                                                                               
            88                                      88                         
            ""                                      88                         
                                                    88                         
8b       d8 88 88,dPYba,,adPYba,            ,adPPYb,88 ,adPPYYba, 8b,dPPYba,   
`8b     d8' 88 88P'   "88"    "8a aaaaaaaa a8"    `Y88 ""     `Y8 88P'   `"8a  
 `8b   d8'  88 88      88      88 """""""" 8b       88 ,adPPPPP88 88       88  
  `8b,d8'   88 88      88      88          "8a,   ,d88 88,    ,88 88       88  
    "8"     88 88      88      88           `"8bbdP"Y8 `"8bbdP"Y8 88       88  
                                                                               
                                                                               
                     _                    _   _           
 _ __ ___  __ _  ___| |_      _ __   __ _| |_(_)_   _____ 
| '__/ _ \/ _` |/ __| __|____| '_ \ / _` | __| \ \ / / _ \
| | |  __/ (_| | (__| ||_____| | | | (_| | |_| |\ V /  __/
|_|  \___|\__,_|\___|\__|    |_| |_|\__,_|\__|_| \_/ \___|
                                                          
Documentation indexed from : https://reactnative.dev/ 
Last parsed on : Wed Apr 10 03:49:21 PM BST 2024
 _           _           
(_)_ __   __| | _____  __
| | '_ \ / _` |/ _ \ \/ /
| | | | | (_| |  __/>  < 
|_|_| |_|\__,_|\___/_/\_\
                         
- & About the New Architecture &
- & Accessibility &
- & AccessibilityInfo &
- & ActionSheetIOS &
- & ActivityIndicator &
- & Alert &
- & Android Native Modules &
- & Android Native UI Components &
- & Animated &
- & Animated.Value &
- & Animated.ValueXY &
- & Animations &
- & Appearance &
- & App Extensions &
- & AppRegistry &
- & AppState &
- & BackHandler &
- & Building For TV Devices &
- & Button &
- & Color Reference &
- & Communication between native and React Native &
- & Core Components and APIs &
- & Core Components and Native Components &
- & 🚧 DatePickerIOS &
- & Debugging Basics &
- & Debugging Release Builds &
- & DevSettings &
- & Dimensions &
- & Direct Manipulation &
- & DrawerLayoutAndroid &
- & DynamicColorIOS &
- & Easing &
- & Fast Refresh &
- & FlatList &
- & Gesture Responder System &
- & Handling Text Input &
- & Handling Touches &
- & Headless JS &
- & Height and Width &
- & Image &
- & ImageBackground &
- & Images &
- & Image Style Props &
- & Improving User Experience &
- & InputAccessoryView &
- & Integration with an Android Fragment &
- & Integration with Existing Apps &
- & InteractionManager &
- & Introduction &
- & iOS Native Modules &
- & iOS Native UI Components &
- & JavaScript Environment &
- & Keyboard &
- & KeyboardAvoidingView &
- & LayoutAnimation &
- & LayoutEvent Object Type &
- & Layout Props &
- & Layout with Flexbox &
- & Learn the Basics &
- & Linking &
- & Linking Libraries &
- & Metro &
- & Modal &
- & More Resources &
- & Native Debugging &
- & Native Modules Intro &
- & Native Modules NPM Package Setup &
- & Navigating Between Screens &
- & Networking &
- & Optimizing Flatlist Configuration &
- & Other Debugging Methods &
- & Out-of-Tree Platforms &
- & PanResponder &
- & Performance Overview &
- & PermissionsAndroid &
- & PixelRatio &
- & Platform &
- & PlatformColor &
- & Platform-Specific Code &
- & Pressable &
- & PressEvent Object Type &
- & Profiling &
- & Profiling with Hermes &
- & 🚧 ProgressViewIOS &
- & Props &
- & Publishing to Apple App Store &
- & Publishing to Google Play Store &
- & RAM Bundles and Inline Requires &
- & React 18 & React Native &
- & React DevTools &
- & React Fundamentals &
- & React Native Gradle Plugin &
- & React Node Object Type &
- & Rect Object Type &
- & RefreshControl &
- & RootTag &
- & Running On Device &
- & Running On Simulator &
- & SafeAreaView &
- & ScrollView &
- & SectionList &
- & Security &
- & Settings &
- & Setting up the development environment &
- & Shadow Props &
- & Share &
- & 🚧 Slider &
- & Speeding Up CI Builds &
- & Speeding up your Build phase &
- & State &
- & StatusBar &
- & Style &
- & StyleSheet &
- & Switch &
- & Systrace &
- & Testing &
- & Text &
- & TextInput &
- & Text Style Props &
- & Timers &
- & ToastAndroid &
- & Toggle navigation &
- & TouchableHighlight &
- & TouchableNativeFeedback &
- & TouchableOpacity &
- & TouchableWithoutFeedback &
- & Transforms &
- & Troubleshooting &
- & Upgrading to new versions &
- & useColorScheme &
- & useWindowDimensions &
- & Using a ScrollView &
- & Using Hermes &
- & Using Libraries &
- & Using List Views &
- & Using TypeScript &
- & Vibration &
- & View &
- & View Style Props &
- & ViewToken Object Type &
- & VirtualizedList &

# About the New Architecture #
    _    _                 _     _   _            _   _               
   / \  | |__   ___  _   _| |_  | |_| |__   ___  | \ | | _____      __
  / _ \ | '_ \ / _ \| | | | __| | __| '_ \ / _ \ |  \| |/ _ \ \ /\ / /
 / ___ \| |_) | (_) | |_| | |_  | |_| | | |  __/ | |\  |  __/\ V  V / 
/_/   \_\_.__/ \___/ \__,_|\__|  \__|_| |_|\___| |_| \_|\___| \_/\_/  
                                                                      
    _             _     _ _            _                  
   / \   _ __ ___| |__ (_) |_ ___  ___| |_ _   _ _ __ ___ 
  / _ \ | '__/ __| '_ \| | __/ _ \/ __| __| | | | '__/ _ \
 / ___ \| | | (__| | | | | ||  __/ (__| |_| |_| | | |  __/
/_/   \_\_|  \___|_| |_|_|\__\___|\___|\__|\__,_|_|  \___|
                                                          
-   Why a New Architecture?
    -   Synchronous Layout and Effects
    -   Support for Concurrent Renderer and Features
    -   Fast JavaScript/Native Interfacing
    -   Learn more
-   What can I expect from enabling the New Architecture?
-   Should I use the New Architecture today?
    -   Enable the New Architecture
About the New Architecture

 info

If you are looking for the New Architecture guides, they have moved to
the working group .

Since 2018, the React Native team has been redesigning the core
internals of React Native to enable developers to create higher-quality
experiences. As of 2024, this version of React Native has been proven at
scale and powers production apps by Meta.

The term New Architecture refers to both the new framework architecture
and the work to bring it to open source.

The New Architecture has been available for experimental opt-in as of
React Native 0.68 with continued improvements in every subsequent
release. The team is now working to make this the default experience for
the React Native open source ecosystem.

Why a New Architecture? 

After many years of building with React Native, the team identified a
set of limitations that prevented developers from crafting certain
experiences with a high polish. These limitations were fundamental to
the existing design of the framework, so the New Architecture started as
an investment in the future of React Native.

The New Architecture unlocks capabilities and improvements that were
impossible in the legacy architecture.

Synchronous Layout and Effects 

Building adaptive UI experiences often requires measuring the size and
position of your views and adjusting layout.

Today, you would use the  onLayout event to get the layout information
of a view and make any adjustments. However, state updates within the
 onLayout callback may apply after painting the previous render. This
means that users may see intermediate states or visual jumps between
rendering the initial layout and responding to layout measurements.

With the New Architecture, we can avoid this issue entirely with
synchronous access to layout information and properly scheduled updates
such that no intermediate state is visible to users.

Example: Rendering a Tooltip

Measuring and placing a tooltip above a view allows us to showcase what
synchronous rendering unlocks. The tooltip needs to know the position of
its target view to determine where it should render.

In the current architecture, we use  onLayout to get the measurements of
the view and then update the positioning of the tooltip based on where
the view is.

    function ViewWithTooltip() {
      // ...

      // We get the layout information and pass to ToolTip to position itself
      const onLayout = React.useCallback(event => {
        targetRef.current?.measureInWindow((x, y, width, height) => {
          // This state update is not guaranteed to run in the same commit
          // This results in a visual "jump" as the ToolTip repositions itself
          setTargetRect({x, y, width, height});
        });
      }, );

      return (
        <>
          <View ref={targetRef} onLayout={onLayout}>
            <Text>Some content that renders a tooltip above</Text>
          </View>
          <Tooltip targetRect={targetRect} />
        </>
      );
    }

 

With the New Architecture, we can use  useLayoutEffect to synchronously
measure and apply layout updates in a single commit, avoiding the visual
"jump".

    function ViewWithTooltip() {
      // ...

      useLayoutEffect(() => {
        // The measurement and state update for `targetRect` happens in a single commit
        // allowing ToolTip to position itself without intermediate paints
        targetRef.current?.measureInWindow((x, y, width, height) => {
          setTargetRect({x, y, width, height});
        });
      }, [setTargetRect]);

      return (
        <>
          <View ref={targetRef}>
            <Text>Some content that renders a tooltip above</Text>
          </View>
          <Tooltip targetRect={targetRect} />
        </>
      );
    }

 

[Asynchronous measurement and render of the ToolTip. See code .]

[Synchronous measurement and render of the ToolTip. See code .]

Support for Concurrent Renderer and Features 

The New Architecture supports concurrent rendering and features that
have shipped in React 18 and beyond. You can now use features like
Suspense for data-fetching, Transitions, and other new React APIs in
your React Native code, further conforming codebases and concepts
between web and native React development.

The concurrent renderer also brings out-of-the-box improvements like
automatic batching, which reduces re-renders in React.

Example: Automatic Batching

With the New Architecture, you'll get automatic batching with the React
18 renderer.

In this example, a slider specifies how many tiles to render. Dragging
the slider from 0 to 1000 will fire off a quick succession of state
updates and re-renders.

In comparing the renderers for the same code , you can visually notice
the renderer provides a smoother UI, with less intermediate UI updates.
State updates from native event handlers, like this native Slider
component, are now batched.

[Rendering frequent state updates with legacy renderer.]

[Rendering frequent state updates with React 18 renderer.]

New concurrent features, like Transitions , give you the power to
express the priority of UI updates. Marking an update as lower priority
tells React it can "interrupt" rendering the update to handle higher
priority updates to ensure a responsive user experience where it
matters.

Example: Using  startTransition

We can build on the previous example to showcase how transitions can
interrupt in-progress rendering to handle a newer state update.

We wrap the tile number state update with  startTransition to indicate
that rendering the tiles can be interrupted.  startTransition also
provides a  isPending flag to tell us when the transition is complete.

    function TileSlider({value, onValueChange}) {
      const [isPending, startTransition] = useTransition();

      return (
        <>
          <View>
            <Text>
              Render {value} Tiles
            </Text>
            <ActivityIndicator animating={isPending} />
          </View>
          <Slider
            value={1}
            minimumValue={1}
            maximumValue={1000}
            step={1}
            onValueChange={newValue => {
              startTransition(() => {
                onValueChange(newValue);
              });
            }}
          />
        </>
      );
    }

    function ManyTiles() {
      const [value, setValue] = useState(1);
      const tiles = generateTileViews(value);
      return (
          <TileSlider onValueChange={setValue} value={value} />
          <View>
            {tiles}
          </View>
      )
    }

 

You'll notice that with the frequent updates in a transition, React
renders fewer intermediate states because it bails out of rendering the
state as soon as it becomes stale. In comparison, without transitions,
more intermediate states are rendered. Both examples still use automatic
batching. Still, transitions give even more power to developers to batch
in-progress renders.

[Rendering tiles with transitions to interrupt in-progress renders of
stale state. See code .]

[Rendering tiles without marking it as a transition. See code .]

Fast JavaScript/Native Interfacing 

The New Architecture removes the asynchronous bridge between JavaScript
and native and replaces it with JavaScript Interface (JSI). JSI is an
interface that allows JavaScript to hold a reference to a C++ object and
vice-versa. With a memory reference, you can directly invoke methods
without serialization costs.

JSI enables VisionCamera , a popular camera library for React Native, to
process frames in real time. Typical frame buffers are 10 MB, which
amounts to roughly 1 GB of data per second, depending on the frame rate.
In comparison with the serialization costs of the bridge, JSI handles
that amount of interfacing data with ease. JSI can expose other complex
instance-based types such as databases, images, audio samples, etc.

JSI adoption in the New Architecture removes this class of serialization
work from all native-JavaScript interop. This includes initializing and
re-rendering native core components like  View and  Text . You can read
more about our investigation in rendering performance in the New
Architecture and the improved benchmarks we measured.

Learn more 

To achieve this, the New Architecture had to refactor multiple parts of
the React Native infrastructure. To learn more about the refactor and
other benefits it brings, check out the documentation in the New
Architecture working group.

What can I expect from enabling the New Architecture? 

While the New Architecture enables these features and improvements,
enabling the New Architecture for your app or library may not
immediately improve the performance or user experience.

For example, your code may need refactoring to leverage new capabilities
like synchronous layout effects or concurrent features. Although JSI
will minimize the overhead between JavaScript and native memory, data
serialization may not have been a bottleneck for your app's performance.

Enabling the New Architecture in your app or library is opting into the
future of React Native.

The team is actively researching and developing new capabilities the New
Architecture unlocks. For example, web alignment is an active area of
exploration at Meta that will ship to the React Native open source
ecosystem.

-   Updates to the event loop model
-   Node and layout APIs
-   Styling and layout conformance

You can follow along and contribute in our dedicated discussions &
proposals repository.

Should I use the New Architecture today? 

Today, the New Architecture is considered experimental and we continue
to refine backwards compatibility for a better adoption experience.

The team plans to enable the New Architecture by default in an upcoming
React Native release by the end of 2024.

Our guidance is as follows

-   For most production apps, we do not recommend enabling the New
    Architecture today. Waiting for the official release will offer the
    best experience.
-   If you maintain a React Native library, we recommend enabling it and
    verifying your use cases are covered. You can find the instructions
    here .

Enable the New Architecture 

If you are interested in dogfooding the New Architecture experience, you
can find instructions in our dedicated working group. The New
Architecture working group is a dedicated space for support and
coordination for New Architecture adoption and where the team posts
regular updates.

# Accessibility #
    _                         _ _     _ _ _ _         
   / \   ___ ___ ___  ___ ___(_) |__ (_) (_) |_ _   _ 
  / _ \ / __/ __/ _ \/ __/ __| | '_ \| | | | __| | | |
 / ___ \ (_| (_|  __/\__ \__ \ | |_) | | | | |_| |_| |
/_/   \_\___\___\___||___/___/_|_.__/|_|_|_|\__|\__, |
                                                |___/ 
-   Accessibility properties
    -    accessible
    -    accessibilityLabel
    -    accessibilityLabelledBy
        Android
    -    accessibilityHint
    -    accessibilityLanguage
        iOS
    -    accessibilityIgnoresInvertColors
        iOS
    -    accessibilityLiveRegion
        Android
    -    accessibilityRole
    -    accessibilityState
    -    accessibilityValue
    -    accessibilityViewIsModal
        iOS
    -    accessibilityElementsHidden
        iOS
    -    aria-valuemax
    -    aria-valuemin
    -    aria-valuenow
    -    aria-valuetext
    -    aria-busy
    -    aria-checked
    -    aria-disabled
    -    aria-expanded
    -    aria-hidden
    -    aria-label
    -    aria-labelledby
        Android
    -    aria-live
        Android
    -    aria-modal
        iOS
    -    aria-selected
    -    importantForAccessibility
        Android
    -    onAccessibilityEscape
        iOS
    -    onAccessibilityTap
    -    onMagicTap
        iOS
    -    role
-   Accessibility Actions
-   Checking if a Screen Reader is Enabled
-   Sending Accessibility Events
    Android
-   Testing TalkBack Support
    Android
-   Testing VoiceOver Support
    iOS
-   Additional Resources
Accessibility

Both Android and iOS provide APIs for integrating apps with assistive
technologies like the bundled screen readers VoiceOver (iOS) and
TalkBack (Android). React Native has complementary APIs that let your
app accommodate all users.

 info

Android and iOS differ slightly in their approaches, and thus the React
Native implementations may vary by platform.

Accessibility properties 

 accessible 

When  true , indicates that the view is an accessibility element. When a
view is an accessibility element, it groups its children into a single
selectable component. By default, all touchable elements are accessible.

On Android,  accessible={true} property for a react-native View will be
translated into native  focusable={true} .

    <View accessible={true}>
      <Text>text one</Text>
      <Text>text two</Text>
    </View>

 

In the above example, accessibility focus is only available on the
parent view with the  accessible property, and not individually for
'text one' and 'text two'.

 accessibilityLabel 

When a view is marked as accessible, it is a good practice to set an
 accessibilityLabel on the view, so that people who use VoiceOver or
TalkBack know what element they have selected. A screen reader will
verbalize this string when the associated element is selected.

To use, set the  accessibilityLabel property to a custom string on your
View, Text, or Touchable:

    <TouchableOpacity
      accessible={true}
      accessibilityLabel="Tap me!"
      onPress={onPress}>
      <View style={styles.button}>
        <Text style={styles.buttonText}>Press me!</Text>
      </View>
    </TouchableOpacity>

 

In the above example, the  accessibilityLabel on the TouchableOpacity
element would default to "Press me!". The label is constructed by
concatenating all Text node children separated by spaces.

 accessibilityLabelledBy

Android



A reference to another element nativeID used to build complex forms. The
value of  accessibilityLabelledBy should match the  nativeID of the
related element:

    <View>
      <Text nativeID="formLabel">Label for Input Field</Text>
      <TextInput
        accessibilityLabel="input"
        accessibilityLabelledBy="formLabel"
      />
    </View>

 

In the above example, the screen reader announces
 Input, Edit Box for Label for Input Field when focusing on the
TextInput.

 accessibilityHint 

An accessibility hint can be used to provide additional context to the
user on the result of the action when it is not clear from the
accessibility label alone.

Provide the  accessibilityHint property a custom string on your View,
Text, or Touchable:

    <TouchableOpacity
      accessible={true}
      accessibilityLabel="Go back"
      accessibilityHint="Navigates to the previous screen"
      onPress={onPress}>
      <View style={styles.button}>
        <Text style={styles.buttonText}>Back</Text>
      </View>
    </TouchableOpacity>

 

iOS

In the above example, VoiceOver will read the hint after the label, if
the user has hints enabled in the device's VoiceOver settings. Read more
about guidelines for  accessibilityHint in the iOS Developer Docs

Android

In the above example, TalkBack will read the hint after the label. At
this time, hints cannot be turned off on Android.

 accessibilityLanguage

iOS



By using the  accessibilityLanguage property, the screen reader will
understand which language to use while reading the element's label ,
value , and hint . The provided string value must follow the BCP 47
specification .

    <View
      accessible={true}
      accessibilityLabel="Pizza"
      accessibilityLanguage="it-IT">
      <Text>🍕</Text>
    </View>

 

 accessibilityIgnoresInvertColors

iOS



Inverting screen colors is an accessibility feature available in iOS and
iPadOS for people with color blindness, low vision, or vision
impairment. If there's a view you don't want to invert when this setting
is on, possibly a photo, set this property to  true .

 accessibilityLiveRegion

Android



When components dynamically change, we want TalkBack to alert the end
user. This is made possible by the  accessibilityLiveRegion property. It
can be set to  none ,  polite , and  assertive :

-   none Accessibility services should not announce changes to this
    view.
-   polite Accessibility services should announce changes to this view.
-   assertive Accessibility services should interrupt ongoing speech to
    immediately announce changes to this view.

    <TouchableWithoutFeedback onPress={addOne}>
      <View style={styles.embedded}>
        <Text>Click me</Text>
      </View>
    </TouchableWithoutFeedback>
    <Text accessibilityLiveRegion="polite">
      Clicked {count} times
    </Text>

 

In the above example method  addOne changes the state variable  count .
When the TouchableWithoutFeedback is triggered, TalkBack reads the text
in the Text view because of its  accessibilityLiveRegion="polite"
property.

 accessibilityRole 

 accessibilityRole communicates the purpose of a component to the user
of assistive technology.

 accessibilityRole can be one of the following:

-   adjustable Used when an element can be "adjusted" (e.g. a slider).
-   alert Used when an element contains important text to be presented
    to the user.
-   button Used when the element should be treated as a button.
-   checkbox Used when an element represents a checkbox that can be
    checked, unchecked, or have a mixed checked state.
-   combobox Used when an element represents a combo box, which allows
    the user to select among several choices.
-   header Used when an element acts as a header for a content section
    (e.g. the title of a navigation bar).
-   image Used when the element should be treated as an image. Can be
    combined with a button or link.
-   imagebutton Used when the element should be treated as a button and
    is also an image.
-   keyboardkey Used when the element acts as a keyboard key.
-   link Used when the element should be treated as a link.
-   menu Used when the component is a menu of choices.
-   menubar Used when a component is a container of multiple menus.
-   menuitem Used to represent an item within a menu.
-   none Used when the element has no role.
-   progressbar Used to represent a component that indicates the
    progress of a task.
-   radio Used to represent a radio button.
-   radiogroup Used to represent a group of radio buttons.
-   scrollbar Used to represent a scroll bar.
-   search Used when a text field element should also be treated as a
    search field.
-   spinbutton Used to represent a button that opens a list of choices.
-   summary Used when an element can be used to provide a quick summary
    of current conditions in the app when the app first launches.
-   switch Used to represent a switch that can be turned on and off.
-   tab Used to represent a tab.
-   tablist Used to represent a list of tabs.
-   text Used when the element should be treated as static text that
    cannot change.
-   timer Used to represent a timer.
-   togglebutton Used to represent a toggle button. Should be used with
    accessibilityState checked to indicate if the button is toggled on
    or off.
-   toolbar Used to represent a toolbar (a container of action buttons
    or components).
-   grid Used with ScrollView, VirtualizedList, FlatList, or SectionList
    to represent a grid. Adds the in/out of grid announcements to
    Android's GridView.

 accessibilityState 

Describes the current state of a component to the assistive technology
user.

 accessibilityState is an object. It contains the following fields:

  Name       Description                                                                                                                             Type                 Required
  ---------- --------------------------------------------------------------------------------------------------------------------------------------- -------------------- ----------
  disabled   Indicates whether the element is disabled or not.                                                                                       boolean              No
  selected   Indicates whether a selectable element is currently selected or not.                                                                    boolean              No
  checked    Indicates the state of a checkable element. This field can either take a boolean or the "mixed" string to represent mixed checkboxes.   boolean or 'mixed'   No
  busy       Indicates whether an element is currently busy or not.                                                                                  boolean              No
  expanded   Indicates whether an expandable element is currently expanded or collapsed.                                                             boolean              No

To use, set the  accessibilityState to an object with a specific
definition.

 accessibilityValue 

Represents the current value of a component. It can be a textual
description of a component's value, or for range-based components, such
as sliders and progress bars, it contains range information (minimum,
current, and maximum).

 accessibilityValue is an object. It contains the following fields:

  Name   Description                                                                                     Type      Required
  ------ ----------------------------------------------------------------------------------------------- --------- --------------------------
  min    The minimum value of this component's range.                                                    integer   Required if  now is set.
  max    The maximum value of this component's range.                                                    integer   Required if  now is set.
  now    The current value of this component's range.                                                    integer   No
  text   A textual description of this component's value. Will override  min ,  now , and  max if set.   string    No

 accessibilityViewIsModal

iOS



A boolean value that indicates whether VoiceOver should ignore the
elements within views that are siblings of the receiver.

For example, in a window that contains sibling views  A and  B , setting
 accessibilityViewIsModal to  true on view  B causes VoiceOver to ignore
the elements in view  A . On the other hand, if view  B contains a child
view  C and you set  accessibilityViewIsModal to  true on view  C ,
VoiceOver does not ignore the elements in view  A .

 accessibilityElementsHidden

iOS



A boolean value indicating whether the accessibility elements contained
within this accessibility element are hidden.

For example, in a window that contains sibling views  A and  B , setting
 accessibilityElementsHidden to  true on view  B causes VoiceOver to
ignore the elements in view  B . This is similar to the Android property
 importantForAccessibility="no-hide-descendants" .

 aria-valuemax 

Represents the maximum value for range-based components, such as sliders
and progress bars.

 aria-valuemin 

Represents the minimum value for range-based components, such as sliders
and progress bars.

 aria-valuenow 

Represents the current value for range-based components, such as sliders
and progress bars.

 aria-valuetext 

Represents the textual description of the component.

 aria-busy 

Indicates an element is being modified and that assistive technologies
may want to wait until the changes are complete before informing the
user about the update.

  Type      Default
  --------- ---------
  boolean   false

 aria-checked 

Indicates the state of a checkable element. This field can either take a
boolean or the "mixed" string to represent mixed checkboxes.

  Type               Default
  ------------------ ---------
  boolean, 'mixed'   false

 aria-disabled 

Indicates that the element is perceivable but disabled, so it is not
editable or otherwise operable.

  Type      Default
  --------- ---------
  boolean   false

 aria-expanded 

Indicates whether an expandable element is currently expanded or
collapsed.

  Type      Default
  --------- ---------
  boolean   false

 aria-hidden 

Indicates whether the accessibility elements contained within this
accessibility element are hidden.

For example, in a window that contains sibling views  A and  B , setting
 aria-hidden to  true on view  B causes VoiceOver to ignore the elements
in view  B .

  Type      Default
  --------- ---------
  boolean   false

 aria-label 

Defines a string value that labels an interactive element.

  Type
  --------
  string

 aria-labelledby

Android



Identifies the element that labels the element it is applied to. The
value of  aria-labelledby should match the  nativeID of the related
element:

    <View>
      <Text nativeID="formLabel">Label for Input Field</Text>
      <TextInput aria-label="input" aria-labelledby="formLabel" />
    </View>

 

  Type
  --------
  string

 aria-live

Android



Indicates that an element will be updated and describes the types of
updates the user agents, assistive technologies, and user can expect
from the live region.

-   off Accessibility services should not announce changes to this view.
-   polite Accessibility services should announce changes to this view.
-   assertive Accessibility services should interrupt ongoing speech to
    immediately announce changes to this view.

  Type                                        Default
  ------------------------------------------- ---------
  enum(  'assertive' ,  'off' ,  'polite' )    'off'

------------------------------------------------------------------------

 aria-modal

iOS



Boolean value indicating whether VoiceOver should ignore the elements
within views that are siblings of the receiver.

  Type      Default
  --------- ---------
  boolean   false

 aria-selected 

Indicates whether a selectable element is currently selected or not.

  Type
  ---------
  boolean

 importantForAccessibility

Android



In the case of two overlapping UI components with the same parent,
default accessibility focus can have unpredictable behavior. The
 importantForAccessibility property will resolve this by controlling if
a view fires accessibility events and if it is reported to accessibility
services. It can be set to  auto ,  yes ,  no and  no-hide-descendants
(the last value will force accessibility services to ignore the
component and all of its children).

    <View style={styles.container}>
      <View
        style={[styles.layout, {backgroundColor: 'green'}]}
        importantForAccessibility="yes">
        <Text>First layout</Text>
      </View>
      <View
        style={[styles.layout, {backgroundColor: 'yellow'}]}
        importantForAccessibility="no-hide-descendants">
        <Text>Second layout</Text>
      </View>
    </View>

 

In the above example, the  yellow layout and its descendants are
completely invisible to TalkBack and all other accessibility services.
So we can use overlapping views with the same parent without confusing
TalkBack.

 onAccessibilityEscape

iOS



Assign this property to a custom function which will be called when
someone performs the "escape" gesture, which is a two finger Z shaped
gesture. An escape function should move back hierarchically in the user
interface. This can mean moving up or back in a navigation hierarchy or
dismissing a modal user interface. If the selected element does not have
an  onAccessibilityEscape function, the system will attempt to traverse
up the view hierarchy until it finds a view that does or bonk to
indicate it was unable to find one.

 onAccessibilityTap 

Use this property to assign a custom function to be called when someone
activates an accessible element by double tapping on it while it's
selected.

 onMagicTap

iOS



Assign this property to a custom function which will be called when
someone performs the "magic tap" gesture, which is a double-tap with two
fingers. A magic tap function should perform the most relevant action a
user could take on a component. In the Phone app on iPhone, a magic tap
answers a phone call or ends the current one. If the selected element
does not have an  onMagicTap function, the system will traverse up the
view hierarchy until it finds a view that does.

 role 

 role communicates the purpose of a component and has precedence over
the  accessibilityRole prop.

 role can be one of the following:

-   alert Used when an element contains important text to be presented
    to the user.
-   button Used when the element should be treated as a button.
-   checkbox Used when an element represents a checkbox that can be
    checked, unchecked, or have a mixed checked state.
-   combobox Used when an element represents a combo box, which allows
    the user to select among several choices.
-   grid Used with ScrollView, VirtualizedList, FlatList, or SectionList
    to represent a grid. Adds the in/out of grid announcements to the
    android GridView.
-   heading Used when an element acts as a header for a content section
    (e.g. the title of a navigation bar).
-   img Used when the element should be treated as an image. Can be
    combined with a button or link, for example.
-   link Used when the element should be treated as a link.
-   list Used to identify a list of items.
-   menu Used when the component is a menu of choices.
-   menubar Used when a component is a container of multiple menus.
-   menuitem Used to represent an item within a menu.
-   none Used when the element has no role.
-   presentation Used when the element has no role.
-   progressbar Used to represent a component that indicates the
    progress of a task.
-   radio Used to represent a radio button.
-   radiogroup Used to represent a group of radio buttons.
-   scrollbar Used to represent a scroll bar.
-   searchbox Used when the text field element should also be treated as
    a search field.
-   slider Used when an element can be "adjusted" (e.g. a slider).
-   spinbutton Used to represent a button that opens a list of choices.
-   summary Used when an element can be used to provide a quick summary
    of current conditions in the app when the app first launches.
-   switch Used to represent a switch that can be turned on and off.
-   tab Used to represent a tab.
-   tablist Used to represent a list of tabs.
-   timer Used to represent a timer.
-   toolbar Used to represent a toolbar (a container of action buttons
    or components).

Accessibility Actions 

Accessibility actions allow assistive technology to programmatically
invoke the action(s) of a component. To support accessibility actions, a
component must do two things:

-   Define the list of actions it supports via the  accessibilityActions
    property.
-   Implement an  onAccessibilityAction function to handle action
    requests.

The  accessibilityActions property should contain a list of action
objects. Each action object should contain the following fields:

  Name    Type     Required
  ------- -------- ----------
  name    string   Yes
  label   string   No

Actions either represent standard actions, such as clicking a button or
adjusting a slider, or custom actions specific to a given component such
as deleting an email message. The  name field is required for both
standard and custom actions, but  label is optional for standard
actions.

When adding support for standard actions,  name must be one of the
following:

-    'magicTap' - iOS only - While VoiceOver focus is on or inside the
    component, the user double tapped with two fingers.
-    'escape' - iOS only - While VoiceOver focus is on or inside the
    component, the user performed a two-finger scrub gesture (left,
    right, left).
-    'activate' - Activate the component. This should perform the same
    action with, or without, assistive technology. Engaged when a screen
    reader user double taps the component.
-    'increment' - Increment an adjustable component. On iOS, VoiceOver
    generates this action when the component has a role of  'adjustable'
    and the user places focus on it and swipes upward. On Android,
    TalkBack generates this action when the user places accessibility
    focus on the component and presses the volume-up button.
-    'decrement' - Decrement an adjustable component. On iOS, VoiceOver
    generates this action when the component has a role of  'adjustable'
    and the user places focus on it and swipes downward. On Android,
    TalkBack generates this action when the user places accessibility
    focus on the component and presses the volume-down button.
-    'longpress' - Android only - This action is generated when the user
    places accessibility focus on the component, then double-taps and
    holds one finger on the screen. This should perform the same action
    with, or without, assistive technology.

The  label field is optional for standard actions and is often unused by
assistive technologies. For custom actions, it is a localized string
containing a description of the action to be presented to the user.

To handle action requests, a component must implement an
 onAccessibilityAction function. The only argument to this function is
an event containing the name of the action to perform. The below example
from RNTester shows how to create a component that defines and handles
several custom actions.

    <View
      accessible={true}
      accessibilityActions={[
        {name: 'cut', label: 'cut'},
        {name: 'copy', label: 'copy'},
        {name: 'paste', label: 'paste'},
      ]}
      onAccessibilityAction={event => {
        switch (event.nativeEvent.actionName) {
          case 'cut':
            Alert.alert('Alert', 'cut action success');
            break;
          case 'copy':
            Alert.alert('Alert', 'copy action success');
            break;
          case 'paste':
            Alert.alert('Alert', 'paste action success');
            break;
        }
      }}
    />

 

Checking if a Screen Reader is Enabled 

The  AccessibilityInfo API allows you to determine whether or not a
screen reader is currently active. See the AccessibilityInfo
documentation for details.

Sending Accessibility Events

Android



Sometimes it is useful to trigger an accessibility event on a UI
component (i.e. when a custom view appears on a screen or set
accessibility focus to a view). Native UIManager module exposes a method
‘sendAccessibilityEvent’ for this purpose. It takes two arguments: a
view tag and a type of event. The supported event types are
 typeWindowStateChanged ,  typeViewFocused , and  typeViewClicked .

    import {Platform, UIManager, findNodeHandle} from 'react-native';

    if (Platform.OS === 'android') {
      UIManager.sendAccessibilityEvent(
        findNodeHandle(this),
        UIManager.AccessibilityEventTypes.typeViewFocused,
      );
    }

 

Testing TalkBack Support

Android



To enable TalkBack, go to the Settings app on your Android device or
emulator. Tap Accessibility, then TalkBack. Toggle the "Use service"
switch to enable or disable it.

Android emulators don't have TalkBack installed by default. You can
install TalkBack on your emulator via the Google Play Store. Make sure
to choose an emulator with the Google Play store installed. These are
available in Android Studio.

You can use the volume key shortcut to toggle TalkBack. To turn on the
volume key shortcut, go to the Settings app, then Accessibility. At the
top, turn on the volume key shortcut.

To use the volume key shortcut, press both volume keys for 3 seconds to
start an accessibility tool.

Additionally, if you prefer, you can toggle TalkBack via the command
line with:

    # disable
    adb shell settings put secure enabled_accessibility_services com.android.talkback/com.google.android.marvin.talkback.TalkBackService

    # enable
    adb shell settings put secure enabled_accessibility_services com.google.android.marvin.talkback/com.google.android.marvin.talkback.TalkBackService

 

Testing VoiceOver Support

iOS



To enable VoiceOver on your iOS or iPadOS device, go to the Settings
app, tap General, then Accessibility. There you will find many tools
available for people to enable their devices to be more usable,
including VoiceOver. To enable VoiceOver, tap on VoiceOver under
"Vision" and toggle the switch that appears at the top.

At the very bottom of the Accessibility settings, there is an
"Accessibility Shortcut". You can use this to toggle VoiceOver by
triple-clicking the Home button.

VoiceOver isn't available via the simulator, but you can use
Accessibility Inspector from Xcode to use the macOS VoiceOver through an
application. Note it's always best to test with a device as macOS's
VoiceOver may result in varied experiences.

Additional Resources 

-   Making React Native Apps Accessible

# AccessibilityInfo #
    _                         _ _     _ _ _ _         ___        __       
   / \   ___ ___ ___  ___ ___(_) |__ (_) (_) |_ _   _|_ _|_ __  / _| ___  
  / _ \ / __/ __/ _ \/ __/ __| | '_ \| | | | __| | | || || '_ \| |_ / _ \ 
 / ___ \ (_| (_|  __/\__ \__ \ | |_) | | | | |_| |_| || || | | |  _| (_) |
/_/   \_\___\___\___||___/___/_|_.__/|_|_|_|\__|\__, |___|_| |_|_|  \___/ 
                                                |___/                     
-   Example
-   Methods
    -    addEventListener()
    -    announceForAccessibility()
    -    announceForAccessibilityWithOptions()
    -    getRecommendedTimeoutMillis()
        Android
    -    isAccessibilityServiceEnabled()
        Android
    -    isBoldTextEnabled()
        iOS
    -    isGrayscaleEnabled()
        iOS
    -    isInvertColorsEnabled()
        iOS
    -    isReduceMotionEnabled()
    -    isReduceTransparencyEnabled()
        iOS
    -    isScreenReaderEnabled()
    -    prefersCrossFadeTransitions()
        iOS
    -    setAccessibilityFocus()
AccessibilityInfo

Sometimes it's useful to know whether or not the device has a screen
reader that is currently active. The  AccessibilityInfo API is designed
for this purpose. You can use it to query the current state of the
screen reader as well as to register to be notified when the state of
the screen reader changes.

Example 

------------------------------------------------------------------------

Reference

Methods 

 addEventListener() 

    static addEventListener(
      eventName: AccessibilityChangeEventName | AccessibilityAnnouncementEventName,
      handler: (
        event: AccessibilityChangeEvent | AccessibilityAnnouncementFinishedEvent,
      ) => void,
    ): EmitterSubscription;

 

Add an event handler. Supported events:

+-----------------------------------+-----------------------------------+
| Event name                        | Description                       |
+===================================+===================================+
|  accessibilityServiceChanged      | Fires when some services such as  |
|                                   | TalkBack, other Android assistive |
| Android                           | technologies, and third-party     |
|                                   | accessibility services are        |
|                                   | enabled. The argument to the      |
|                                   | event handler is a boolean. The   |
|                                   | boolean is  true when a some      |
|                                   | accessibility services is enabled |
|                                   | and  false otherwise.             |
+-----------------------------------+-----------------------------------+
|  announcementFinished             | Fires when the screen reader has  |
|                                   | finished making an announcement.  |
| iOS                               | The argument to the event handler |
|                                   | is a dictionary with these keys:  |
|                                   |                                   |
|                                   | -    announcement : The string    |
|                                   |     announced by the screen       |
|                                   |     reader.                       |
|                                   | -    success : A boolean          |
|                                   |     indicating whether the        |
|                                   |     announcement was successfully |
|                                   |     made.                         |
+-----------------------------------+-----------------------------------+
|  boldTextChanged                  | Fires when the state of the bold  |
|                                   | text toggle changes. The argument |
| iOS                               | to the event handler is a         |
|                                   | boolean. The boolean is  true     |
|                                   | when bold text is enabled and     |
|                                   |  false otherwise.                 |
+-----------------------------------+-----------------------------------+
|  grayscaleChanged                 | Fires when the state of the gray  |
|                                   | scale toggle changes. The         |
| iOS                               | argument to the event handler is  |
|                                   | a boolean. The boolean is  true   |
|                                   | when a gray scale is enabled and  |
|                                   |  false otherwise.                 |
+-----------------------------------+-----------------------------------+
|  invertColorsChanged              | Fires when the state of the       |
|                                   | invert colors toggle changes. The |
| iOS                               | argument to the event handler is  |
|                                   | a boolean. The boolean is  true   |
|                                   | when invert colors is enabled and |
|                                   |  false otherwise.                 |
+-----------------------------------+-----------------------------------+
|  reduceMotionChanged              | Fires when the state of the       |
|                                   | reduce motion toggle changes. The |
|                                   | argument to the event handler is  |
|                                   | a boolean. The boolean is  true   |
|                                   | when a reduce motion is enabled   |
|                                   | (or when "Transition Animation    |
|                                   | Scale" in "Developer options" is  |
|                                   | "Animation off") and  false       |
|                                   | otherwise.                        |
+-----------------------------------+-----------------------------------+
|  reduceTransparencyChanged        | Fires when the state of the       |
|                                   | reduce transparency toggle        |
| iOS                               | changes. The argument to the      |
|                                   | event handler is a boolean. The   |
|                                   | boolean is  true when reduce      |
|                                   | transparency is enabled and       |
|                                   |  false otherwise.                 |
+-----------------------------------+-----------------------------------+
|  screenReaderChanged              | Fires when the state of the       |
|                                   | screen reader changes. The        |
|                                   | argument to the event handler is  |
|                                   | a boolean. The boolean is  true   |
|                                   | when a screen reader is enabled   |
|                                   | and  false otherwise.             |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 announceForAccessibility() 

    static announceForAccessibility(announcement: string);

 

Post a string to be announced by the screen reader.

------------------------------------------------------------------------

 announceForAccessibilityWithOptions() 

    static announceForAccessibilityWithOptions(
      announcement: string,
      options: options: {queue?: boolean},
    );

 

Post a string to be announced by the screen reader with modification
options. By default announcements will interrupt any existing speech,
but on iOS they can be queued behind existing speech by setting  queue
to  true in the options object.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| announcement          | string                | The string to be      |
|                       |                       | announced             |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+
| options               | object                |  queue - queue the    |
|                       |                       | announcement behind   |
| Required              |                       | existing speech       |
|                       |                       |                       |
|                       |                       | iOS                   |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 getRecommendedTimeoutMillis()

Android



    static getRecommendedTimeoutMillis(originalTimeout: number): Promise<number>;

 

Gets the timeout in millisecond that the user needs. This value is set
in "Time to take action (Accessibility timeout)" of "Accessibility"
settings.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| originalTimeout       | number                | The timeout to return |
|                       |                       | if "Accessibility     |
| Required              |                       | timeout" is not set.  |
|                       |                       | Specify in            |
|                       |                       | milliseconds.         |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 isAccessibilityServiceEnabled()

Android



    static isAccessibilityServiceEnabled(): Promise<boolean>;

 

Check whether any accessibility service is enabled. This includes
TalkBack but also any third-party accessibility app that may be
installed. To only check whether TalkBack is enabled, use
isScreenReaderEnabled . Returns a promise which resolves to a boolean.
The result is  true when some accessibility services is enabled and
 false otherwise.

  Note : Please use isScreenReaderEnabled if you only want to check the
  status of TalkBack.

------------------------------------------------------------------------

 isBoldTextEnabled()

iOS



    static isBoldTextEnabled(): Promise<boolean>:

 

Query whether a bold text is currently enabled. Returns a promise which
resolves to a boolean. The result is  true when bold text is enabled and
 false otherwise.

------------------------------------------------------------------------

 isGrayscaleEnabled()

iOS



    static isGrayscaleEnabled(): Promise<boolean>;

 

Query whether grayscale is currently enabled. Returns a promise which
resolves to a boolean. The result is  true when grayscale is enabled and
 false otherwise.

------------------------------------------------------------------------

 isInvertColorsEnabled()

iOS



    static isInvertColorsEnabled(): Promise<boolean>;

 

Query whether invert colors is currently enabled. Returns a promise
which resolves to a boolean. The result is  true when invert colors is
enabled and  false otherwise.

------------------------------------------------------------------------

 isReduceMotionEnabled() 

    static isReduceMotionEnabled(): Promise<boolean>;

 

Query whether reduce motion is currently enabled. Returns a promise
which resolves to a boolean. The result is  true when reduce motion is
enabled and  false otherwise.

------------------------------------------------------------------------

 isReduceTransparencyEnabled()

iOS



    static isReduceTransparencyEnabled(): Promise<boolean>;

 

Query whether reduce transparency is currently enabled. Returns a
promise which resolves to a boolean. The result is  true when a reduce
transparency is enabled and  false otherwise.

------------------------------------------------------------------------

 isScreenReaderEnabled() 

    static isScreenReaderEnabled(): Promise<boolean>;

 

Query whether a screen reader is currently enabled. Returns a promise
which resolves to a boolean. The result is  true when a screen reader is
enabled and  false otherwise.

------------------------------------------------------------------------

 prefersCrossFadeTransitions()

iOS



    static prefersCrossFadeTransitions(): Promise<boolean>;

 

Query whether reduce motion and prefer cross-fade transitions settings
are currently enabled. Returns a promise which resolves to a boolean.
The result is  true when prefer cross-fade transitions is enabled and
 false otherwise.

------------------------------------------------------------------------

 setAccessibilityFocus() 

    static setAccessibilityFocus(reactTag: number);

 

Set accessibility focus to a React component.

On Android, this calls  UIManager.sendAccessibilityEvent method with
passed  reactTag and  UIManager.AccessibilityEventTypes.typeViewFocused
arguments.

  Note : Make sure that any  View you want to receive the accessibility
  focus has  accessible={true} .

# ActionSheetIOS #
    _        _   _             ____  _               _   ___ ___  ____  
   / \   ___| |_(_) ___  _ __ / ___|| |__   ___  ___| |_|_ _/ _ \/ ___| 
  / _ \ / __| __| |/ _ \| '_ \\___ \| '_ \ / _ \/ _ \ __|| | | | \___ \ 
 / ___ \ (__| |_| | (_) | | | |___) | | | |  __/  __/ |_ | | |_| |___) |
/_/   \_\___|\__|_|\___/|_| |_|____/|_| |_|\___|\___|\__|___\___/|____/ 
                                                                        
-   Example
-   Methods
    -    showActionSheetWithOptions()
    -    dismissActionSheet()
    -    showShareActionSheetWithOptions()
ActionSheetIOS

Displays native to iOS Action Sheet component.

Example 

Reference

Methods 

 showActionSheetWithOptions() 

    static showActionSheetWithOptions: (
      options: ActionSheetIOSOptions,
      callback: (buttonIndex: number) => void,
    );

 

Display an iOS action sheet. The  options object must contain one or
more of:

-    options (array of strings) - a list of button titles (required)
-    cancelButtonIndex (int) - index of cancel button in  options
-    cancelButtonTintColor (string) - the color used for the change the
    text color of the cancel button
-    destructiveButtonIndex (int or array of ints) - indices of
    destructive buttons in  options
-    title (string) - a title to show above the action sheet
-    message (string) - a message to show below the title
-    anchor (number) - the node to which the action sheet should be
    anchored (used for iPad)
-    tintColor (string) - the color used for non-destructive button
    titles
-    disabledButtonIndices (array of numbers) - a list of button indices
    which should be disabled
-    userInterfaceStyle (string) - the interface style used for the
    action sheet, can be set to  light or  dark , otherwise the default
    system style will be used

The 'callback' function takes one parameter, the zero-based index of the
selected item.

Minimal example:

    ActionSheetIOS.showActionSheetWithOptions(
      {
        options: ['Cancel', 'Remove'],
        destructiveButtonIndex: 1,
        cancelButtonIndex: 0,
      },
      buttonIndex => {
        if (buttonIndex === 1) {
          /* destructive action */
        }
      },
    );

 

------------------------------------------------------------------------

 dismissActionSheet() 

    static dismissActionSheet();

 

Dismisses the most upper iOS action sheet presented, if no action sheet
is present a warning is displayed.

------------------------------------------------------------------------

 showShareActionSheetWithOptions() 

    static showShareActionSheetWithOptions: (
      options: ShareActionSheetIOSOptions,
      failureCallback: (error: Error) => void,
      successCallback: (success: boolean, method: string) => void,
    );

 

Display the iOS share sheet. The  options object should contain one or
both of  message and  url and can additionally have a  subject or
 excludedActivityTypes :

-    url (string) - a URL to share
-    message (string) - a message to share
-    subject (string) - a subject for the message
-    excludedActivityTypes (array) - the activities to exclude from the
    ActionSheet

  Note: If  url points to a local file, or is a base64-encoded uri, the
  file it points to will be loaded and shared directly. In this way, you
  can share images, videos, PDF files, etc. If  url points to a remote
  file or address it must conform to URL format as described in RFC 2396
  . For example, a web URL without a proper protocol (HTTP/HTTPS) will
  not be shared.

The 'failureCallback' function takes one parameter, an error object. The
only property defined on this object is an optional  stack property of
type  string .

The 'successCallback' function takes two parameters:

-   a boolean value signifying success or failure
-   a string that, in the case of success, indicates the method of
    sharing

# ActivityIndicator #
    _        _   _       _ _         ___           _ _           _             
   / \   ___| |_(_)_   _(_) |_ _   _|_ _|_ __   __| (_) ___ __ _| |_ ___  _ __ 
  / _ \ / __| __| \ \ / / | __| | | || || '_ \ / _` | |/ __/ _` | __/ _ \| '__|
 / ___ \ (__| |_| |\ V /| | |_| |_| || || | | | (_| | | (_| (_| | || (_) | |   
/_/   \_\___|\__|_| \_/ |_|\__|\__, |___|_| |_|\__,_|_|\___\__,_|\__\___/|_|   
                               |___/                                           
-   Example
-   Props
    -   View Props
    -    animating
    -    color
    -    hidesWhenStopped
        iOS
    -    size
ActivityIndicator

Displays a circular loading indicator.

Example 

Reference

Props 

View Props 

Inherits View Props .

------------------------------------------------------------------------

 animating 

Whether to show the indicator (  true ) or hide it (  false ).

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 color 

The foreground color of the spinner.

+-----------------------------------+-----------------------------------+
| Type                              | Default                           |
+===================================+===================================+
| color                             |  null (system accent default      |
|                                   | color)                            |
|                                   |                                   |
|                                   | Android                           |
|                                   |                                   |
|                                   | -------------------------------   |
|                                   |                                   |
|                                   |  '#999999'                        |
|                                   |                                   |
|                                   | iOS                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 hidesWhenStopped

iOS



Whether the indicator should hide when not animating.

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 size 

Size of the indicator.

+-----------------------------------+-----------------------------------+
| Type                              | Default                           |
+===================================+===================================+
| enum(  'small' ,  'large' )       |  'small'                          |
|                                   |                                   |
| -------------------------------   |                                   |
|                                   |                                   |
| number                            |                                   |
|                                   |                                   |
| Android                           |                                   |
+-----------------------------------+-----------------------------------+

# Alert #
    _    _           _   
   / \  | | ___ _ __| |_ 
  / _ \ | |/ _ \ '__| __|
 / ___ \| |  __/ |  | |_ 
/_/   \_\_|\___|_|   \__|
                         
-   Example
-   iOS
-   Android
    -   Example
        Android
-   Methods
    -    alert()
    -    prompt()
        iOS
-   Type Definitions
    -   AlertButtonStyle
        iOS
    -   AlertType
        iOS
    -   AlertButton
    -   AlertOptions
Alert

Launches an alert dialog with the specified title and message.

Optionally provide a list of buttons. Tapping any button will fire the
respective onPress callback and dismiss the alert. By default, the only
button will be an 'OK' button.

This is an API that works both on Android and iOS and can show static
alerts. Alert that prompts the user to enter some information is
available on iOS only.

Example 

iOS 

On iOS you can specify any number of buttons. Each button can optionally
specify a style or be emphasized, available options are represented by
the AlertButtonStyle enum and the  isPreferred field on AlertButton .

Android 

On Android at most three buttons can be specified. Android has a concept
of a neutral, negative and a positive button:

-   If you specify one button, it will be the 'positive' one (such as
    'OK')
-   Two buttons mean 'negative', 'positive' (such as 'Cancel', 'OK')
-   Three buttons mean 'neutral', 'negative', 'positive' (such as
    'Later', 'Cancel', 'OK')

Alerts on Android can be dismissed by tapping outside of the alert box.
It is disabled by default and can be enabled by providing an optional
AlertOptions parameter with the cancelable property set to  true i.e.
 {cancelable: true} .

The cancel event can be handled by providing an  onDismiss callback
property inside the  options parameter.

Example

Android



------------------------------------------------------------------------

Reference

Methods 

 alert() 

    static alert (
      title: string,
      message?: string,
      buttons?: AlertButton,
      options?: AlertOptions,
    );

 

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| title                 | string                | The dialog's title.   |
|                       |                       | Passing  null or      |
| Required              |                       | empty string will     |
|                       |                       | hide the title.       |
+-----------------------+-----------------------+-----------------------+
| message               | string                | An optional message   |
|                       |                       | that appears below    |
|                       |                       | the dialog's title.   |
+-----------------------+-----------------------+-----------------------+
| buttons               | AlertButton         | An optional array     |
|                       |                       | containing buttons    |
|                       |                       | configuration.        |
+-----------------------+-----------------------+-----------------------+
| options               | AlertOptions          | An optional Alert     |
|                       |                       | configuration.        |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 prompt()

iOS



    static prompt: (
      title: string,
      message?: string,
      callbackOrButtons?: ((text: string) => void) | AlertButton,
      type?: AlertType,
      defaultValue?: string,
      keyboardType?: string,
    );

 

Create and display a prompt to enter some text in form of Alert.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| title                 | string                | The dialog's title.   |
|                       |                       |                       |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+
| message               | string                | An optional message   |
|                       |                       | that appears above    |
|                       |                       | the text input.       |
+-----------------------+-----------------------+-----------------------+
| callbackOrButtons     | function              | If passed a function, |
|                       |                       | it will be called     |
|                       | -------------------   | with the prompt's     |
|                       |                       | value                 |
|                       | AlertButton         |  (                    |
|                       |                       | text: string) => void |
|                       |                       | , when the user taps  |
|                       |                       | 'OK'.                 |
|                       |                       |                       |
|                       |                       | -------------------   |
|                       |                       |                       |
|                       |                       | If passed an array,   |
|                       |                       | buttons will be       |
|                       |                       | configured based on   |
|                       |                       | the array content.    |
+-----------------------+-----------------------+-----------------------+
| type                  | AlertType             | This configures the   |
|                       |                       | text input.           |
+-----------------------+-----------------------+-----------------------+
| defaultValue          | string                | The default text in   |
|                       |                       | text input.           |
+-----------------------+-----------------------+-----------------------+
| keyboardType          | string                | The keyboard type of  |
|                       |                       | first text field (if  |
|                       |                       | exists). One of       |
|                       |                       | TextInput             |
|                       |                       | keyboardTypes .       |
+-----------------------+-----------------------+-----------------------+
| options               | AlertOptions          | An optional Alert     |
|                       |                       | configuration.        |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

Type Definitions 

AlertButtonStyle

iOS



An iOS Alert button style.

  Type
  ------
  enum

Constants:

  Value            Description
  ---------------- ---------------------------
   'default'       Default button style.
   'cancel'        Cancel button style.
   'destructive'   Destructive button style.

------------------------------------------------------------------------

AlertType

iOS



An iOS Alert type.

  Type
  ------
  enum

Constants:

  Value               Description
  ------------------- ------------------------------
   'default'          Default alert with no inputs
   'plain-text'       Plain text input alert
   'secure-text'      Secure text input alert
   'login-password'   Login and password alert

------------------------------------------------------------------------

AlertButton 

An object describing the configuration of a button in the alert.

  Type
  ------------------
  array of objects

Objects properties:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| text                  | string                | Button label.         |
+-----------------------+-----------------------+-----------------------+
| onPress               | function              | Callback function     |
|                       |                       | when button is        |
|                       |                       | pressed.              |
+-----------------------+-----------------------+-----------------------+
| style                 | AlertButtonStyle      | Button style, on      |
|                       |                       | Android this property |
| iOS                   |                       | will be ignored.      |
+-----------------------+-----------------------+-----------------------+
| isPreferred           | boolean               | Whether button should |
|                       |                       | be emphasized, on     |
| iOS                   |                       | Android this property |
|                       |                       | will be ignored.      |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

AlertOptions 

  Type
  --------
  object

Properties:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| cancelable            | boolean               | Defines if alert can  |
|                       |                       | be dismissed by       |
| Android               |                       | tapping outside of    |
|                       |                       | the alert box.        |
+-----------------------+-----------------------+-----------------------+
| userInterfaceStyle    | string                | The interface style   |
|                       |                       | used for the alert,   |
| iOS                   |                       | can be set to  light  |
|                       |                       | or  dark , otherwise  |
|                       |                       | the default system    |
|                       |                       | style will be used.   |
+-----------------------+-----------------------+-----------------------+
| onDismiss             | function              | Callback function     |
|                       |                       | fired when alert has  |
| Android               |                       | been dismissed.       |
+-----------------------+-----------------------+-----------------------+

# Android Native Modules #
    _              _           _     _   _   _       _   _           
   / \   _ __   __| |_ __ ___ (_) __| | | \ | | __ _| |_(_)_   _____ 
  / _ \ | '_ \ / _` | '__/ _ \| |/ _` | |  \| |/ _` | __| \ \ / / _ \
 / ___ \| | | | (_| | | | (_) | | (_| | | |\  | (_| | |_| |\ V /  __/
/_/   \_\_| |_|\__,_|_|  \___/|_|\__,_| |_| \_|\__,_|\__|_| \_/ \___|
                                                                     
 __  __           _       _           
|  \/  | ___   __| |_   _| | ___  ___ 
| |\/| |/ _ \ / _` | | | | |/ _ \/ __|
| |  | | (_) | (_| | |_| | |  __/\__ \
|_|  |_|\___/ \__,_|\__,_|_|\___||___/
                                      
-   Create a Calendar Native Module
    -   Setup
    -   Create A Custom Native Module File
    -   Module Name
    -   Export a Native Method to JavaScript
    -   Synchronous Methods
    -   Register the Module (Android Specific)
    -   Test What You Have Built
    -   Building as You Iterate
    -   Recap✨
-   Beyond a Calendar Native Module
    -   Better Native Module Export
    -   Argument Types
    -   Exporting Constants
    -   Callbacks
    -   Promises
    -   Sending Events to JavaScript
    -   Getting Activity Result from startActivityForResult
    -   Listening to Lifecycle Events
    -   Threading
Android Native Modules

 info

Native Module and Native Components are our stable technologies used by
the legacy architecture. They will be deprecated in the future when the
New Architecture will be stable. The New Architecture uses Turbo Native
Module and Fabric Native Components to achieve similar results.

Welcome to Native Modules for Android. Please start by reading the
Native Modules Intro for an intro to what native modules are.

Create a Calendar Native Module 

In the following guide you will create a native module,  CalendarModule
, that will allow you to access Android’s calendar APIs from JavaScript.
By the end, you will be able to call
 CalendarModule.createCalendarEvent('Dinner Party', 'My House'); from
JavaScript, invoking a Java/Kotlin method that creates a calendar event.

Setup 

To get started, open up the Android project within your React Native
application in Android Studio. You can find your Android project here
within a React Native app:

[Image of where you can find your Android project]

We recommend using Android Studio to write your native code. Android
studio is an IDE built for Android development and using it will help
you resolve minor issues like code syntax errors quickly.

We also recommend enabling Gradle Daemon to speed up builds as you
iterate on Java/Kotlin code.

Create A Custom Native Module File 

The first step is to create the (  CalendarModule.java or
 CalendarModule.kt ) Java/Kotlin file inside
 android/app/src/main/java/com/your-app-name/ folder (the folder is the
same for both Kotlin and Java). This Java/Kotlin file will contain your
native module Java/Kotlin class.

[Image of how to add the CalendarModuleClass]

Then add the following content:

-   Java
-   Kotlin

    package com.your-apps-package-name; // replace your-apps-package-name with your app’s package name
    import com.facebook.react.bridge.NativeModule;
    import com.facebook.react.bridge.ReactApplicationContext;
    import com.facebook.react.bridge.ReactContext;
    import com.facebook.react.bridge.ReactContextBaseJavaModule;
    import com.facebook.react.bridge.ReactMethod;
    import java.util.Map;
    import java.util.HashMap;

    public class CalendarModule extends ReactContextBaseJavaModule {
       CalendarModule(ReactApplicationContext context) {
           super(context);
       }
    }

 

    package com.your-apps-package-name; // replace your-apps-package-name with your app’s package name
    import com.facebook.react.bridge.NativeModule
    import com.facebook.react.bridge.ReactApplicationContext
    import com.facebook.react.bridge.ReactContext
    import com.facebook.react.bridge.ReactContextBaseJavaModule
    import com.facebook.react.bridge.ReactMethod

    class CalendarModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {...}

 

As you can see, your  CalendarModule class extends the
 ReactContextBaseJavaModule class. For Android, Java/Kotlin native
modules are written as classes that extend  ReactContextBaseJavaModule
and implement the functionality required by JavaScript.

  It is worth noting that technically Java/Kotlin classes only need to
  extend the  BaseJavaModule class or implement the  NativeModule
  interface to be considered a Native Module by React Native.

  However we recommend that you use  ReactContextBaseJavaModule , as
  shown above.  ReactContextBaseJavaModule gives access to the
   ReactApplicationContext (RAC), which is useful for Native Modules
  that need to hook into activity lifecycle methods. Using
   ReactContextBaseJavaModule will also make it easier to make your
  native module type-safe in the future. For native module type-safety,
  which is coming in future releases, React Native looks at each native
  module's JavaScript spec and generates an abstract base class that
  extends  ReactContextBaseJavaModule .

Module Name 

All Java/Kotlin native modules in Android need to implement the
 getName() method. This method returns a string, which represents the
name of the native module. The native module can then be accessed in
JavaScript using its name. For example, in the below code snippet,
 getName() returns  "CalendarModule" .

-   Java
-   Kotlin

    // add to CalendarModule.java
    @Override
    public String getName() {
       return "CalendarModule";
    }

 

    // add to CalendarModule.kt
    override fun getName() = "CalendarModule"

 

The native module can then be accessed in JS like this:

    const {CalendarModule} = ReactNative.NativeModules;

 

Export a Native Method to JavaScript 

Next you will need to add a method to your native module that will
create calendar events and can be invoked in JavaScript. All native
module methods meant to be invoked from JavaScript must be annotated
with  @ReactMethod .

Set up a method  createCalendarEvent() for  CalendarModule that can be
invoked in JS through  CalendarModule.createCalendarEvent() . For now,
the method will take in a name and location as strings. Argument type
options will be covered shortly.

-   Java
-   Kotlin

    @ReactMethod
    public void createCalendarEvent(String name, String location) {
    }

 

    @ReactMethod fun createCalendarEvent(name: String, location: String) {}

 

Add a debug log in the method to confirm it has been invoked when you
call it from your application. Below is an example of how you can import
and use the Log class from the Android util package:

-   Java
-   Kotlin

    import android.util.Log;

    @ReactMethod
    public void createCalendarEvent(String name, String location) {
       Log.d("CalendarModule", "Create event called with name: " + name
       + " and location: " + location);
    }

 

    import android.util.Log

    @ReactMethod
    fun createCalendarEvent(name: String, location: String) {
        Log.d("CalendarModule", "Create event called with name: $name and location: $location")
    }

 

Once you finish implementing the native module and hook it up in
JavaScript, you can follow these steps to view the logs from your app.

Synchronous Methods 

You can pass  isBlockingSynchronousMethod = true to a native method to
mark it as a synchronous method.

-   Java
-   Kotlin

    @ReactMethod(isBlockingSynchronousMethod = true)

 

    @ReactMethod(isBlockingSynchronousMethod = true)

 

At the moment, we do not recommend this, since calling methods
synchronously can have strong performance penalties and introduce
threading-related bugs to your native modules. Additionally, please note
that if you choose to enable  isBlockingSynchronousMethod , your app can
no longer use the Google Chrome debugger. This is because synchronous
methods require the JS VM to share memory with the app. For the Google
Chrome debugger, React Native runs inside the JS VM in Google Chrome,
and communicates asynchronously with the mobile devices via WebSockets.

Register the Module (Android Specific) 

Once a native module is written, it needs to be registered with React
Native. In order to do so, you need to add your native module to a
 ReactPackage and register the  ReactPackage with React Native. During
initialization, React Native will loop over all packages, and for each
 ReactPackage , register each native module within.

React Native invokes the method  createNativeModules() on a
 ReactPackage in order to get the list of native modules to register.
For Android, if a module is not instantiated and returned in
createNativeModules it will not be available from JavaScript.

To add your Native Module to  ReactPackage , first create a new
Java/Kotlin Class named (  MyAppPackage.java or  MyAppPackage.kt ) that
implements  ReactPackage inside the
 android/app/src/main/java/com/your-app-name/ folder:

Then add the following content:

-   Java
-   Kotlin

    package com.your-app-name; // replace your-app-name with your app’s name
    import com.facebook.react.ReactPackage;
    import com.facebook.react.bridge.NativeModule;
    import com.facebook.react.bridge.ReactApplicationContext;
    import com.facebook.react.uimanager.ViewManager;

    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.List;

    public class MyAppPackage implements ReactPackage {

       @Override
       public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
           return Collections.emptyList();
       }

       @Override
       public List<NativeModule> createNativeModules(
               ReactApplicationContext reactContext) {
           List<NativeModule> modules = new ArrayList<>();

           modules.add(new CalendarModule(reactContext));

           return modules;
       }

    }

 

    package com.your-app-name // replace your-app-name with your app’s name

    import android.view.View
    import com.facebook.react.ReactPackage
    import com.facebook.react.bridge.NativeModule
    import com.facebook.react.bridge.ReactApplicationContext
    import com.facebook.react.uimanager.ReactShadowNode
    import com.facebook.react.uimanager.ViewManager

    class MyAppPackage : ReactPackage {

        override fun createViewManagers(
            reactContext: ReactApplicationContext
        ): MutableList<ViewManager<View, ReactShadowNode<*>>> = mutableListOf()

        override fun createNativeModules(
            reactContext: ReactApplicationContext
        ): MutableList<NativeModule> = listOf(CalendarModule(reactContext)).toMutableList()
    }

 

This file imports the native module you created,  CalendarModule . It
then instantiates  CalendarModule within the  createNativeModules()
function and returns it as a list of  NativeModules to register. If you
add more native modules down the line, you can also instantiate them and
add them to the list returned here.

  It is worth noting that this way of registering native modules eagerly
  initializes all native modules when the application starts, which adds
  to the startup time of an application. You can use TurboReactPackage
  as an alternative. Instead of  createNativeModules , which return a
  list of instantiated native module objects, TurboReactPackage
  implements a  getModule(String name, ReactApplicationContext rac)
  method that creates the native module object, when required.
  TurboReactPackage is a bit more complicated to implement at the
  moment. In addition to implementing a  getModule() method, you have to
  implement a  getReactModuleInfoProvider() method, which returns a list
  of all the native modules the package can instantiate along with a
  function that instantiates them, example here . Again, using
  TurboReactPackage will allow your application to have a faster startup
  time, but it is currently a bit cumbersome to write. So proceed with
  caution if you choose to use TurboReactPackages.

To register the  CalendarModule package, you must add  MyAppPackage to
the list of packages returned in ReactNativeHost's  getPackages()
method. Open up your  MainApplication.java or  MainApplication.kt file,
which can be found in the following path:
 android/app/src/main/java/com/your-app-name/ .

Locate ReactNativeHost’s  getPackages() method and add your package to
the packages list  getPackages() returns:

-   Java
-   Kotlin

    @Override
      protected List<ReactPackage> getPackages() {
        @SuppressWarnings("UnnecessaryLocalVariable")
        List<ReactPackage> packages = new PackageList(this).getPackages();
        // below MyAppPackage is added to the list of packages returned
        packages.add(new MyAppPackage());
        return packages;
      }

 

    override fun getPackages(): List<ReactPackage> =
        PackageList(this).packages.apply {
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // packages.add(new MyReactNativePackage());
            add(MyAppPackage())
        }

 

You have now successfully registered your native module for Android!

Test What You Have Built 

At this point, you have set up the basic scaffolding for your native
module in Android. Test that out by accessing the native module and
invoking its exported method in JavaScript.

Find a place in your application where you would like to add a call to
the native module’s  createCalendarEvent() method. Below is an example
of a component,  NewModuleButton you can add in your app. You can invoke
the native module inside  NewModuleButton 's  onPress() function.

    import React from 'react';
    import {NativeModules, Button} from 'react-native';

    const NewModuleButton = () => {
      const onPress = () => {
        console.log('We will invoke the native module here!');
      };

      return (
        <Button
          title="Click to invoke your native module!"
          color="#841584"
          onPress={onPress}
        />
      );
    };

    export default NewModuleButton;

 

In order to access your native module from JavaScript you need to first
import  NativeModules from React Native:

    import {NativeModules} from 'react-native';

 

You can then access the  CalendarModule native module off of
 NativeModules .

    const {CalendarModule} = NativeModules;

 

Now that you have the CalendarModule native module available, you can
invoke your native method  createCalendarEvent() . Below it is added to
the  onPress() method in  NewModuleButton :

    const onPress = () => {
      CalendarModule.createCalendarEvent('testName', 'testLocation');
    };

 

The final step is to rebuild the React Native app so that you can have
the latest native code (with your new native module!) available. In your
command line, where the react native application is located, run the
following:

-   npm
-   Yarn

    npm run android

 

    yarn android

 

Building as You Iterate 

As you work through these guides and iterate on your native module, you
will need to do a native rebuild of your application to access your most
recent changes from JavaScript. This is because the code that you are
writing sits within the native part of your application. While React
Native’s metro bundler can watch for changes in JavaScript and rebuild
on the fly for you, it will not do so for native code. So if you want to
test your latest native changes you need to rebuild by using the above
command.

Recap✨ 

You should now be able to invoke your  createCalendarEvent() method on
your native module in the app. In our example this occurs by pressing
the  NewModuleButton . You can confirm this by viewing the log you set
up in your  createCalendarEvent() method. You can follow these steps to
view ADB logs in your app. You should then be able to search for your
 Log.d message (in our example “Create event called with name: testName
and location: testLocation”) and see your message logged each time you
invoke your native module method.

[Image of ADB logs in Android Studio]

At this point you have created an Android native module and invoked its
native method from JavaScript in your React Native application. You can
read on to learn more about things like argument types available to a
native module method and how to setup callbacks and promises.

Beyond a Calendar Native Module 

Better Native Module Export 

Importing your native module by pulling it off of  NativeModules like
above is a bit clunky.

To save consumers of your native module from needing to do that each
time they want to access your native module, you can create a JavaScript
wrapper for the module. Create a new JavaScript file named
 CalendarModule.js with the following content:

    /**
    * This exposes the native CalendarModule module as a JS module. This has a
    * function 'createCalendarEvent' which takes the following parameters:

    * 1. String name: A string representing the name of the event
    * 2. String location: A string representing the location of the event
    */
    import {NativeModules} from 'react-native';
    const {CalendarModule} = NativeModules;
    export default CalendarModule;

 

This JavaScript file also becomes a good location for you to add any
JavaScript side functionality. For example, if you use a type system
like TypeScript you can add type annotations for your native module
here. While React Native does not yet support Native to JS type safety,
all your JS code will be type safe. Doing so will also make it easier
for you to switch to type-safe native modules down the line. Below is an
example of adding type safety to the CalendarModule:

    /**
     * This exposes the native CalendarModule module as a JS module. This has a
     * function 'createCalendarEvent' which takes the following parameters:
     *
     * 1. String name: A string representing the name of the event
     * 2. String location: A string representing the location of the event
     */
    import {NativeModules} from 'react-native';
    const {CalendarModule} = NativeModules;
    interface CalendarInterface {
      createCalendarEvent(name: string, location: string): void;
    }
    export default CalendarModule as CalendarInterface;

 

In your other JavaScript files you can access the native module and
invoke its method like this:

    import CalendarModule from './CalendarModule';
    CalendarModule.createCalendarEvent('foo', 'bar');

 

  This assumes that the place you are importing  CalendarModule is in
  the same hierarchy as  CalendarModule.js . Please update the relative
  import as necessary.

Argument Types 

When a native module method is invoked in JavaScript, React Native
converts the arguments from JS objects to their Java/Kotlin object
analogues. So for example, if your Java Native Module method accepts a
double, in JS you need to call the method with a number. React Native
will handle the conversion for you. Below is a list of the argument
types supported for native module methods and the JavaScript equivalents
they map to.

  Java            Kotlin          JavaScript
  --------------- --------------- ------------
  Boolean         Boolean         ?boolean
  boolean                         boolean
  Double          Double          ?number
  double                          number
  String          String          string
  Callback        Callback        Function
  Promise         Promise         Promise
  ReadableMap     ReadableMap     Object
  ReadableArray   ReadableArray   Array

  The following types are currently supported but will not be supported
  in TurboModules. Please avoid using them:

  -   Integer Java/Kotlin -> ?number
  -   Float Java/Kotlin -> ?number
  -   int Java -> number
  -   float Java -> number

For argument types not listed above, you will need to handle the
conversion yourself. For example, in Android,  Date conversion is not
supported out of the box. You can handle the conversion to the  Date
type within the native method yourself like so:

-   Java
-   Kotlin

        String dateFormat = "yyyy-MM-dd";
        SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
        Calendar eStartDate = Calendar.getInstance();
        try {
            eStartDate.setTime(sdf.parse(startDate));
        }

 

        val dateFormat = "yyyy-MM-dd"
        val sdf = SimpleDateFormat(dateFormat, Locale.US)
        val eStartDate = Calendar.getInstance()
        try {
            sdf.parse(startDate)?.let {
                eStartDate.time = it
            }
        }

 

Exporting Constants 

A native module can export constants by implementing the native method
 getConstants() , which is available in JS. Below you will implement
 getConstants() and return a Map that contains a  DEFAULT_EVENT_NAME
constant you can access in JavaScript:

-   Java
-   Kotlin

    @Override
    public Map<String, Object> getConstants() {
       final Map<String, Object> constants = new HashMap<>();
       constants.put("DEFAULT_EVENT_NAME", "New Event");
       return constants;
    }

 

    override fun getConstants(): MutableMap<String, Any> =
        hashMapOf("DEFAULT_EVENT_NAME" to "New Event")

 

The constant can then be accessed by invoking  getConstants on the
native module in JS:

    const {DEFAULT_EVENT_NAME} = CalendarModule.getConstants();
    console.log(DEFAULT_EVENT_NAME);

 

Technically it is possible to access constants exported in
 getConstants() directly off the native module object. This will no
longer be supported with TurboModules, so we encourage the community to
switch to the above approach to avoid necessary migration down the line.

  That currently constants are exported only at initialization time, so
  if you change getConstants values at runtime it won't affect the
  JavaScript environment. This will change with Turbomodules. With
  Turbomodules,  getConstants() will become a regular native module
  method, and each invocation will hit the native side.

Callbacks 

Native modules also support a unique kind of argument: a callback.
Callbacks are used to pass data from Java/Kotlin to JavaScript for
asynchronous methods. They can also be used to asynchronously execute
JavaScript from the native side.

In order to create a native module method with a callback, first import
the  Callback interface, and then add a new parameter to your native
module method of type  Callback . There are a couple of nuances with
callback arguments that will soon be lifted with TurboModules. First
off, you can only have two callbacks in your function arguments- a
successCallback and a failureCallback. In addition, the last argument to
a native module method call, if it's a function, is treated as the
successCallback, and the second to last argument to a native module
method call, if it's a function, is treated as the failure callback.

-   Java
-   Kotlin

    import com.facebook.react.bridge.Callback;

    @ReactMethod
    public void createCalendarEvent(String name, String location, Callback callBack) {
    }

 

    import com.facebook.react.bridge.Callback

    @ReactMethod fun createCalendarEvent(name: String, location: String, callback: Callback) {}

 

You can invoke the callback in your Java/Kotlin method, providing
whatever data you want to pass to JavaScript. Please note that you can
only pass serializable data from native code to JavaScript. If you need
to pass back a native object you can use  WriteableMaps , if you need to
use a collection use  WritableArrays . It is also important to highlight
that the callback is not invoked immediately after the native function
completes. Below the ID of an event created in an earlier call is passed
to the callback.

-   Java
-   Kotlin

      @ReactMethod
       public void createCalendarEvent(String name, String location, Callback callBack) {
           Integer eventId = ...
           callBack.invoke(eventId);
       }

 

      @ReactMethod
      fun createCalendarEvent(name: String, location: String, callback: Callback) {
          val eventId = ...
          callback.invoke(eventId)
      }

 

This method could then be accessed in JavaScript using:

    const onPress = () => {
      CalendarModule.createCalendarEvent(
        'Party',
        'My House',
        eventId => {
          console.log(`Created a new event with id ${eventId}`);
        },
      );
    };

 

Another important detail to note is that a native module method can only
invoke one callback, one time. This means that you can either call a
success callback or a failure callback, but not both, and each callback
can only be invoked at most one time. A native module can, however,
store the callback and invoke it later.

There are two approaches to error handling with callbacks. The first is
to follow Node’s convention and treat the first argument passed to the
callback as an error object.

-   Java
-   Kotlin

      @ReactMethod
       public void createCalendarEvent(String name, String location, Callback callBack) {
           Integer eventId = ...
           callBack.invoke(null, eventId);
       }

 

      @ReactMethod
      fun createCalendarEvent(name: String, location: String, callback: Callback) {
          val eventId = ...
          callback.invoke(null, eventId)
      }

 

In JavaScript, you can then check the first argument to see if an error
was passed through:

    const onPress = () => {
      CalendarModule.createCalendarEvent(
        'testName',
        'testLocation',
        (error, eventId) => {
          if (error) {
            console.error(`Error found! ${error}`);
          }
          console.log(`event id ${eventId} returned`);
        },
      );
    };

 

Another option is to use an onSuccess and onFailure callback:

-   Java
-   Kotlin

    @ReactMethod
    public void createCalendarEvent(String name, String location, Callback myFailureCallback, Callback mySuccessCallback) {
    }

 

    @ReactMethod
      fun createCalendarEvent(
          name: String,
          location: String,
          myFailureCallback: Callback,
          mySuccessCallback: Callback
      ) {}

 

Then in JavaScript you can add a separate callback for error and success
responses:

    const onPress = () => {
      CalendarModule.createCalendarEvent(
        'testName',
        'testLocation',
        error => {
          console.error(`Error found! ${error}`);
        },
        eventId => {
          console.log(`event id ${eventId} returned`);
        },
      );
    };

 

Promises 

Native modules can also fulfill a Promise , which can simplify your
JavaScript, especially when using ES2016's async/await syntax. When the
last parameter of a native module Java/Kotlin method is a Promise, its
corresponding JS method will return a JS Promise object.

Refactoring the above code to use a promise instead of callbacks looks
like this:

-   Java
-   Kotlin

    import com.facebook.react.bridge.Promise;

    @ReactMethod
    public void createCalendarEvent(String name, String location, Promise promise) {
        try {
            Integer eventId = ...
            promise.resolve(eventId);
        } catch(Exception e) {
            promise.reject("Create Event Error", e);
        }
    }

 

    import com.facebook.react.bridge.Promise

    @ReactMethod
    fun createCalendarEvent(name: String, location: String, promise: Promise) {
        try {
            val eventId = ...
            promise.resolve(eventId)
        } catch (e: Throwable) {
            promise.reject("Create Event Error", e)
        }
    }

 

  Similar to callbacks, a native module method can either reject or
  resolve a promise (but not both) and can do so at most once. This
  means that you can either call a success callback or a failure
  callback, but not both, and each callback can only be invoked at most
  one time. A native module can, however, store the callback and invoke
  it later.

The JavaScript counterpart of this method returns a Promise. This means
you can use the  await keyword within an async function to call it and
wait for its result:

    const onSubmit = async () => {
      try {
        const eventId = await CalendarModule.createCalendarEvent(
          'Party',
          'My House',
        );
        console.log(`Created a new event with id ${eventId}`);
      } catch (e) {
        console.error(e);
      }
    };

 

The reject method takes different combinations of the following
arguments:

-   Java
-   Kotlin

    String code, String message, WritableMap userInfo, Throwable throwable

 

    code: String, message: String, userInfo: WritableMap, throwable: Throwable

 

For more detail, you can find the  Promise.java interface here . If
 userInfo is not provided, ReactNative will set it to null. For the rest
of the parameters React Native will use a default value. The  message
argument provides the error  message shown at the top of an error call
stack. Below is an example of the error message shown in JavaScript from
the following reject call in Java/Kotlin.

Java/Kotlin reject call:

-   Java
-   Kotlin

    promise.reject("Create Event error", "Error parsing date", e);

 

    promise.reject("Create Event error", "Error parsing date", e)

 

Error message in React Native App when promise is rejected:

[Image of error message]

Sending Events to JavaScript 

Native modules can signal events to JavaScript without being invoked
directly. For example, you might want to signal to JavaScript a reminder
that a calendar event from the native Android calendar app will occur
soon. The easiest way to do this is to use the  RCTDeviceEventEmitter
which can be obtained from the  ReactContext as in the code snippet
below.

-   Java
-   Kotlin

    ...
    import com.facebook.react.modules.core.DeviceEventManagerModule;
    import com.facebook.react.bridge.WritableMap;
    import com.facebook.react.bridge.Arguments;
    ...
    private void sendEvent(ReactContext reactContext,
                          String eventName,
                          @Nullable WritableMap params) {
     reactContext
         .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
         .emit(eventName, params);
    }

    private int listenerCount = 0;

    @ReactMethod
    public void addListener(String eventName) {
      if (listenerCount == 0) {
        // Set up any upstream listeners or background tasks as necessary
      }

      listenerCount += 1;
    }

    @ReactMethod
    public void removeListeners(Integer count) {
      listenerCount -= count;
      if (listenerCount == 0) {
        // Remove upstream listeners, stop unnecessary background tasks
      }
    }
    ...
    WritableMap params = Arguments.createMap();
    params.putString("eventProperty", "someValue");
    ...
    sendEvent(reactContext, "EventReminder", params);

 

    ...
    import com.facebook.react.bridge.WritableMap
    import com.facebook.react.bridge.Arguments
    import com.facebook.react.modules.core.DeviceEventManagerModule
    ...

    private fun sendEvent(reactContext: ReactContext, eventName: String, params: WritableMap?) {
        reactContext
          .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
          .emit(eventName, params)
    }

    private var listenerCount = 0

    @ReactMethod
    fun addListener(eventName: String) {
      if (listenerCount == 0) {
        // Set up any upstream listeners or background tasks as necessary
      }

      listenerCount += 1
    }

    @ReactMethod
    fun removeListeners(count: Int) {
      listenerCount -= count
      if (listenerCount == 0) {
        // Remove upstream listeners, stop unnecessary background tasks
      }
    }
    ...
    val params = Arguments.createMap().apply {
        putString("eventProperty", "someValue")
    }
    ...
    sendEvent(reactContext, "EventReminder", params)

 

JavaScript modules can then register to receive events by  addListener
on the NativeEventEmitter class.

    import {NativeEventEmitter, NativeModules} from 'react-native';
    ...
    useEffect(() => {
        const eventEmitter = new NativeEventEmitter(NativeModules.ToastExample);
        let eventListener = eventEmitter.addListener('EventReminder', event => {
          console.log(event.eventProperty) // "someValue"
        });

        // Removes the listener once unmounted
        return () => {
          eventListener.remove();
        };
      }, );

 

Getting Activity Result from startActivityForResult 

You'll need to listen to  onActivityResult if you want to get results
from an activity you started with  startActivityForResult . To do this,
you must extend  BaseActivityEventListener or implement
 ActivityEventListener . The former is preferred as it is more resilient
to API changes. Then, you need to register the listener in the module's
constructor like so:

-   Java
-   Kotlin

    reactContext.addActivityEventListener(mActivityResultListener);

 

    reactContext.addActivityEventListener(mActivityResultListener);

 

Now you can listen to  onActivityResult by implementing the following
method:

-   Java
-   Kotlin

    @Override
    public void onActivityResult(
     final Activity activity,
     final int requestCode,
     final int resultCode,
     final Intent intent) {
     // Your logic here
    }

 

    override fun onActivityResult(
        activity: Activity?,
        requestCode: Int,
        resultCode: Int,
        intent: Intent?
    ) {
        // Your logic here
    }

 

Let's implement a basic image picker to demonstrate this. The image
picker will expose the method  pickImage to JavaScript, which will
return the path of the image when called.

-   Java
-   Kotlin

    public class ImagePickerModule extends ReactContextBaseJavaModule {

      private static final int IMAGE_PICKER_REQUEST = 1;
      private static final String E_ACTIVITY_DOES_NOT_EXIST = "E_ACTIVITY_DOES_NOT_EXIST";
      private static final String E_PICKER_CANCELLED = "E_PICKER_CANCELLED";
      private static final String E_FAILED_TO_SHOW_PICKER = "E_FAILED_TO_SHOW_PICKER";
      private static final String E_NO_IMAGE_DATA_FOUND = "E_NO_IMAGE_DATA_FOUND";

      private Promise mPickerPromise;

      private final ActivityEventListener mActivityEventListener = new BaseActivityEventListener() {

        @Override
        public void onActivityResult(Activity activity, int requestCode, int resultCode, Intent intent) {
          if (requestCode == IMAGE_PICKER_REQUEST) {
            if (mPickerPromise != null) {
              if (resultCode == Activity.RESULT_CANCELED) {
                mPickerPromise.reject(E_PICKER_CANCELLED, "Image picker was cancelled");
              } else if (resultCode == Activity.RESULT_OK) {
                Uri uri = intent.getData();

                if (uri == null) {
                  mPickerPromise.reject(E_NO_IMAGE_DATA_FOUND, "No image data found");
                } else {
                  mPickerPromise.resolve(uri.toString());
                }
              }

              mPickerPromise = null;
            }
          }
        }
      };

      ImagePickerModule(ReactApplicationContext reactContext) {
        super(reactContext);

        // Add the listener for `onActivityResult`
        reactContext.addActivityEventListener(mActivityEventListener);
      }

      @Override
      public String getName() {
        return "ImagePickerModule";
      }

      @ReactMethod
      public void pickImage(final Promise promise) {
        Activity currentActivity = getCurrentActivity();

        if (currentActivity == null) {
          promise.reject(E_ACTIVITY_DOES_NOT_EXIST, "Activity doesn't exist");
          return;
        }

        // Store the promise to resolve/reject when picker returns data
        mPickerPromise = promise;

        try {
          final Intent galleryIntent = new Intent(Intent.ACTION_PICK);

          galleryIntent.setType("image/*");

          final Intent chooserIntent = Intent.createChooser(galleryIntent, "Pick an image");

          currentActivity.startActivityForResult(chooserIntent, IMAGE_PICKER_REQUEST);
        } catch (Exception e) {
          mPickerPromise.reject(E_FAILED_TO_SHOW_PICKER, e);
          mPickerPromise = null;
        }
      }
    }

 

    class ImagePickerModule(reactContext: ReactApplicationContext) :
        ReactContextBaseJavaModule(reactContext) {

        private var pickerPromise: Promise? = null

        private val activityEventListener =
            object : BaseActivityEventListener() {
                override fun onActivityResult(
                    activity: Activity?,
                    requestCode: Int,
                    resultCode: Int,
                    intent: Intent?
                ) {
                    if (requestCode == IMAGE_PICKER_REQUEST) {
                        pickerPromise?.let { promise ->
                            when (resultCode) {
                                Activity.RESULT_CANCELED ->
                                    promise.reject(E_PICKER_CANCELLED, "Image picker was cancelled")
                                Activity.RESULT_OK -> {
                                    val uri = intent?.data

                                    uri?.let { promise.resolve(uri.toString())}
                                        ?: promise.reject(E_NO_IMAGE_DATA_FOUND, "No image data found")
                                }
                            }

                            pickerPromise = null
                        }
                    }
                }
            }

        init {
            reactContext.addActivityEventListener(activityEventListener)
        }

        override fun getName() = "ImagePickerModule"

        @ReactMethod
        fun pickImage(promise: Promise) {
            val activity = currentActivity

            if (activity == null) {
                promise.reject(E_ACTIVITY_DOES_NOT_EXIST, "Activity doesn't exist")
                return
            }

            pickerPromise = promise

            try {
                val galleryIntent = Intent(Intent.ACTION_PICK).apply { type = "image\/*" }

                val chooserIntent = Intent.createChooser(galleryIntent, "Pick an image")

                activity.startActivityForResult(chooserIntent, IMAGE_PICKER_REQUEST)
            } catch (t: Throwable) {
                pickerPromise?.reject(E_FAILED_TO_SHOW_PICKER, t)
                pickerPromise = null
            }
        }

        companion object {
            const val IMAGE_PICKER_REQUEST = 1
            const val E_ACTIVITY_DOES_NOT_EXIST = "E_ACTIVITY_DOES_NOT_EXIST"
            const val E_PICKER_CANCELLED = "E_PICKER_CANCELLED"
            const val E_FAILED_TO_SHOW_PICKER = "E_FAILED_TO_SHOW_PICKER"
            const val E_NO_IMAGE_DATA_FOUND = "E_NO_IMAGE_DATA_FOUND"
        }
    }

 

Listening to Lifecycle Events 

Listening to the activity's LifeCycle events such as  onResume ,
 onPause etc. is very similar to how  ActivityEventListener was
implemented. The module must implement  LifecycleEventListener . Then,
you need to register a listener in the module's constructor like so:

-   Java
-   Kotlin

    reactContext.addLifecycleEventListener(this);

 

    reactContext.addLifecycleEventListener(this)

 

Now you can listen to the activity's LifeCycle events by implementing
the following methods:

-   Java
-   Kotlin

    @Override
    public void onHostResume() {
       // Activity `onResume`
    }
    @Override
    public void onHostPause() {
       // Activity `onPause`
    }
    @Override
    public void onHostDestroy() {
       // Activity `onDestroy`
    }

 

    override fun onHostResume() {
        // Activity `onResume`
    }

    override fun onHostPause() {
        // Activity `onPause`
    }

    override fun onHostDestroy() {
        // Activity `onDestroy`
    }

 

Threading 

To date, on Android, all native module async methods execute on one
thread. Native modules should not have any assumptions about what thread
they are being called on, as the current assignment is subject to change
in the future. If a blocking call is required, the heavy work should be
dispatched to an internally managed worker thread, and any callbacks
distributed from there.

# Android Native UI Components #
    _              _           _     _   _   _       _   _           
   / \   _ __   __| |_ __ ___ (_) __| | | \ | | __ _| |_(_)_   _____ 
  / _ \ | '_ \ / _` | '__/ _ \| |/ _` | |  \| |/ _` | __| \ \ / / _ \
 / ___ \| | | | (_| | | | (_) | | (_| | | |\  | (_| | |_| |\ V /  __/
/_/   \_\_| |_|\__,_|_|  \___/|_|\__,_| |_| \_|\__,_|\__|_| \_/ \___|
                                                                     
 _   _ ___    ____                                             _       
| | | |_ _|  / ___|___  _ __ ___  _ __   ___  _ __   ___ _ __ | |_ ___ 
| | | || |  | |   / _ \| '_ ` _ \| '_ \ / _ \| '_ \ / _ \ '_ \| __/ __|
| |_| || |  | |__| (_) | | | | | | |_) | (_) | | | |  __/ | | | |_\__ \
 \___/|___|  \____\___/|_| |_| |_| .__/ \___/|_| |_|\___|_| |_|\__|___/
                                 |_|                                   
-   ImageView example
    -   1. Create the  ViewManager subclass
    -   2. Implement method  createViewInstance
    -   3. Expose view property setters using  @ReactProp (or
         @ReactPropGroup ) annotation
    -   4. Register the  ViewManager
    -   5. Implement the JavaScript module
-   Events
-   Integration with an Android Fragment example
    -   1. Create an example custom view
    -   2. Create a  Fragment
    -   3. Create the  ViewManager subclass
    -   4. Register the  ViewManager
    -   5. Register the  Package
    -   6. Implement the JavaScript module
Android Native UI Components

 info

Native Module and Native Components are our stable technologies used by
the legacy architecture. They will be deprecated in the future when the
New Architecture will be stable. The New Architecture uses Turbo Native
Module and Fabric Native Components to achieve similar results.

There are tons of native UI widgets out there ready to be used in the
latest apps - some of them are part of the platform, others are
available as third-party libraries, and still more might be in use in
your very own portfolio. React Native has several of the most critical
platform components already wrapped, like  ScrollView and  TextInput ,
but not all of them, and certainly not ones you might have written
yourself for a previous app. Fortunately, we can wrap up these existing
components for seamless integration with your React Native application.

Like the native module guide, this too is a more advanced guide that
assumes you are somewhat familiar with Android SDK programming. This
guide will show you how to build a native UI component, walking you
through the implementation of a subset of the existing  ImageView
component available in the core React Native library.

ImageView example 

For this example we are going to walk through the implementation
requirements to allow the use of ImageViews in JavaScript.

Native views are created and manipulated by extending  ViewManager or
more commonly  SimpleViewManager . A  SimpleViewManager is convenient in
this case because it applies common properties such as background color,
opacity, and Flexbox layout.

These subclasses are essentially singletons - only one instance of each
is created by the bridge. They send native views to the
 NativeViewHierarchyManager , which delegates back to them to set and
update the properties of the views as necessary. The  ViewManagers are
also typically the delegates for the views, sending events back to
JavaScript via the bridge.

To send a view:

1.  Create the ViewManager subclass.
2.  Implement the  createViewInstance method
3.  Expose view property setters using  @ReactProp (or  @ReactPropGroup
    ) annotation
4.  Register the manager in  createViewManagers of the applications
    package.
5.  Implement the JavaScript module

1. Create the  ViewManager subclass 

In this example we create view manager class  ReactImageManager that
extends  SimpleViewManager of type  ReactImageView .  ReactImageView is
the type of object managed by the manager, this will be the custom
native view. Name returned by  getName is used to reference the native
view type from JavaScript.

-   Java
-   Kotlin

    class ReactImageManager(
        private val callerContext: ReactApplicationContext
    ) : SimpleViewManager<ReactImageView>() {

      override fun getName() = REACT_CLASS

      companion object {
        const val REACT_CLASS = "RCTImageView"
      }
    }

 

    public class ReactImageManager extends SimpleViewManager<ReactImageView> {

      public static final String REACT_CLASS = "RCTImageView";
      ReactApplicationContext mCallerContext;

      public ReactImageManager(ReactApplicationContext reactContext) {
        mCallerContext = reactContext;
      }

      @Override
      public String getName() {
        return REACT_CLASS;
      }
    }

 

2. Implement method  createViewInstance 

Views are created in the  createViewInstance method, the view should
initialize itself in its default state, any properties will be set via a
follow up call to  updateView.

-   Java
-   Kotlin

      override fun createViewInstance(context: ThemedReactContext) =
          ReactImageView(context, Fresco.newDraweeControllerBuilder(), null, callerContext)

 

      @Override
      public ReactImageView createViewInstance(ThemedReactContext context) {
        return new ReactImageView(context, Fresco.newDraweeControllerBuilder(), null, mCallerContext);
      }

 

3. Expose view property setters using  @ReactProp (or  @ReactPropGroup ) annotation 

Properties that are to be reflected in JavaScript needs to be exposed as
setter method annotated with  @ReactProp (or  @ReactPropGroup ). Setter
method should take view to be updated (of the current view type) as a
first argument and property value as a second argument. Setter should be
public and not return a value (i.e. return type should be  void in Java
or  Unit in Kotlin). Property type sent to JS is determined
automatically based on the type of value argument of the setter. The
following type of values are currently supported (in Java):  boolean ,
 int ,  float ,  double ,  String ,  Boolean ,  Integer ,  ReadableArray
,  ReadableMap . The corresponding types in Kotlin are  Boolean ,  Int ,
 Float ,  Double ,  String ,  ReadableArray ,  ReadableMap .

Annotation  @ReactProp has one obligatory argument  name of type  String
. Name assigned to the  @ReactProp annotation linked to the setter
method is used to reference the property on JS side.

Except from  name ,  @ReactProp annotation may take following optional
arguments:  defaultBoolean ,  defaultInt ,  defaultFloat . Those
arguments should be of the corresponding type (accordingly  boolean ,
 int ,  float in Java and  Boolean ,  Int ,  Float in Kotlin) and the
value provided will be passed to the setter method in case when the
property that the setter is referencing has been removed from the
component. Note that "default" values are only provided for primitive
types, in case when setter is of some complex type,  null will be
provided as a default value in case when corresponding property gets
removed.

Setter declaration requirements for methods annotated with
 @ReactPropGroup are different than for  @ReactProp , please refer to
the  @ReactPropGroup annotation class docs for more information about
it. IMPORTANT! in ReactJS updating the property value will result in
setter method call. Note that one of the ways we can update component is
by removing properties that have been set before. In that case setter
method will be called as well to notify view manager that property has
changed. In that case "default" value will be provided (for primitive
types "default" value can be specified using  defaultBoolean ,
 defaultFloat , etc. arguments of  @ReactProp annotation, for complex
types setter will be called with value set to  null ).

-   Java
-   Kotlin

      @ReactProp(name = "src")
      fun setSrc(view: ReactImageView, sources: ReadableArray?) {
        view.setSource(sources)
      }

      @ReactProp(name = "borderRadius", defaultFloat = 0f)
      override fun setBorderRadius(view: ReactImageView, borderRadius: Float) {
        view.setBorderRadius(borderRadius)
      }

      @ReactProp(name = ViewProps.RESIZE_MODE)
      fun setResizeMode(view: ReactImageView, resizeMode: String?) {
        view.setScaleType(ImageResizeMode.toScaleType(resizeMode))
      }

 

      @ReactProp(name = "src")
      public void setSrc(ReactImageView view, @Nullable ReadableArray sources) {
        view.setSource(sources);
      }

      @ReactProp(name = "borderRadius", defaultFloat = 0f)
      public void setBorderRadius(ReactImageView view, float borderRadius) {
        view.setBorderRadius(borderRadius);
      }

      @ReactProp(name = ViewProps.RESIZE_MODE)
      public void setResizeMode(ReactImageView view, @Nullable String resizeMode) {
        view.setScaleType(ImageResizeMode.toScaleType(resizeMode));
      }

 

4. Register the  ViewManager 

The final step is to register the ViewManager to the application, this
happens in a similar way to Native Modules , via the applications
package member function  createViewManagers .

-   Java
-   Kotlin

      override fun createViewManagers(
          reactContext: ReactApplicationContext
      ) = listOf(ReactImageManager(reactContext))

 

      @Override
      public List<ViewManager> createViewManagers(
                                ReactApplicationContext reactContext) {
        return Arrays.<ViewManager>asList(
          new ReactImageManager(reactContext)
        );
      }

 

5. Implement the JavaScript module 

The very final step is to create the JavaScript module that defines the
interface layer between Java/Kotlin and JavaScript for the users of your
new view. It is recommended for you to document the component interface
in this module (e.g. using TypeScript, Flow, or plain old comments).

ImageView.tsx

    import {requireNativeComponent} from 'react-native';

    /**
     * Composes `View`.
     *
     * - src: string
     * - borderRadius: number
     * - resizeMode: 'cover' | 'contain' | 'stretch'
     */
    module.exports = requireNativeComponent('RCTImageView');

 

The  requireNativeComponent function takes the name of the native view.
Note that if your component needs to do anything more sophisticated
(e.g. custom event handling), you should wrap the native component in
another React component. This is illustrated in the  MyCustomView
example below.

Events 

So now we know how to expose native view components that we can control
freely from JS, but how do we deal with events from the user, like
pinch-zooms or panning? When a native event occurs the native code
should issue an event to the JavaScript representation of the View, and
the two views are linked with the value returned from the  getId()
method.

-   Java
-   Kotlin

    class MyCustomView(context: Context) : View(context) {
      ...
      fun onReceiveNativeEvent() {
        val event = Arguments.createMap().apply {
          putString("message", "MyMessage")
        }
        val reactContext = context as ReactContext
        reactContext
            .getJSModule(RCTEventEmitter::class.java)
            .receiveEvent(id, "topChange", event)
      }
    }

 

    class MyCustomView extends View {
       ...
       public void onReceiveNativeEvent() {
          WritableMap event = Arguments.createMap();
          event.putString("message", "MyMessage");
          ReactContext reactContext = (ReactContext)getContext();
          reactContext
              .getJSModule(RCTEventEmitter.class)
              .receiveEvent(getId(), "topChange", event);
        }
    }

 

To map the  topChange event name to the  onChange callback prop in
JavaScript, register it by overriding the
 getExportedCustomBubblingEventTypeConstants method in your  ViewManager
:

-   Java
-   Kotlin

    class ReactImageManager : SimpleViewManager<MyCustomView>() {
      ...
      override fun getExportedCustomBubblingEventTypeConstants(): Map<String, Any> {
        return mapOf(
          "topChange" to mapOf(
            "phasedRegistrationNames" to mapOf(
              "bubbled" to "onChange"
            )
          )
        )
      }
    }

 

    public class ReactImageManager extends SimpleViewManager<MyCustomView> {
        ...
        public Map getExportedCustomBubblingEventTypeConstants() {
            return MapBuilder.builder().put(
                "topChange",
                MapBuilder.of(
                    "phasedRegistrationNames",
                    MapBuilder.of("bubbled", "onChange")
                )
            ).build();
        }
    }

 

This callback is invoked with the raw event, which we typically process
in the wrapper component to make a simpler API:

MyCustomView.tsx

    class MyCustomView extends React.Component {
      constructor(props) {
        super(props);
        this._onChange = this._onChange.bind(this);
      }
      _onChange(event) {
        if (!this.props.onChangeMessage) {
          return;
        }
        this.props.onChangeMessage(event.nativeEvent.message);
      }
      render() {
        return <RCTMyCustomView {...this.props} onChange={this._onChange} />;
      }
    }
    MyCustomView.propTypes = {
      /**
       * Callback that is called continuously when the user is dragging the map.
       */
      onChangeMessage: PropTypes.func,
      ...
    };

    const RCTMyCustomView = requireNativeComponent(`RCTMyCustomView`);

 

Integration with an Android Fragment example 

In order to integrate existing Native UI elements to your React Native
app, you might need to use Android Fragments to give you a more granular
control over your native component than returning a  View from your
 ViewManager . You will need this if you want to add custom logic that
is tied to your view with the help of lifecycle methods , such as
 onViewCreated ,  onPause ,  onResume . The following steps will show
you how to do it:

1. Create an example custom view 

First, let's create a  CustomView class which extends  FrameLayout (the
content of this view can be any view that you'd like to render)

-   Java
-   Kotlin

CustomView.kt

    // replace with your package
    package com.mypackage

    import android.content.Context
    import android.graphics.Color
    import android.widget.FrameLayout
    import android.widget.TextView

    class CustomView(context: Context) : FrameLayout(context) {
      init {
        // set padding and background color
        setPadding(16,16,16,16)
        setBackgroundColor(Color.parseColor("#5FD3F3"))

        // add default text view
        addView(TextView(context).apply {
          text = "Welcome to Android Fragments with React Native."
        })
      }
    }

 

CustomView.java

    // replace with your package
    package com.mypackage;

    import android.content.Context;
    import android.graphics.Color;
    import android.widget.FrameLayout;
    import android.widget.ImageView;
    import android.widget.TextView;

    import androidx.annotation.NonNull;

    public class CustomView extends FrameLayout {
      public CustomView(@NonNull Context context) {
        super(context);
        // set padding and background color
        this.setPadding(16,16,16,16);
        this.setBackgroundColor(Color.parseColor("#5FD3F3"));

        // add default text view
        TextView text = new TextView(context);
        text.setText("Welcome to Android Fragments with React Native.");
        this.addView(text);
      }
    }

 

2. Create a  Fragment 

-   Java
-   Kotlin

MyFragment.kt

    // replace with your package
    package com.mypackage

    import android.os.Bundle
    import android.view.LayoutInflater
    import android.view.View
    import android.view.ViewGroup
    import androidx.fragment.app.Fragment

    // replace with your view's import
    import com.mypackage.CustomView

    class MyFragment : Fragment() {
      private lateinit var customView: CustomView

      override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        super.onCreateView(inflater, container, savedInstanceState)
        customView = CustomView(requireNotNull(context))
        return customView // this CustomView could be any view that you want to render
      }

      override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // do any logic that should happen in an `onCreate` method, e.g:
        // customView.onCreate(savedInstanceState);
      }

      override fun onPause() {
        super.onPause()
        // do any logic that should happen in an `onPause` method
        // e.g.: customView.onPause();
      }

      override fun onResume() {
        super.onResume()
        // do any logic that should happen in an `onResume` method
        // e.g.: customView.onResume();
      }

      override fun onDestroy() {
        super.onDestroy()
        // do any logic that should happen in an `onDestroy` method
        // e.g.: customView.onDestroy();
      }
    }

 

MyFragment.java

    // replace with your package
    package com.mypackage;

    import android.os.Bundle;
    import android.view.LayoutInflater;
    import android.view.View;
    import android.view.ViewGroup;
    import androidx.fragment.app.Fragment;

    // replace with your view's import
    import com.mypackage.CustomView;

    public class MyFragment extends Fragment {
        CustomView customView;

        @Override
        public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
            super.onCreateView(inflater, parent, savedInstanceState);
            customView = new CustomView(this.getContext());
            return customView; // this CustomView could be any view that you want to render
        }

        @Override
        public void onViewCreated(View view, Bundle savedInstanceState) {
            super.onViewCreated(view, savedInstanceState);
            // do any logic that should happen in an `onCreate` method, e.g:
            // customView.onCreate(savedInstanceState);
        }

        @Override
        public void onPause() {
            super.onPause();
            // do any logic that should happen in an `onPause` method
            // e.g.: customView.onPause();
        }

        @Override
        public void onResume() {
            super.onResume();
           // do any logic that should happen in an `onResume` method
           // e.g.: customView.onResume();
        }

        @Override
        public void onDestroy() {
            super.onDestroy();
            // do any logic that should happen in an `onDestroy` method
            // e.g.: customView.onDestroy();
        }
    }

 

3. Create the  ViewManager subclass 

-   Java
-   Kotlin

MyViewManager.kt

    // replace with your package
    package com.mypackage

    import android.view.Choreographer
    import android.view.View
    import android.view.ViewGroup
    import android.widget.FrameLayout
    import androidx.fragment.app.FragmentActivity
    import com.facebook.react.bridge.ReactApplicationContext
    import com.facebook.react.bridge.ReadableArray
    import com.facebook.react.uimanager.ThemedReactContext
    import com.facebook.react.uimanager.ViewGroupManager
    import com.facebook.react.uimanager.annotations.ReactPropGroup

    class MyViewManager(
        private val reactContext: ReactApplicationContext
    ) : ViewGroupManager<FrameLayout>() {
      private var propWidth: Int? = null
      private var propHeight: Int? = null

      override fun getName() = REACT_CLASS

      /**
       * Return a FrameLayout which will later hold the Fragment
       */
      override fun createViewInstance(reactContext: ThemedReactContext) =
          FrameLayout(reactContext)

      /**
       * Map the "create" command to an integer
       */
      override fun getCommandsMap() = mapOf("create" to COMMAND_CREATE)

      /**
       * Handle "create" command (called from JS) and call createFragment method
       */
      override fun receiveCommand(
          root: FrameLayout,
          commandId: String,
          args: ReadableArray?
      ) {
        super.receiveCommand(root, commandId, args)
        val reactNativeViewId = requireNotNull(args).getInt(0)

        when (commandId.toInt()) {
          COMMAND_CREATE -> createFragment(root, reactNativeViewId)
        }
      }

      @ReactPropGroup(names = ["width", "height"], customType = "Style")
      fun setStyle(view: FrameLayout, index: Int, value: Int) {
        if (index == 0) propWidth = value
        if (index == 1) propHeight = value
      }

      /**
       * Replace your React Native view with a custom fragment
       */
      fun createFragment(root: FrameLayout, reactNativeViewId: Int) {
        val parentView = root.findViewById<ViewGroup>(reactNativeViewId)
        setupLayout(parentView)

        val myFragment = MyFragment()
        val activity = reactContext.currentActivity as FragmentActivity
        activity.supportFragmentManager
            .beginTransaction()
            .replace(reactNativeViewId, myFragment, reactNativeViewId.toString())
            .commit()
      }

      fun setupLayout(view: View) {
        Choreographer.getInstance().postFrameCallback(object: Choreographer.FrameCallback {
          override fun doFrame(frameTimeNanos: Long) {
            manuallyLayoutChildren(view)
            view.viewTreeObserver.dispatchOnGlobalLayout()
            Choreographer.getInstance().postFrameCallback(this)
          }
        })
      }

      /**
       * Layout all children properly
       */
      private fun manuallyLayoutChildren(view: View) {
        // propWidth and propHeight coming from react-native props
        val width = requireNotNull(propWidth)
        val height = requireNotNull(propHeight)

        view.measure(
            View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY),
            View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY))

        view.layout(0, 0, width, height)
      }

      companion object {
        private const val REACT_CLASS = "MyViewManager"
        private const val COMMAND_CREATE = 1
      }
    }

 

MyViewManager.java

    // replace with your package
    package com.mypackage;

    import android.view.Choreographer;
    import android.view.View;
    import android.view.ViewGroup;
    import android.widget.FrameLayout;

    import androidx.annotation.NonNull;
    import androidx.annotation.Nullable;
    import androidx.fragment.app.FragmentActivity;

    import com.facebook.react.bridge.ReactApplicationContext;
    import com.facebook.react.bridge.ReadableArray;
    import com.facebook.react.common.MapBuilder;
    import com.facebook.react.uimanager.annotations.ReactProp;
    import com.facebook.react.uimanager.annotations.ReactPropGroup;
    import com.facebook.react.uimanager.ViewGroupManager;
    import com.facebook.react.uimanager.ThemedReactContext;

    import java.util.Map;

    public class MyViewManager extends ViewGroupManager<FrameLayout> {

      public static final String REACT_CLASS = "MyViewManager";
      public final int COMMAND_CREATE = 1;
      private int propWidth;
      private int propHeight;

      ReactApplicationContext reactContext;

      public MyViewManager(ReactApplicationContext reactContext) {
        this.reactContext = reactContext;
      }

      @Override
      public String getName() {
        return REACT_CLASS;
      }

      /**
       * Return a FrameLayout which will later hold the Fragment
       */
      @Override
      public FrameLayout createViewInstance(ThemedReactContext reactContext) {
        return new FrameLayout(reactContext);
      }

      /**
       * Map the "create" command to an integer
       */
      @Nullable
      @Override
      public Map<String, Integer> getCommandsMap() {
        return MapBuilder.of("create", COMMAND_CREATE);
      }

      /**
       * Handle "create" command (called from JS) and call createFragment method
       */
      @Override
      public void receiveCommand(
        @NonNull FrameLayout root,
        String commandId,
        @Nullable ReadableArray args
      ) {
        super.receiveCommand(root, commandId, args);
        int reactNativeViewId = args.getInt(0);
        int commandIdInt = Integer.parseInt(commandId);

        switch (commandIdInt) {
          case COMMAND_CREATE:
            createFragment(root, reactNativeViewId);
            break;
          default: {}
        }
      }

      @ReactPropGroup(names = {"width", "height"}, customType = "Style")
      public void setStyle(FrameLayout view, int index, Integer value) {
        if (index == 0) {
          propWidth = value;
        }

        if (index == 1) {
          propHeight = value;
        }
      }

      /**
       * Replace your React Native view with a custom fragment
       */
      public void createFragment(FrameLayout root, int reactNativeViewId) {
        ViewGroup parentView = (ViewGroup) root.findViewById(reactNativeViewId);
        setupLayout(parentView);

        final MyFragment myFragment = new MyFragment();
        FragmentActivity activity = (FragmentActivity) reactContext.getCurrentActivity();
        activity.getSupportFragmentManager()
                .beginTransaction()
                .replace(reactNativeViewId, myFragment, String.valueOf(reactNativeViewId))
                .commit();
      }

      public void setupLayout(View view) {
        Choreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {
          @Override
          public void doFrame(long frameTimeNanos) {
            manuallyLayoutChildren(view);
            view.getViewTreeObserver().dispatchOnGlobalLayout();
            Choreographer.getInstance().postFrameCallback(this);
          }
        });
      }

      /**
       * Layout all children properly
       */
      public void manuallyLayoutChildren(View view) {
          // propWidth and propHeight coming from react-native props
          int width = propWidth;
          int height = propHeight;

          view.measure(
                  View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY),
                  View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY));

          view.layout(0, 0, width, height);
      }
    }

 

4. Register the  ViewManager 

-   Java
-   Kotlin

MyPackage.kt

    // replace with your package
    package com.mypackage

    import com.facebook.react.ReactPackage
    import com.facebook.react.bridge.ReactApplicationContext
    import com.facebook.react.uimanager.ViewManager

    class MyPackage : ReactPackage {
      ...
      override fun createViewManagers(
          reactContext: ReactApplicationContext
      ) = listOf(MyViewManager(reactContext))
    }

 

MyPackage.java

    // replace with your package
    package com.mypackage;

    import com.facebook.react.ReactPackage;
    import com.facebook.react.bridge.ReactApplicationContext;
    import com.facebook.react.uimanager.ViewManager;

    import java.util.Arrays;
    import java.util.List;

    public class MyPackage implements ReactPackage {

       @Override
       public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
           return Arrays.<ViewManager>asList(
                new MyViewManager(reactContext)
           );
       }

    }

 

5. Register the  Package 

-   Java
-   Kotlin

MainApplication.kt

        override fun getPackages() = PackageList(this).packages.apply {
          add(MyPackage())
        }

 

MainApplication.java

        @Override
        protected List<ReactPackage> getPackages() {
          List<ReactPackage> packages = new PackageList(this).getPackages();
          ...
          packages.add(new MyPackage());
          return packages;
        }

 

6. Implement the JavaScript module 

I. Start with custom View manager:

MyViewManager.tsx

    import {requireNativeComponent} from 'react-native';

    export const MyViewManager =
      requireNativeComponent('MyViewManager');

 

II. Then implement custom View calling the  create method:

MyView.tsx

    import React, {useEffect, useRef} from 'react';
    import {
      PixelRatio,
      UIManager,
      findNodeHandle,
    } from 'react-native';

    import {MyViewManager} from './my-view-manager';

    const createFragment = viewId =>
      UIManager.dispatchViewManagerCommand(
        viewId,
        // we are calling the 'create' command
        UIManager.MyViewManager.Commands.create.toString(),
        [viewId],
      );

    export const MyView = () => {
      const ref = useRef(null);

      useEffect(() => {
        const viewId = findNodeHandle(ref.current);
        createFragment(viewId);
      }, );

      return (
        <MyViewManager
          style={{
            // converts dpi to px, provide desired height
            height: PixelRatio.getPixelSizeForLayoutSize(200),
            // converts dpi to px, provide desired width
            width: PixelRatio.getPixelSizeForLayoutSize(200),
          }}
          ref={ref}
        />
      );
    };

 

If you want to expose property setters using  @ReactProp (or
 @ReactPropGroup ) annotation see the ImageView example above.

# Animated #
    _          _                 _           _ 
   / \   _ __ (_)_ __ ___   __ _| |_ ___  __| |
  / _ \ | '_ \| | '_ ` _ \ / _` | __/ _ \/ _` |
 / ___ \| | | | | | | | | | (_| | ||  __/ (_| |
/_/   \_\_| |_|_|_| |_| |_|\__,_|\__\___|\__,_|
                                               
-   Example
-   Overview
    -   Configuring animations
    -   Working with animations
    -   Using the native driver
    -   Animatable components
    -   Composing animations
    -   Combining animated values
    -   Interpolation
    -   Handling gestures and other events
-   Methods
    -    decay()
    -    timing()
    -    spring()
    -    add()
    -    subtract()
    -    divide()
    -    multiply()
    -    modulo()
    -    diffClamp()
    -    delay()
    -    sequence()
    -    parallel()
    -    stagger()
    -    loop()
    -    event()
    -    forkEvent()
    -    unforkEvent()
    -    start()
    -    stop()
    -    reset()
-   Properties
    -    Value
    -    ValueXY
    -    Interpolation
    -    Node
    -    createAnimatedComponent
    -    attachNativeEvent
Animated

The  Animated library is designed to make animations fluid, powerful,
and painless to build and maintain.  Animated focuses on declarative
relationships between inputs and outputs, configurable transforms in
between, and  start /  stop methods to control time-based animation
execution.

The core workflow for creating an animation is to create an
 Animated.Value , hook it up to one or more style attributes of an
animated component, and then drive updates via animations using
 Animated.timing() .

  Don't modify the animated value directly. You can use the  useRef Hook
  to return a mutable ref object. This ref object's  current property is
  initialized as the given argument and persists throughout the
  component lifecycle.

Example 

The following example contains a  View which will fade in and fade out
based on the animated value  fadeAnim

Refer to the Animations guide to see additional examples of  Animated in
action.

Overview 

There are two value types you can use with  Animated :

-    Animated.Value() for single values
-    Animated.ValueXY() for vectors

 Animated.Value can bind to style properties or other props, and can be
interpolated as well. A single  Animated.Value can drive any number of
properties.

Configuring animations 

 Animated provides three types of animation types. Each animation type
provides a particular animation curve that controls how your values
animate from their initial value to the final value:

-    Animated.decay() starts with an initial velocity and gradually
    slows to a stop.
-    Animated.spring() provides a basic spring physics model.
-    Animated.timing() animates a value over time using easing functions
    .

In most cases, you will be using  timing() . By default, it uses a
symmetric easeInOut curve that conveys the gradual acceleration of an
object to full speed and concludes by gradually decelerating to a stop.

Working with animations 

Animations are started by calling  start() on your animation.  start()
takes a completion callback that will be called when the animation is
done. If the animation finished running normally, the completion
callback will be invoked with  {finished: true} . If the animation is
done because  stop() was called on it before it could finish (e.g.
because it was interrupted by a gesture or another animation), then it
will receive  {finished: false} .

    Animated.timing({}).start(({finished}) => {
      /* completion callback */
    });

 

Using the native driver 

By using the native driver, we send everything about the animation to
native before starting the animation, allowing native code to perform
the animation on the UI thread without having to go through the bridge
on every frame. Once the animation has started, the JS thread can be
blocked without affecting the animation.

You can use the native driver by specifying  useNativeDriver: true in
your animation configuration. See the Animations guide to learn more.

Animatable components 

Only animatable components can be animated. These unique components do
the magic of binding the animated values to the properties, and do
targeted native updates to avoid the cost of the React render and
reconciliation process on every frame. They also handle cleanup on
unmount so they are safe by default.

-    createAnimatedComponent() can be used to make a component
    animatable.

 Animated exports the following animatable components using the above
wrapper:

-    Animated.Image
-    Animated.ScrollView
-    Animated.Text
-    Animated.View
-    Animated.FlatList
-    Animated.SectionList

Composing animations 

Animations can also be combined in complex ways using composition
functions:

-    Animated.delay() starts an animation after a given delay.
-    Animated.parallel() starts a number of animations at the same time.
-    Animated.sequence() starts the animations in order, waiting for
    each to complete before starting the next.
-    Animated.stagger() starts animations in order and in parallel, but
    with successive delays.

Animations can also be chained together by setting the  toValue of one
animation to be another  Animated.Value . See Tracking dynamic values in
the Animations guide.

By default, if one animation is stopped or interrupted, then all other
animations in the group are also stopped.

Combining animated values 

You can combine two animated values via addition, subtraction,
multiplication, division, or modulo to make a new animated value:

-    Animated.add()
-    Animated.subtract()
-    Animated.divide()
-    Animated.modulo()
-    Animated.multiply()

Interpolation 

The  interpolate() function allows input ranges to map to different
output ranges. By default, it will extrapolate the curve beyond the
ranges given, but you can also have it clamp the output value. It uses
linear interpolation by default but also supports easing functions.

-    interpolate()

Read more about interpolation in the Animation guide.

Handling gestures and other events 

Gestures, like panning or scrolling, and other events can map directly
to animated values using  Animated.event() . This is done with a
structured map syntax so that values can be extracted from complex event
objects. The first level is an array to allow mapping across multiple
args, and that array contains nested objects.

-    Animated.event()

For example, when working with horizontal scrolling gestures, you would
do the following in order to map  event.nativeEvent.contentOffset.x to
 scrollX (an  Animated.Value ):

     onScroll={Animated.event(
       // scrollX = e.nativeEvent.contentOffset.x
       [{nativeEvent: {
            contentOffset: {
              x: scrollX
            }
          }
        }]
     )}

 

------------------------------------------------------------------------

Reference

Methods 

When the given value is a ValueXY instead of a Value, each config option
may be a vector of the form  {x: ..., y: ...} instead of a scalar.

 decay() 

    static decay(value, config): CompositeAnimation;

 

Animates a value from an initial velocity to zero based on a decay
coefficient.

Config is an object that may have the following options:

-    velocity : Initial velocity. Required.
-    deceleration : Rate of decay. Default 0.997.
-    isInteraction : Whether or not this animation creates an
    "interaction handle" on the  InteractionManager . Default true.
-    useNativeDriver : Uses the native driver when true. Required.

------------------------------------------------------------------------

 timing() 

    static timing(value, config): CompositeAnimation;

 

Animates a value along a timed easing curve. The  Easing module has tons
of predefined curves, or you can use your own function.

Config is an object that may have the following options:

-    duration : Length of animation (milliseconds). Default 500.
-    easing : Easing function to define curve. Default is
     Easing.inOut(Easing.ease) .
-    delay : Start the animation after delay (milliseconds). Default 0.
-    isInteraction : Whether or not this animation creates an
    "interaction handle" on the  InteractionManager . Default true.
-    useNativeDriver : Uses the native driver when true. Required.

------------------------------------------------------------------------

 spring() 

    static spring(value, config): CompositeAnimation;

 

Animates a value according to an analytical spring model based on damped
harmonic oscillation . Tracks velocity state to create fluid motions as
the  toValue updates, and can be chained together.

Config is an object that may have the following options.

Note that you can only define one of bounciness/speed, tension/friction,
or stiffness/damping/mass, but not more than one:

The friction/tension or bounciness/speed options match the spring model
in  Facebook Pop , Rebound , and Origami .

-    friction : Controls "bounciness"/overshoot. Default 7.
-    tension : Controls speed. Default 40.
-    speed : Controls speed of the animation. Default 12.
-    bounciness : Controls bounciness. Default 8.

Specifying stiffness/damping/mass as parameters makes  Animated.spring
use an analytical spring model based on the motion equations of a damped
harmonic oscillator . This behavior is slightly more precise and
faithful to the physics behind spring dynamics, and closely mimics the
implementation in iOS's CASpringAnimation.

-    stiffness : The spring stiffness coefficient. Default 100.
-    damping : Defines how the spring’s motion should be damped due to
    the forces of friction. Default 10.
-    mass : The mass of the object attached to the end of the spring.
    Default 1.

Other configuration options are as follows:

-    velocity : The initial velocity of the object attached to the
    spring. Default 0 (object is at rest).
-    overshootClamping : Boolean indicating whether the spring should be
    clamped and not bounce. Default false.
-    restDisplacementThreshold : The threshold of displacement from rest
    below which the spring should be considered at rest. Default 0.001.
-    restSpeedThreshold : The speed at which the spring should be
    considered at rest in pixels per second. Default 0.001.
-    delay : Start the animation after delay (milliseconds). Default 0.
-    isInteraction : Whether or not this animation creates an
    "interaction handle" on the  InteractionManager . Default true.
-    useNativeDriver : Uses the native driver when true. Required.

------------------------------------------------------------------------

 add() 

    static add(a: Animated, b: Animated): AnimatedAddition;

 

Creates a new Animated value composed from two Animated values added
together.

------------------------------------------------------------------------

 subtract() 

    static subtract(a: Animated, b: Animated): AnimatedSubtraction;

 

Creates a new Animated value composed by subtracting the second Animated
value from the first Animated value.

------------------------------------------------------------------------

 divide() 

    static divide(a: Animated, b: Animated): AnimatedDivision;

 

Creates a new Animated value composed by dividing the first Animated
value by the second Animated value.

------------------------------------------------------------------------

 multiply() 

    static multiply(a: Animated, b: Animated): AnimatedMultiplication;

 

Creates a new Animated value composed from two Animated values
multiplied together.

------------------------------------------------------------------------

 modulo() 

    static modulo(a: Animated, modulus: number): AnimatedModulo;

 

Creates a new Animated value that is the (non-negative) modulo of the
provided Animated value

------------------------------------------------------------------------

 diffClamp() 

    static diffClamp(a: Animated, min: number, max: number): AnimatedDiffClamp;

 

Create a new Animated value that is limited between 2 values. It uses
the difference between the last value so even if the value is far from
the bounds it will start changing when the value starts getting closer
again. (  value = clamp(value + diff, min, max) ).

This is useful with scroll events, for example, to show the navbar when
scrolling up and to hide it when scrolling down.

------------------------------------------------------------------------

 delay() 

    static delay(time: number): CompositeAnimation;

 

Starts an animation after the given delay.

------------------------------------------------------------------------

 sequence() 

    static sequence(animations: CompositeAnimation): CompositeAnimation;

 

Starts an array of animations in order, waiting for each to complete
before starting the next. If the current running animation is stopped,
no following animations will be started.

------------------------------------------------------------------------

 parallel() 

    static parallel(
      animations: CompositeAnimation,
      config?: ParallelConfig
    ): CompositeAnimation;

 

Starts an array of animations all at the same time. By default, if one
of the animations is stopped, they will all be stopped. You can override
this with the  stopTogether flag.

------------------------------------------------------------------------

 stagger() 

    static stagger(
      time: number,
      animations: CompositeAnimation
    ): CompositeAnimation;

 

Array of animations may run in parallel (overlap), but are started in
sequence with successive delays. Nice for doing trailing effects.

------------------------------------------------------------------------

 loop() 

    static loop(
      animation: CompositeAnimation,
      config?: LoopAnimationConfig
    ): CompositeAnimation;

 

Loops a given animation continuously, so that each time it reaches the
end, it resets and begins again from the start. Will loop without
blocking the JS thread if the child animation is set to
 useNativeDriver: true . In addition, loops can prevent  VirtualizedList
-based components from rendering more rows while the animation is
running. You can pass  isInteraction: false in the child animation
config to fix this.

Config is an object that may have the following options:

-    iterations : Number of times the animation should loop. Default  -1
    (infinite).

------------------------------------------------------------------------

 event() 

    static event(
      argMapping: Mapping,
      config?: EventConfig
    ): (...args: any) => void;

 

Takes an array of mappings and extracts values from each arg
accordingly, then calls  setValue on the mapped outputs. e.g.

    onScroll={Animated.event(
      [{nativeEvent: {contentOffset: {x: this._scrollX}}}],
      {listener: (event: ScrollEvent) => console.log(event)}, // Optional async listener
    )}
     ...
    onPanResponderMove: Animated.event(
      [
        null, // raw event arg ignored
        {dx: this._panX},
      ], // gestureState arg
      {
        listener: (
          event: GestureResponderEvent,
          gestureState: PanResponderGestureState
        ) => console.log(event, gestureState),
      } // Optional async listener
    );

 

Config is an object that may have the following options:

-    listener : Optional async listener.
-    useNativeDriver : Uses the native driver when true. Required.

------------------------------------------------------------------------

 forkEvent() 

    static forkEvent(event: AnimatedEvent, listener: Function): AnimatedEvent;

 

Advanced imperative API for snooping on animated events that are passed
in through props. It permits to add a new javascript listener to an
existing  AnimatedEvent . If  animatedEvent is a javascript listener, it
will merge the 2 listeners into a single one, and if  animatedEvent is
null/undefined, it will assign the javascript listener directly. Use
values directly where possible.

------------------------------------------------------------------------

 unforkEvent() 

    static unforkEvent(event: AnimatedEvent, listener: Function);

 

------------------------------------------------------------------------

 start() 

    static start(callback?: (result: {finished: boolean}) => void);

 

Animations are started by calling start() on your animation. start()
takes a completion callback that will be called when the animation is
done or when the animation is done because stop() was called on it
before it could finish.

Parameters:

  Name       Type                                     Required   Description
  ---------- ---------------------------------------- ---------- -----------------------------------------------------------------------------------------------------------------------------------------------------------------
  callback    (result: {finished: boolean}) => void   No         Function that will be called after the animation finished running normally or when the animation is done because stop() was called on it before it could finish

Start example with callback:

    Animated.timing({}).start(({finished}) => {
      /* completion callback */
    });

 

------------------------------------------------------------------------

 stop() 

    static stop();

 

Stops any running animation.

------------------------------------------------------------------------

 reset() 

    static reset();

 

Stops any running animation and resets the value to its original.

Properties 

 Value 

Standard value class for driving animations. Typically initialized with
 new Animated.Value(0);

You can read more about  Animated.Value API on the separate page .

------------------------------------------------------------------------

 ValueXY 

2D value class for driving 2D animations, such as pan gestures.

You can read more about  Animated.ValueXY API on the separate page .

------------------------------------------------------------------------

 Interpolation 

Exported to use the Interpolation type in flow.

------------------------------------------------------------------------

 Node 

Exported for ease of type checking. All animated values derive from this
class.

------------------------------------------------------------------------

 createAnimatedComponent 

Make any React component Animatable. Used to create  Animated.View ,
etc.

------------------------------------------------------------------------

 attachNativeEvent 

Imperative API to attach an animated value to an event on a view. Prefer
using  Animated.event with  useNativeDriver: true if possible.

# Animated.Value #
    _          _                 _           ___     __    _            
   / \   _ __ (_)_ __ ___   __ _| |_ ___  __| \ \   / /_ _| |_   _  ___ 
  / _ \ | '_ \| | '_ ` _ \ / _` | __/ _ \/ _` |\ \ / / _` | | | | |/ _ \
 / ___ \| | | | | | | | | | (_| | ||  __/ (_| |_\ V / (_| | | |_| |  __/
/_/   \_\_| |_|_|_| |_| |_|\__,_|\__\___|\__,_(_)\_/ \__,_|_|\__,_|\___|
                                                                        
-   Methods
    -    setValue()
    -    setOffset()
    -    flattenOffset()
    -    extractOffset()
    -    addListener()
    -    removeListener()
    -    removeAllListeners()
    -    stopAnimation()
    -    resetAnimation()
    -    interpolate()
    -    animate()
Animated.Value

Standard value for driving animations. One  Animated.Value can drive
multiple properties in a synchronized fashion, but can only be driven by
one mechanism at a time. Using a new mechanism (e.g. starting a new
animation, or calling  setValue ) will stop any previous ones.

Typically initialized with  new Animated.Value(0);

------------------------------------------------------------------------

Reference

Methods 

 setValue() 

    setValue(value: number);

 

Directly set the value. This will stop any animations running on the
value and update all the bound properties.

Parameters:

  Name    Type     Required   Description
  ------- -------- ---------- -------------
  value   number   Yes        Value

------------------------------------------------------------------------

 setOffset() 

    setOffset(offset: number);

 

Sets an offset that is applied on top of whatever value is set, whether
via  setValue , an animation, or  Animated.event . Useful for
compensating things like the start of a pan gesture.

Parameters:

  Name     Type     Required   Description
  -------- -------- ---------- --------------
  offset   number   Yes        Offset value

------------------------------------------------------------------------

 flattenOffset() 

    flattenOffset();

 

Merges the offset value into the base value and resets the offset to
zero. The final output of the value is unchanged.

------------------------------------------------------------------------

 extractOffset() 

    extractOffset();

 

Sets the offset value to the base value, and resets the base value to
zero. The final output of the value is unchanged.

------------------------------------------------------------------------

 addListener() 

    addListener(callback: (state: {value: number}) => void): string;

 

Adds an asynchronous listener to the value so you can observe updates
from animations. This is useful because there is no way to synchronously
read the value because it might be driven natively.

Returns a string that serves as an identifier for the listener.

Parameters:

  Name       Type       Required   Description
  ---------- ---------- ---------- --------------------------------------------------------------------------------------------
  callback   function   Yes        The callback function which will receive an object with a  value key set to the new value.

------------------------------------------------------------------------

 removeListener() 

    removeListener(id: string);

 

Unregister a listener. The  id param shall match the identifier
previously returned by  addListener() .

Parameters:

  Name   Type     Required   Description
  ------ -------- ---------- ------------------------------------
  id     string   Yes        Id for the listener being removed.

------------------------------------------------------------------------

 removeAllListeners() 

    removeAllListeners();

 

Remove all registered listeners.

------------------------------------------------------------------------

 stopAnimation() 

    stopAnimation(callback?: (value: number) => void);

 

Stops any running animation or tracking.  callback is invoked with the
final value after stopping the animation, which is useful for updating
state to match the animation position with layout.

Parameters:

  Name       Type       Required   Description
  ---------- ---------- ---------- -----------------------------------------------
  callback   function   No         A function that will receive the final value.

------------------------------------------------------------------------

 resetAnimation() 

    resetAnimation(callback?: (value: number) => void);

 

Stops any animation and resets the value to its original.

Parameters:

  Name       Type       Required   Description
  ---------- ---------- ---------- --------------------------------------------------
  callback   function   No         A function that will receive the original value.

------------------------------------------------------------------------

 interpolate() 

    interpolate(config: InterpolationConfigType);

 

Interpolates the value before updating the property, e.g. mapping 0-1 to
0-10.

See  AnimatedInterpolation.js

Parameters:

  Name     Type     Required   Description
  -------- -------- ---------- -------------
  config   object   Yes        See below.

The  config object is composed of the following keys:

-    inputRange : an array of numbers
-    outputRange : an array of numbers or strings
-    easing (optional): a function that returns a number, given an input
    number
-    extrapolate (optional): a string such as 'extend', 'identity', or
    'clamp'
-    extrapolateLeft (optional): a string such as 'extend', 'identity',
    or 'clamp'
-    extrapolateRight (optional): a string such as 'extend', 'identity',
    or 'clamp'

------------------------------------------------------------------------

 animate() 

    animate(animation, callback);

 

Typically only used internally, but could be used by a custom Animation
class.

Parameters:

  Name        Type        Required   Description
  ----------- ----------- ---------- ---------------------
  animation   Animation   Yes        See  Animation.js .
  callback    function    Yes        Callback function.

# Animated.ValueXY #
    _          _                 _           ___     __    _           __  __
   / \   _ __ (_)_ __ ___   __ _| |_ ___  __| \ \   / /_ _| |_   _  ___\ \/ /
  / _ \ | '_ \| | '_ ` _ \ / _` | __/ _ \/ _` |\ \ / / _` | | | | |/ _ \\  / 
 / ___ \| | | | | | | | | | (_| | ||  __/ (_| |_\ V / (_| | | |_| |  __//  \ 
/_/   \_\_| |_|_|_| |_| |_|\__,_|\__\___|\__,_(_)\_/ \__,_|_|\__,_|\___/_/\_\
                                                                             
__   __
\ \ / /
 \ V / 
  | |  
  |_|  
       
-   Example
-   Methods
    -    setValue()
    -    setOffset()
    -    flattenOffset()
    -    extractOffset()
    -    addListener()
    -    removeListener()
    -    removeAllListeners()
    -    stopAnimation()
    -    resetAnimation()
    -    getLayout()
    -    getTranslateTransform()
Animated.ValueXY

2D Value for driving 2D animations, such as pan gestures. Almost
identical API to normal  Animated.Value , but multiplexed. Contains two
regular  Animated.Value s under the hood.

Example 

------------------------------------------------------------------------

Reference

Methods 

 setValue() 

    setValue(value: {x: number; y: number});

 

Directly set the value. This will stop any animations running on the
value and update all the bound properties.

Parameters:

  Name    Type                      Required   Description
  ------- ------------------------- ---------- -------------
  value    {x: number; y: number}   Yes        Value

------------------------------------------------------------------------

 setOffset() 

    setOffset(offset: {x: number; y: number});

 

Sets an offset that is applied on top of whatever value is set, whether
via  setValue , an animation, or  Animated.event . Useful for
compensating things like the start of a pan gesture.

Parameters:

  Name     Type                      Required   Description
  -------- ------------------------- ---------- --------------
  offset    {x: number; y: number}   Yes        Offset value

------------------------------------------------------------------------

 flattenOffset() 

    flattenOffset();

 

Merges the offset value into the base value and resets the offset to
zero. The final output of the value is unchanged.

------------------------------------------------------------------------

 extractOffset() 

    extractOffset();

 

Sets the offset value to the base value, and resets the base value to
zero. The final output of the value is unchanged.

------------------------------------------------------------------------

 addListener() 

    addListener(callback: (value: {x: number; y: number}) => void);

 

Adds an asynchronous listener to the value so you can observe updates
from animations. This is useful because there is no way to synchronously
read the value because it might be driven natively.

Returns a string that serves as an identifier for the listener.

Parameters:

  Name       Type       Required   Description
  ---------- ---------- ---------- --------------------------------------------------------------------------------------------
  callback   function   Yes        The callback function which will receive an object with a  value key set to the new value.

------------------------------------------------------------------------

 removeListener() 

    removeListener(id: string);

 

Unregister a listener. The  id param shall match the identifier
previously returned by  addListener() .

Parameters:

  Name   Type     Required   Description
  ------ -------- ---------- ------------------------------------
  id     string   Yes        Id for the listener being removed.

------------------------------------------------------------------------

 removeAllListeners() 

    removeAllListeners();

 

Remove all registered listeners.

------------------------------------------------------------------------

 stopAnimation() 

    stopAnimation(callback?: (value: {x: number; y: number}) => void);

 

Stops any running animation or tracking.  callback is invoked with the
final value after stopping the animation, which is useful for updating
state to match the animation position with layout.

Parameters:

  Name       Type       Required   Description
  ---------- ---------- ---------- -----------------------------------------------
  callback   function   No         A function that will receive the final value.

------------------------------------------------------------------------

 resetAnimation() 

    resetAnimation(callback?: (value: {x: number; y: number}) => void);

 

Stops any animation and resets the value to its original.

Parameters:

  Name       Type       Required   Description
  ---------- ---------- ---------- --------------------------------------------------
  callback   function   No         A function that will receive the original value.

------------------------------------------------------------------------

 getLayout() 

    getLayout(): {left: Animated.Value, top: Animated.Value};

 

Converts  {x, y} into  {left, top} for use in style, e.g.

    style={this.state.anim.getLayout()}

 

------------------------------------------------------------------------

 getTranslateTransform() 

    getTranslateTransform(): [
      {translateX: Animated.Value},
      {translateY: Animated.Value},
    ];

 

Converts  {x, y} into a useable translation transform, e.g.

    style={{
      transform: this.state.anim.getTranslateTransform()
    }}

 

# Animations #
    _          _                 _   _                 
   / \   _ __ (_)_ __ ___   __ _| |_(_) ___  _ __  ___ 
  / _ \ | '_ \| | '_ ` _ \ / _` | __| |/ _ \| '_ \/ __|
 / ___ \| | | | | | | | | | (_| | |_| | (_) | | | \__ \
/_/   \_\_| |_|_|_| |_| |_|\__,_|\__|_|\___/|_| |_|___/
                                                       
-    Animated API
    -   Configuring animations
    -   Composing animations
    -   Combining animated values
    -   Interpolation
    -   Tracking dynamic values
    -   Tracking gestures
    -   Responding to the current animation value
    -   Using the native driver
    -   Bear in mind
    -   Additional examples
-    LayoutAnimation API
-   Additional notes
    -    requestAnimationFrame
    -    setNativeProps
Animations

Animations are very important to create a great user experience.
Stationary objects must overcome inertia as they start moving. Objects
in motion have momentum and rarely come to a stop immediately.
Animations allow you to convey physically believable motion in your
interface.

React Native provides two complementary animation systems:  Animated for
granular and interactive control of specific values, and
 LayoutAnimation for animated global layout transactions.

 Animated API 

The  Animated API is designed to concisely express a wide variety of
interesting animation and interaction patterns in a very performant way.
 Animated focuses on declarative relationships between inputs and
outputs, with configurable transforms in between, and  start /  stop
methods to control time-based animation execution.

 Animated exports six animatable component types:  View ,  Text ,  Image
,  ScrollView ,  FlatList and  SectionList , but you can also create
your own using  Animated.createAnimatedComponent() .

For example, a container view that fades in when it is mounted may look
like this:

-   TypeScript
-   JavaScript

Let's break down what's happening here. In the  FadeInView constructor,
a new  Animated.Value called  fadeAnim is initialized as part of  state
. The opacity property on the  View is mapped to this animated value.
Behind the scenes, the numeric value is extracted and used to set
opacity.

When the component mounts, the opacity is set to 0. Then, an easing
animation is started on the  fadeAnim animated value, which will update
all of its dependent mappings (in this case, only the opacity) on each
frame as the value animates to the final value of 1.

This is done in an optimized way that is faster than calling  setState
and re-rendering. Because the entire configuration is declarative, we
will be able to implement further optimizations that serialize the
configuration and runs the animation on a high-priority thread.

Configuring animations 

Animations are heavily configurable. Custom and predefined easing
functions, delays, durations, decay factors, spring constants, and more
can all be tweaked depending on the type of animation.

 Animated provides several animation types, the most commonly used one
being  Animated.timing() . It supports animating a value over time using
one of various predefined easing functions, or you can use your own.
Easing functions are typically used in animation to convey gradual
acceleration and deceleration of objects.

By default,  timing will use an easeInOut curve that conveys gradual
acceleration to full speed and concludes by gradually decelerating to a
stop. You can specify a different easing function by passing an  easing
parameter. Custom  duration or even a  delay before the animation starts
is also supported.

For example, if we want to create a 2-second long animation of an object
that slightly backs up before moving to its final position:

    Animated.timing(this.state.xPosition, {
      toValue: 100,
      easing: Easing.back(),
      duration: 2000,
      useNativeDriver: true,
    }).start();

 

Take a look at the Configuring animations section of the  Animated API
reference to learn more about all the config parameters supported by the
built-in animations.

Composing animations 

Animations can be combined and played in sequence or in parallel.
Sequential animations can play immediately after the previous animation
has finished, or they can start after a specified delay. The  Animated
API provides several methods, such as  sequence() and  delay() , each of
which take an array of animations to execute and automatically calls
 start() /  stop() as needed.

For example, the following animation coasts to a stop, then it springs
back while twirling in parallel:

    Animated.sequence([
      // decay, then spring to start and twirl
      Animated.decay(position, {
        // coast to a stop
        velocity: {x: gestureState.vx, y: gestureState.vy}, // velocity from gesture release
        deceleration: 0.997,
        useNativeDriver: true,
      }),
      Animated.parallel([
        // after decay, in parallel:
        Animated.spring(position, {
          toValue: {x: 0, y: 0}, // return to start
          useNativeDriver: true,
        }),
        Animated.timing(twirl, {
          // and twirl
          toValue: 360,
          useNativeDriver: true,
        }),
      ]),
    ]).start(); // start the sequence group

 

If one animation is stopped or interrupted, then all other animations in
the group are also stopped.  Animated.parallel has a  stopTogether
option that can be set to  false to disable this.

You can find a full list of composition methods in the Composing
animations section of the  Animated API reference.

Combining animated values 

You can combine two animated values via addition, multiplication,
division, or modulo to make a new animated value.

There are some cases where an animated value needs to invert another
animated value for calculation. An example is inverting a scale (2x -->
0.5x):

    const a = new Animated.Value(1);
    const b = Animated.divide(1, a);

    Animated.spring(a, {
      toValue: 2,
      useNativeDriver: true,
    }).start();

 

Interpolation 

Each property can be run through an interpolation first. An
interpolation maps input ranges to output ranges, typically using a
linear interpolation but also supports easing functions. By default, it
will extrapolate the curve beyond the ranges given, but you can also
have it clamp the output value.

A basic mapping to convert a 0-1 range to a 0-100 range would be:

    value.interpolate({
      inputRange: [0, 1],
      outputRange: [0, 100],
    });

 

For example, you may want to think about your  Animated.Value as going
from 0 to 1, but animate the position from 150px to 0px and the opacity
from 0 to 1. This can be done by modifying  style from the example above
like so:

      style={{
        opacity: this.state.fadeAnim, // Binds directly
        transform: [{
          translateY: this.state.fadeAnim.interpolate({
            inputRange: [0, 1],
            outputRange: [150, 0]  // 0 : 150, 0.5 : 75, 1 : 0
          }),
        }],
      }}

 

 interpolate() supports multiple range segments as well, which is handy
for defining dead zones and other handy tricks. For example, to get a
negation relationship at -300 that goes to 0 at -100, then back up to 1
at 0, and then back down to zero at 100 followed by a dead-zone that
remains at 0 for everything beyond that, you could do:

    value.interpolate({
      inputRange: [-300, -100, 0, 100, 101],
      outputRange: [300, 0, 1, 0, 0],
    });

 

Which would map like so:

    Input | Output
    ------|-------
      -400|    450
      -300|    300
      -200|    150
      -100|      0
       -50|    0.5
         0|      1
        50|    0.5
       100|      0
       101|      0
       200|      0

 

 interpolate() also supports mapping to strings, allowing you to animate
colors as well as values with units. For example, if you wanted to
animate a rotation you could do:

    value.interpolate({
      inputRange: [0, 360],
      outputRange: ['0deg', '360deg'],
    });

 

 interpolate() also supports arbitrary easing functions, many of which
are already implemented in the  Easing module.  interpolate() also has
configurable behavior for extrapolating the  outputRange . You can set
the extrapolation by setting the  extrapolate ,  extrapolateLeft , or
 extrapolateRight options. The default value is  extend but you can use
 clamp to prevent the output value from exceeding  outputRange .

Tracking dynamic values 

Animated values can also track other values by setting the  toValue of
an animation to another animated value instead of a plain number. For
example, a "Chat Heads" animation like the one used by Messenger on
Android could be implemented with a  spring() pinned on another animated
value, or with  timing() and a  duration of 0 for rigid tracking. They
can also be composed with interpolations:

    Animated.spring(follower, {toValue: leader}).start();
    Animated.timing(opacity, {
      toValue: pan.x.interpolate({
        inputRange: [0, 300],
        outputRange: [1, 0],
        useNativeDriver: true,
      }),
    }).start();

 

The  leader and  follower animated values would be implemented using
 Animated.ValueXY() .  ValueXY is a handy way to deal with 2D
interactions, such as panning or dragging. It is a basic wrapper that
contains two  Animated.Value instances and some helper functions that
call through to them, making  ValueXY a drop-in replacement for  Value
in many cases. It allows us to track both x and y values in the example
above.

Tracking gestures 

Gestures, like panning or scrolling, and other events can map directly
to animated values using  Animated.event . This is done with a
structured map syntax so that values can be extracted from complex event
objects. The first level is an array to allow mapping across multiple
args, and that array contains nested objects.

For example, when working with horizontal scrolling gestures, you would
do the following in order to map  event.nativeEvent.contentOffset.x to
 scrollX (an  Animated.Value ):

     onScroll={Animated.event(
       // scrollX = e.nativeEvent.contentOffset.x
       [{nativeEvent: {
            contentOffset: {
              x: scrollX
            }
          }
        }]
     )}

 

The following example implements a horizontal scrolling carousel where
the scroll position indicators are animated using the  Animated.event
used in the  ScrollView

ScrollView with Animated Event Example 

When using  PanResponder , you could use the following code to extract
the x and y positions from  gestureState.dx and  gestureState.dy . We
use a  null in the first position of the array, as we are only
interested in the second argument passed to the  PanResponder handler,
which is the  gestureState .

    onPanResponderMove={Animated.event(
      [null, // ignore the native event
      // extract dx and dy from gestureState
      // like 'pan.x = gestureState.dx, pan.y = gestureState.dy'
      {dx: pan.x, dy: pan.y}
    ])}

 

PanResponder with Animated Event Example 

Responding to the current animation value 

You may notice that there is no clear way to read the current value
while animating. This is because the value may only be known in the
native runtime due to optimizations. If you need to run JavaScript in
response to the current value, there are two approaches:

-    spring.stopAnimation(callback) will stop the animation and invoke
     callback with the final value. This is useful when making gesture
    transitions.
-    spring.addListener(callback) will invoke  callback asynchronously
    while the animation is running, providing a recent value. This is
    useful for triggering state changes, for example snapping a bobble
    to a new option as the user drags it closer, because these larger
    state changes are less sensitive to a few frames of lag compared to
    continuous gestures like panning which need to run at 60 fps.

 Animated is designed to be fully serializable so that animations can be
run in a high performance way, independent of the normal JavaScript
event loop. This does influence the API, so keep that in mind when it
seems a little trickier to do something compared to a fully synchronous
system. Check out  Animated.Value.addListener as a way to work around
some of these limitations, but use it sparingly since it might have
performance implications in the future.

Using the native driver 

The  Animated API is designed to be serializable. By using the native
driver , we send everything about the animation to native before
starting the animation, allowing native code to perform the animation on
the UI thread without having to go through the bridge on every frame.
Once the animation has started, the JS thread can be blocked without
affecting the animation.

Using the native driver for normal animations can be accomplished by
setting  useNativeDriver: true in animation config when starting it.
Animations without a  useNativeDriver property will default to false for
legacy reasons, but emit a warning (and typechecking error in
TypeScript).

    Animated.timing(this.state.animatedValue, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true, // <-- Set this to true
    }).start();

 

Animated values are only compatible with one driver so if you use native
driver when starting an animation on a value, make sure every animation
on that value also uses the native driver.

The native driver also works with  Animated.event . This is especially
useful for animations that follow the scroll position as without the
native driver, the animation will always run a frame behind the gesture
due to the async nature of React Native.

    <Animated.ScrollView // <-- Use the Animated ScrollView wrapper
      scrollEventThrottle={1} // <-- Use 1 here to make sure no events are ever missed
      onScroll={Animated.event(
        [
          {
            nativeEvent: {
              contentOffset: {y: this.state.animatedValue},
            },
          },
        ],
        {useNativeDriver: true}, // <-- Set this to true
      )}>
      {content}
    </Animated.ScrollView>

 

You can see the native driver in action by running the RNTester app ,
then loading the Native Animated Example. You can also take a look at
the source code to learn how these examples were produced.

Caveats 

Not everything you can do with  Animated is currently supported by the
native driver. The main limitation is that you can only animate
non-layout properties: things like  transform and  opacity will work,
but Flexbox and position properties will not. When using  Animated.event
, it will only work with direct events and not bubbling events. This
means it does not work with  PanResponder but does work with things like
 ScrollView#onScroll .

When an animation is running, it can prevent  VirtualizedList components
from rendering more rows. If you need to run a long or looping animation
while the user is scrolling through a list, you can use
 isInteraction: false in your animation's config to prevent this issue.

Bear in mind 

While using transform styles such as  rotateY ,  rotateX , and others
ensure the transform style  perspective is in place. At this time some
animations may not render on Android without it. Example below.

    <Animated.View
      style={{
        transform: [
          {scale: this.state.scale},
          {rotateY: this.state.rotateY},
          {perspective: 1000}, // without this line this Animation will not render on Android while working fine on iOS
        ],
      }}
    />

 

Additional examples 

The RNTester app has various examples of  Animated in use:

-   AnimatedGratuitousApp
-   NativeAnimationsExample

 LayoutAnimation API 

 LayoutAnimation allows you to globally configure  create and  update
animations that will be used for all views in the next render/layout
cycle. This is useful for doing Flexbox layout updates without bothering
to measure or calculate specific properties in order to animate them
directly, and is especially useful when layout changes may affect
ancestors, for example a "see more" expansion that also increases the
size of the parent and pushes down the row below which would otherwise
require explicit coordination between the components in order to animate
them all in sync.

Note that although  LayoutAnimation is very powerful and can be quite
useful, it provides much less control than  Animated and other animation
libraries, so you may need to use another approach if you can't get
 LayoutAnimation to do what you want.

Note that in order to get this to work on Android you need to set the
following flags via  UIManager :

    UIManager.setLayoutAnimationEnabledExperimental(true);

 

This example uses a preset value, you can customize the animations as
you need, see LayoutAnimation.js for more information.

Additional notes 

 requestAnimationFrame 

 requestAnimationFrame is a polyfill from the browser that you might be
familiar with. It accepts a function as its only argument and calls that
function before the next repaint. It is an essential building block for
animations that underlies all of the JavaScript-based animation APIs. In
general, you shouldn't need to call this yourself - the animation APIs
will manage frame updates for you.

 setNativeProps 

As mentioned in the Direct Manipulation section ,  setNativeProps allows
us to modify properties of native-backed components (components that are
actually backed by native views, unlike composite components) directly,
without having to  setState and re-render the component hierarchy.

We could use this in the Rebound example to update the scale - this
might be helpful if the component that we are updating is deeply nested
and hasn't been optimized with  shouldComponentUpdate .

If you find your animations with dropping frames (performing below 60
frames per second), look into using  setNativeProps or
 shouldComponentUpdate to optimize them. Or you could run the animations
on the UI thread rather than the JavaScript thread with the
useNativeDriver option . You may also want to defer any computationally
intensive work until after animations are complete, using the
InteractionManager . You can monitor the frame rate by using the In-App
Dev Menu "FPS Monitor" tool.

# Appearance #
    _                                                    
   / \   _ __  _ __   ___  __ _ _ __ __ _ _ __   ___ ___ 
  / _ \ | '_ \| '_ \ / _ \/ _` | '__/ _` | '_ \ / __/ _ \
 / ___ \| |_) | |_) |  __/ (_| | | | (_| | | | | (_|  __/
/_/   \_\ .__/| .__/ \___|\__,_|_|  \__,_|_| |_|\___\___|
        |_|   |_|                                        
-   Example
-   Methods
    -    getColorScheme()
    -    setColorScheme()
    -    addChangeListener()
Appearance

    import {Appearance} from 'react-native';

 

The  Appearance module exposes information about the user's appearance
preferences, such as their preferred color scheme (light or dark).

Developer notes 

-   Android
-   iOS
-   Web

  The  Appearance API is inspired by the Media Queries draft from the
  W3C. The color scheme preference is modeled after the
   prefers-color-scheme CSS media feature .

  The color scheme preference will map to the user's Light or Dark theme
  preference on Android 10 (API level 29) devices and higher.

  The color scheme preference will map to the user's Light or Dark Mode
  preference on iOS 13 devices and higher.

  Note: When taking a screenshot, by default, the color scheme may
  flicker between light and dark mode. It happens because the iOS takes
  snapshots on both color schemes and updating the user interface with
  color scheme is asynchronous.

Example 

You can use the  Appearance module to determine if the user prefers a
dark color scheme:

    const colorScheme = Appearance.getColorScheme();
    if (colorScheme === 'dark') {
      // Use dark color scheme
    }

 

Although the color scheme is available immediately, this may change
(e.g. scheduled color scheme change at sunrise or sunset). Any rendering
logic or styles that depend on the user preferred color scheme should
try to call this function on every render, rather than caching the
value. For example, you may use the  useColorScheme React hook as it
provides and subscribes to color scheme updates, or you may use inline
styles rather than setting a value in a  StyleSheet .

------------------------------------------------------------------------

Reference

Methods 

 getColorScheme() 

    static getColorScheme(): 'light' | 'dark' | null;

 

Indicates the current user preferred color scheme. The value may be
updated later, either through direct user action (e.g. theme selection
in device settings or application-level selected user interface style
via  setColorScheme ) or on a schedule (e.g. light and dark themes that
follow the day/night cycle).

Supported color schemes:

-    light : The user prefers a light color theme.
-    dark : The user prefers a dark color theme.
-   null: The user has not indicated a preferred color theme.

See also:  useColorScheme hook.

  Note:  getColorScheme() will always return  light when debugging with
  Chrome.

------------------------------------------------------------------------

 setColorScheme() 

    static setColorScheme('light' | 'dark' | null): void;

 

Force the application to always adopt a light or dark interface style.
The default value is  null which causes the application to inherit the
system's interface style. If you assign a different value, the new style
applies to the application and all native elements within the
application (Alerts, Pickers etc).

Supported color schemes:

-    light : Apply light user interface style.
-    dark : Apply dark user interface style.
-   null: Follow the system's interface style.

  Note: The change will not affect the system's selected interface style
  or any style set in other applications.

------------------------------------------------------------------------

 addChangeListener() 

    static addChangeListener(
      listener: (preferences: {colorScheme: 'light' | 'dark' | null}) => void,
    ): NativeEventSubscription;

 

Add an event handler that is fired when appearance preferences change.

# App Extensions #
    _                  _____      _                 _                 
   / \   _ __  _ __   | ____|_  _| |_ ___ _ __  ___(_) ___  _ __  ___ 
  / _ \ | '_ \| '_ \  |  _| \ \/ / __/ _ \ '_ \/ __| |/ _ \| '_ \/ __|
 / ___ \| |_) | |_) | | |___ >  <| ||  __/ | | \__ \ | (_) | | | \__ \
/_/   \_\ .__/| .__/  |_____/_/\_\\__\___|_| |_|___/_|\___/|_| |_|___/
        |_|   |_|                                                     
-   Memory use in extensions
    -   Today widget
    -   Other app extensions
App Extensions

App extensions let you provide custom functionality and content outside
of your main app. There are different types of app extensions on iOS,
and they are all covered in the App Extension Programming Guide . In
this guide, we'll briefly cover how you may take advantage of app
extensions on iOS.

Memory use in extensions 

As these extensions are loaded outside of the regular app sandbox, it's
highly likely that several of these app extensions will be loaded
simultaneously. As you might expect, these extensions have small memory
usage limits. Keep these in mind when developing your app extensions.
It's always highly recommended to test your application on an actual
device, and more so when developing app extensions: too frequently,
developers find that their extension works fine in the iOS Simulator,
only to get user reports that their extension is not loading on actual
devices.

We highly recommend that you watch Conrad Kramer's talk on Memory Use in
Extensions to learn more about this topic.

Today widget 

The memory limit of a Today widget is 16 MB. As it happens, Today widget
implementations using React Native may work unreliably because the
memory usage tends to be too high. You can tell if your Today widget is
exceeding the memory limit if it yields the message 'Unable to Load':



Always make sure to test your app extensions in a real device, but be
aware that this may not be sufficient, especially when dealing with
Today widgets. Debug-configured builds are more likely to exceed the
memory limits, while release-configured builds don't fail right away. We
highly recommend that you use Xcode's Instruments to analyze your real
world memory usage, as it's very likely that your release-configured
build is very close to the 16 MB limit. In situations like these, you
can quickly go over the 16 MB limit by performing common operations,
such as fetching data from an API.

To experiment with the limits of React Native Today widget
implementations, try extending the example project in
react-native-today-widget .

Other app extensions 

Other types of app extensions have greater memory limits than the Today
widget. For instance, Custom Keyboard extensions are limited to 48 MB,
and Share extensions are limited to 120 MB. Implementing such app
extensions with React Native is more viable. One proof of concept
example is react-native-ios-share-extension .

# AppRegistry #
    _                ____            _     _              
   / \   _ __  _ __ |  _ \ ___  __ _(_)___| |_ _ __ _   _ 
  / _ \ | '_ \| '_ \| |_) / _ \/ _` | / __| __| '__| | | |
 / ___ \| |_) | |_) |  _ <  __/ (_| | \__ \ |_| |  | |_| |
/_/   \_\ .__/| .__/|_| \_\___|\__, |_|___/\__|_|   \__, |
        |_|   |_|              |___/                |___/ 
-   Methods
    -    getAppKeys()
    -    getRegistry()
    -    getRunnable()
    -    getSectionKeys()
    -    getSections()
    -    registerCancellableHeadlessTask()
    -    registerComponent()
    -    registerConfig()
    -    registerHeadlessTask()
    -    registerRunnable()
    -    registerSection()
    -    runApplication()
    -    setComponentProviderInstrumentationHook()
    -    setWrapperComponentProvider()
    -    startHeadlessTask()
    -    unmountApplicationComponentAtRootTag()
-   Type Definitions
    -   AppConfig
    -   Registry
    -   Runnable
    -   Runnables
    -   Task
    -   TaskCanceller
    -   TaskCancelProvider
    -   TaskProvider
AppRegistry

Project with Native Code Required

If you are using the managed Expo workflow there is only ever one entry
component registered with  AppRegistry and it is handled automatically
(or through registerRootComponent ). You do not need to use this API.

 AppRegistry is the JS entry point to running all React Native apps. App
root components should register themselves with
 AppRegistry.registerComponent , then the native system can load the
bundle for the app and then actually run the app when it's ready by
invoking  AppRegistry.runApplication .

    import {Text, AppRegistry} from 'react-native';

    const App = () => (
      <View>
        <Text>App1</Text>
      </View>
    );

    AppRegistry.registerComponent('Appname', () => App);

 

To "stop" an application when a view should be destroyed, call
 AppRegistry.unmountApplicationComponentAtRootTag with the tag that was
passed into  runApplication . These should always be used as a pair.

 AppRegistry should be required early in the  require sequence to make
sure the JS execution environment is setup before other modules are
required.

------------------------------------------------------------------------

Reference

Methods 

 getAppKeys() 

    static getAppKeys(): string;

 

Returns an array of strings.

------------------------------------------------------------------------

 getRegistry() 

    static getRegistry(): {sections: string; runnables: Runnable};

 

Returns a Registry object.

------------------------------------------------------------------------

 getRunnable() 

    static getRunnable(appKey: string): : Runnable | undefined;

 

Returns a Runnable object.

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| appKey                            | string                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 getSectionKeys() 

    static getSectionKeys(): string;

 

Returns an array of strings.

------------------------------------------------------------------------

 getSections() 

    static getSections(): Record<string, Runnable>;

 

Returns a Runnables object.

------------------------------------------------------------------------

 registerCancellableHeadlessTask() 

    static registerCancellableHeadlessTask(
      taskKey: string,
      taskProvider: TaskProvider,
      taskCancelProvider: TaskCancelProvider,
    );

 

Register a headless task which can be cancelled. A headless task is a
bit of code that runs without a UI.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| taskKey               | string                | The native id for     |
|                       |                       | this task instance    |
| Required              |                       | that was used when    |
|                       |                       | startHeadlessTask was |
|                       |                       | called.               |
+-----------------------+-----------------------+-----------------------+
| taskProvider          | TaskProvider          | A promise returning   |
|                       |                       | function that takes   |
| Required              |                       | some data passed from |
|                       |                       | the native side as    |
|                       |                       | the only argument.    |
|                       |                       | When the promise is   |
|                       |                       | resolved or rejected  |
|                       |                       | the native side is    |
|                       |                       | notified of this      |
|                       |                       | event and it may      |
|                       |                       | decide to destroy the |
|                       |                       | JS context.           |
+-----------------------+-----------------------+-----------------------+
| taskCancelProvider    | TaskCancelProvider    | a void returning      |
|                       |                       | function that takes   |
| Required              |                       | no arguments; when a  |
|                       |                       | cancellation is       |
|                       |                       | requested, the        |
|                       |                       | function being        |
|                       |                       | executed by           |
|                       |                       | taskProvider should   |
|                       |                       | wrap up and return    |
|                       |                       | ASAP.                 |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 registerComponent() 

    static registerComponent(
      appKey: string,
      getComponentFunc: ComponentProvider,
      section?: boolean,
    ): string;

 

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| appKey                            | string                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+
| componentProvider                 | ComponentProvider                 |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+
| section                           | boolean                           |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 registerConfig() 

    static registerConfig(config: AppConfig);

 

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| config                            | AppConfig                       |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 registerHeadlessTask() 

    static registerHeadlessTask(
      taskKey: string,
      taskProvider: TaskProvider,
    );

 

Register a headless task. A headless task is a bit of code that runs
without a UI.

This is a way to run tasks in JavaScript while your app is in the
background. It can be used, for example, to sync fresh data, handle push
notifications, or play music.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| taskKey               | string                | The native id for     |
|                       |                       | this task instance    |
| Required              |                       | that was used when    |
|                       |                       | startHeadlessTask was |
|                       |                       | called.               |
+-----------------------+-----------------------+-----------------------+
| taskProvider          | TaskProvider          | A promise returning   |
|                       |                       | function that takes   |
| Required              |                       | some data passed from |
|                       |                       | the native side as    |
|                       |                       | the only argument.    |
|                       |                       | When the promise is   |
|                       |                       | resolved or rejected  |
|                       |                       | the native side is    |
|                       |                       | notified of this      |
|                       |                       | event and it may      |
|                       |                       | decide to destroy the |
|                       |                       | JS context.           |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 registerRunnable() 

    static registerRunnable(appKey: string, func: Runnable): string;

 

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| appKey                            | string                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+
| run                               | function                          |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 registerSection() 

    static registerSection(
      appKey: string,
      component: ComponentProvider,
    );

 

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| appKey                            | string                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+
| component                         | ComponentProvider                 |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 runApplication() 

    static runApplication(appKey: string, appParameters: any): void;

 

Loads the JavaScript bundle and runs the app.

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| appKey                            | string                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+
| appParameters                     | any                               |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 setComponentProviderInstrumentationHook() 

    static setComponentProviderInstrumentationHook(
      hook: ComponentProviderInstrumentationHook,
    );

 

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| hook                              | function                          |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

A valid  hook function accepts the following as arguments:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| component                         | ComponentProvider                 |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+
| scopedPerformanceLogger           | IPerformanceLogger                |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

The function must also return a React Component.

------------------------------------------------------------------------

 setWrapperComponentProvider() 

    static setWrapperComponentProvider(
      provider: WrapperComponentProvider,
    );

 

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| provider                          | ComponentProvider                 |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 startHeadlessTask() 

    static startHeadlessTask(
      taskId: number,
      taskKey: string,
      data: any,
    );

 

Only called from native code. Starts a headless task.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| taskId                | number                | The native id for     |
|                       |                       | this task instance to |
| Required              |                       | keep track of its     |
|                       |                       | execution.            |
+-----------------------+-----------------------+-----------------------+
| taskKey               | string                | The key for the task  |
|                       |                       | to start.             |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+
| data                  | any                   | The data to pass to   |
|                       |                       | the task.             |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 unmountApplicationComponentAtRootTag() 

    static unmountApplicationComponentAtRootTag(rootTag: number);

 

Stops an application when a view should be destroyed.

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| rootTag                           | number                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

Type Definitions 

AppConfig 

Application configuration for the  registerConfig method.

  Type
  --------
  object

Properties:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| appKey                            | string                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+
| component                         | ComponentProvider                 |
+-----------------------------------+-----------------------------------+
| run                               | function                          |
+-----------------------------------+-----------------------------------+
| section                           | boolean                           |
+-----------------------------------+-----------------------------------+

  Note: Every config is expected to set either  component or  run
  function.

Registry 

  Type
  --------
  object

Properties:

  Name        Type
  ----------- --------------------
  runnables   array of Runnables
  sections    array of strings

Runnable 

  Type
  --------
  object

Properties:

  Name        Type
  ----------- -------------------
  component   ComponentProvider
  run         function

Runnables 

An object with key of  appKey and value of type of  Runnable .

  Type
  --------
  object

Task 

A  Task is a function that accepts any data as argument and returns a
Promise that resolves to  undefined .

  Type
  ----------
  function

TaskCanceller 

A  TaskCanceller is a function that accepts no argument and returns
void.

  Type
  ----------
  function

TaskCancelProvider 

A valid  TaskCancelProvider is a function that returns a  TaskCanceller
.

  Type
  ----------
  function

TaskProvider 

A valid  TaskProvider is a function that returns a  Task .

  Type
  ----------
  function

# AppState #
    _               ____  _        _       
   / \   _ __  _ __/ ___|| |_ __ _| |_ ___ 
  / _ \ | '_ \| '_ \___ \| __/ _` | __/ _ \
 / ___ \| |_) | |_) |__) | || (_| | ||  __/
/_/   \_\ .__/| .__/____/ \__\__,_|\__\___|
        |_|   |_|                          
-   App States
-   Basic Usage
-   Events
    -    change
    -    memoryWarning
    -    focus
        Android
    -    blur
        Android
-   Methods
    -    addEventListener()
-   Properties
    -    currentState
AppState

 AppState can tell you if the app is in the foreground or background,
and notify you when the state changes.

AppState is frequently used to determine the intent and proper behavior
when handling push notifications.

App States 

-    active - The app is running in the foreground
-    background - The app is running in the background. The user is
    either:
    -   in another app
    -   on the home screen
    -   [Android] on another  Activity (even if it was launched by your
        app)
-   [iOS]  inactive - This is a state that occurs when transitioning
    between foreground & background, and during periods of inactivity
    such as entering the multitasking view, opening the Notification
    Center or in the event of an incoming call.

For more information, see Apple's documentation

Basic Usage 

To see the current state, you can check  AppState.currentState , which
will be kept up-to-date. However,  currentState will be null at launch
while  AppState retrieves it over the bridge.

This example will only ever appear to say "Current state is: active"
because the app is only visible to the user when in the  active state,
and the null state will happen only momentarily. If you want to
experiment with the code we recommend to use your own device instead of
embedded preview.

------------------------------------------------------------------------

Reference

Events 

 change 

This event is received when the app state has changed. The listener is
called with one of the current app state values .

 memoryWarning 

This event is used in the need of throwing memory warning or releasing
it.

 focus

Android



Received when the app gains focus (the user is interacting with the
app).

 blur

Android



Received when the user is not actively interacting with the app. Useful
in situations when the user pulls down the notification drawer .
 AppState won't change but the  blur event will get fired.

Methods 

 addEventListener() 

    static addEventListener(
      type: AppStateEvent,
      listener: (state: AppStateStatus) => void,
    ): NativeEventSubscription;

 

Sets up a function that will be called whenever the specified event type
on AppState occurs. Valid values for  eventType are listed above .
Returns the  EventSubscription .

Properties 

 currentState 

    static currentState: AppStateStatus;

 

# BackHandler #
 ____             _    _   _                 _ _           
| __ )  __ _  ___| | _| | | | __ _ _ __   __| | | ___ _ __ 
|  _ \ / _` |/ __| |/ / |_| |/ _` | '_ \ / _` | |/ _ \ '__|
| |_) | (_| | (__|   <|  _  | (_| | | | | (_| | |  __/ |   
|____/ \__,_|\___|_|\_\_| |_|\__,_|_| |_|\__,_|_|\___|_|   
                                                           
-   Pattern
-   Example
-   Usage with React Navigation
-   Backhandler hook
-   Methods
    -    addEventListener()
    -    exitApp()
    -    removeEventListener()
BackHandler

The Backhandler API detects hardware button presses for back navigation,
lets you register event listeners for the system's back action, and lets
you control how your application responds. It is Android-only.

The event subscriptions are called in reverse order (i.e. the last
registered subscription is called first).

-   If one subscription returns true, then subscriptions registered
    earlier will not be called.
-   If no subscription returns true or none are registered, it
    programmatically invokes the default back button functionality to
    exit the app.

  Warning for modal users: If your app shows an opened  Modal ,
   BackHandler will not publish any events ( see  Modal docs ).

Pattern 

    BackHandler.addEventListener('hardwareBackPress', function () {
      /**
       * this.onMainScreen and this.goBack are just examples,
       * you need to use your own implementation here.
       *
       * Typically you would use the navigator here to go to the last state.
       */

      if (!this.onMainScreen()) {
        this.goBack();
        /**
         * When true is returned the event will not be bubbled up
         * & no other back action will execute
         */
        return true;
      }
      /**
       * Returning false will let the event to bubble up & let other event listeners
       * or the system's default back action to be executed.
       */
      return false;
    });

 

Example 

The following example implements a scenario where you confirm if the
user wants to exit the app:

 BackHandler.addEventListener creates an event listener & returns a
 NativeEventSubscription object which should be cleared using
 NativeEventSubscription.remove method.

Usage with React Navigation 

If you are using React Navigation to navigate across different screens,
you can follow their guide on Custom Android back button behaviour

Backhandler hook 

React Native Hooks has a nice  useBackHandler hook which will simplify
the process of setting up event listeners.

------------------------------------------------------------------------

Reference

Methods 

 addEventListener() 

    static addEventListener(
      eventName: BackPressEventName,
      handler: () => boolean | null | undefined,
    ): NativeEventSubscription;

 

------------------------------------------------------------------------

 exitApp() 

    static exitApp();

 

------------------------------------------------------------------------

 removeEventListener() 

    static removeEventListener(
      eventName: BackPressEventName,
      handler: () => boolean | null | undefined,
    );

 

# Building For TV Devices #
 ____        _ _     _ _               _____            _______     __
| __ ) _   _(_) | __| (_)_ __   __ _  |  ___|__  _ __  |_   _\ \   / /
|  _ \| | | | | |/ _` | | '_ \ / _` | | |_ / _ \| '__|   | |  \ \ / / 
| |_) | |_| | | | (_| | | | | | (_| | |  _| (_) | |      | |   \ V /  
|____/ \__,_|_|_|\__,_|_|_| |_|\__, | |_|  \___/|_|      |_|    \_/   
                               |___/                                  
 ____             _               
|  _ \  _____   _(_) ___ ___  ___ 
| | | |/ _ \ \ / / |/ __/ _ \/ __|
| |_| |  __/\ V /| | (_|  __/\__ \
|____/ \___| \_/ |_|\___\___||___/
                                  

Building For TV Devices

TV devices support has been implemented with the intention of making
existing React Native applications work on Apple TV and Android TV, with
few or no changes needed in the JavaScript code for the applications.

-   Android TV
-   🚧 tvOS

Build changes 

-   Native layer : To run React Native project on Android TV make sure
    to make the following changes to  AndroidManifest.xml

      <!-- Add custom banner image to display as Android TV launcher icon -->
     <application
      ...
      android:banner="@drawable/tv_banner"
      >
        ...
        <intent-filter>
          ...
          <!-- Needed to properly create a launch intent when running on Android TV -->
          <category android:name="android.intent.category.LEANBACK_LAUNCHER"/>
        </intent-filter>
        ...
      </application>

 

-   JavaScript layer : Support for Android TV has been added to
     Platform.android.js . You can check whether code is running on
    Android TV by doing

    const Platform = require('Platform');
    const running_on_android_tv = Platform.isTV;

 

Code changes 

-   Access to touchable controls : When running on Android TV the
    Android framework will automatically apply a directional navigation
    scheme based on relative position of focusable elements in your
    views. The  Touchable mixin has code added to detect focus changes
    and use existing methods to style the components properly and
    initiate the proper actions when the view is selected using the TV
    remote, so  TouchableWithoutFeedback ,  TouchableHighlight ,
     TouchableOpacity and  TouchableNativeFeedback will work as
    expected. In particular:

    -    onFocus will be executed when the touchable view goes into
        focus
    -    onBlur will be executed when the touchable view goes out of
        focus
    -    onPress will be executed when the touchable view is actually
        selected by pressing the "select" button on the TV remote.

-   TV remote/keyboard input : A new native class,
     ReactAndroidTVRootViewHelper , sets up key events handlers for TV
    remote events. When TV remote events occur, this class fires a JS
    event. This event will be picked up by instances of the
     TVEventHandler JavaScript object. Application code that needs to
    implement custom handling of TV remote events can create an instance
    of  TVEventHandler and listen for these events, as in the following
    code:

    const TVEventHandler = require('TVEventHandler');

    class Game2048 extends React.Component {
      _tvEventHandler: any;

      _enableTVEventHandler() {
        this._tvEventHandler = new TVEventHandler();
        this._tvEventHandler.enable(this, function (cmp, evt) {
          if (evt && evt.eventType === 'right') {
            cmp.setState({board: cmp.state.board.move(2)});
          } else if (evt && evt.eventType === 'up') {
            cmp.setState({board: cmp.state.board.move(1)});
          } else if (evt && evt.eventType === 'left') {
            cmp.setState({board: cmp.state.board.move(0)});
          } else if (evt && evt.eventType === 'down') {
            cmp.setState({board: cmp.state.board.move(3)});
          } else if (evt && evt.eventType === 'playPause') {
            cmp.restartGame();
          }
        });
      }

      _disableTVEventHandler() {
        if (this._tvEventHandler) {
          this._tvEventHandler.disable();
          delete this._tvEventHandler;
        }
      }

      componentDidMount() {
        this._enableTVEventHandler();
      }

      componentWillUnmount() {
        this._disableTVEventHandler();
      }
    }

 

-   Dev Menu support : On the emulator, cmd-M will bring up the Dev
    Menu, similar to Android. To bring it up on a real Android TV
    device, press the menu button or long press the fast-forward button
    on the remote. (Please do not shake the Android TV device, that will
    not work :) )

-   Known issues :

    -    TextInput components do not work for now (i.e. they cannot
        receive focus automatically, see this comment ).
        -   It is however possible to use a ref to manually trigger
             inputRef.current.focus() .
        -   You can wrap your input inside a  TouchableWithoutFeedback
            component and trigger focus in the  onFocus event of that
            touchable. This enables opening the keyboard via the arrow
            keys.
        -   The keyboard might reset its state after each keypress (this
            might only happen inside the Android TV emulator).
    -   The content of  Modal components cannot receive focus, see this
        issue for details.

  Deprecated. Use react-native-tvos instead. For the details please
  check the 0.62 release blog post .

Build changes 

-   Native layer : React Native Xcode projects all now have Apple TV
    build targets, with names ending in the string '-tvOS'.

-   react-native init : New React Native projects created with
     react-native init will have Apple TV target automatically created
    in their XCode projects.

-   JavaScript layer : Support for Apple TV has been added to
     Platform.ios.js . You can check whether code is running on AppleTV
    by doing

    const Platform = require('Platform');
    const running_on_tv = Platform.isTV;

    // If you want to be more specific and only detect devices running tvOS
    // (but no Android TV devices) you can use:
    const running_on_apple_tv = Platform.isTVOS;

 

Code changes 

-   General support for tvOS : Apple TV specific changes in native code
    are all wrapped by the TARGET_OS_TV define. These include changes to
    suppress APIs that are not supported on tvOS (e.g. web views,
    sliders, switches, status bar, etc.), and changes to support user
    input from the TV remote or keyboard.

-   Common codebase : Since tvOS and iOS share most Objective-C and
    JavaScript code in common, most documentation for iOS applies
    equally to tvOS.

-   Access to touchable controls : When running on Apple TV, the native
    view class is  RCTTVView , which has additional methods to make use
    of the tvOS focus engine. The  Touchable mixin has code added to
    detect focus changes and use existing methods to style the
    components properly and initiate the proper actions when the view is
    selected using the TV remote, so  TouchableWithoutFeedback ,
     TouchableHighlight and  TouchableOpacity will work as expected. In
    particular:

    -    onFocus will be executed when the touchable view goes into
        focus
    -    onBlur will be executed when the touchable view goes out of
        focus
    -    onPress will be executed when the touchable view is actually
        selected by pressing the "select" button on the TV remote.

-   TV remote/keyboard input : A new native class,  RCTTVRemoteHandler ,
    sets up gesture recognizers for TV remote events. When TV remote
    events occur, this class fires notifications that are picked up by
     RCTTVNavigationEventEmitter (a subclass of  RCTEventEmitter ), that
    fires a JS event. This event will be picked up by instances of the
     TVEventHandler JavaScript object. Application code that needs to
    implement custom handling of TV remote events can create an instance
    of  TVEventHandler and listen for these events, as in the following
    code:

    const TVEventHandler = require('TVEventHandler');

    class Game2048 extends React.Component {
      _tvEventHandler: any;

      _enableTVEventHandler() {
        this._tvEventHandler = new TVEventHandler();
        this._tvEventHandler.enable(this, function (cmp, evt) {
          if (evt && evt.eventType === 'right') {
            cmp.setState({board: cmp.state.board.move(2)});
          } else if (evt && evt.eventType === 'up') {
            cmp.setState({board: cmp.state.board.move(1)});
          } else if (evt && evt.eventType === 'left') {
            cmp.setState({board: cmp.state.board.move(0)});
          } else if (evt && evt.eventType === 'down') {
            cmp.setState({board: cmp.state.board.move(3)});
          } else if (evt && evt.eventType === 'playPause') {
            cmp.restartGame();
          }
        });
      }

      _disableTVEventHandler() {
        if (this._tvEventHandler) {
          this._tvEventHandler.disable();
          delete this._tvEventHandler;
        }
      }

      componentDidMount() {
        this._enableTVEventHandler();
      }

      componentWillUnmount() {
        this._disableTVEventHandler();
      }
    }

 

-   Dev Menu support : On the simulator, cmd-D will bring up the Dev
    Menu, similar to iOS. To bring it up on a real Apple TV device, make
    a long press on the play/pause button on the remote. (Please do not
    shake the Apple TV device, that will not work :) )

-   TV remote animations :  RCTTVView native code implements
    Apple-recommended parallax animations to help guide the eye as the
    user navigates through views. The animations can be disabled or
    adjusted with new optional view properties.

-   Back navigation with the TV remote menu button : The  BackHandler
    component, originally written to support the Android back button,
    now also supports back navigation on the Apple TV using the menu
    button on the TV remote.

-   TabBarIOS behavior : The  TabBarIOS component wraps the native
     UITabBar API, which works differently on Apple TV. To avoid jittery
    re-rendering of the tab bar in tvOS (see this issue ), the selected
    tab bar item can only be set from JavaScript on initial render, and
    is controlled after that by the user through native code.

-   Known issues :

    -   ListView scrolling . The issue can be worked around by setting
         removeClippedSubviews to false in ListView and similar
        components. For more discussion of this issue, see this PR .

# Button #
 ____        _   _              
| __ ) _   _| |_| |_ ___  _ __  
|  _ \| | | | __| __/ _ \| '_ \ 
| |_) | |_| | |_| || (_) | | | |
|____/ \__,_|\__|\__\___/|_| |_|
                                
-   Example
-   Props
    -   
        Required

         onPress
    -   
        Required

         title
    -    accessibilityLabel
    -    accessibilityLanguage
        iOS
    -    accessibilityActions
    -    onAccessibilityAction
    -    color
    -    disabled
    -    hasTVPreferredFocus
        TV
    -    nextFocusDown
        Android

        TV
    -    nextFocusForward
        Android

        TV
    -    nextFocusLeft
        Android

        TV
    -    nextFocusRight
        Android

        TV
    -    nextFocusUp
        Android

        TV
    -    testID
    -    touchSoundDisabled
        Android
Button

A basic button component that should render nicely on any platform.
Supports a minimal level of customization.

If this button doesn't look right for your app, you can build your own
button using Pressable . For inspiration, look at the source code for
the Button component .

    <Button
      onPress={onPressLearnMore}
      title="Learn More"
      color="#841584"
      accessibilityLabel="Learn more about this purple button"
    />

 

Example 

------------------------------------------------------------------------

Reference

Props 

Required

 onPress 

Handler to be called when the user taps the button.

  Type
  ---------------------------------
   ({nativeEvent:  PressEvent  })

------------------------------------------------------------------------

Required

 title 

Text to display inside the button. On Android the given title will be
converted to the uppercased form.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityLabel 

Text to display for blindness accessibility features.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityLanguage

iOS



A value indicating which language should be used by the screen reader
when the user interacts with the element. It should follow the BCP 47
specification .

See the iOS  accessibilityLanguage doc for more information.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityActions 

Accessibility actions allow an assistive technology to programmatically
invoke the actions of a component. The  accessibilityActions property
should contain a list of action objects. Each action object should
contain the field name and label.

See the Accessibility guide for more information.

  Type    Required
  ------- ----------
  array   No

------------------------------------------------------------------------

 onAccessibilityAction 

Invoked when the user performs the accessibility actions. The only
argument to this function is an event containing the name of the action
to perform.

See the Accessibility guide for more information.

  Type       Required
  ---------- ----------
  function   No

------------------------------------------------------------------------

 color 

Color of the text (iOS), or background color of the button (Android).

+-----------------------------------+-----------------------------------+
| Type                              | Default                           |
+===================================+===================================+
| color                             |  '#2196F3'                        |
|                                   |                                   |
|                                   | Android                           |
|                                   |                                   |
|                                   | -------------------------------   |
|                                   |                                   |
|                                   |  '#007AFF'                        |
|                                   |                                   |
|                                   | iOS                               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 disabled 

If  true , disable all interactions for this component.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 hasTVPreferredFocus

TV



TV preferred focus.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 nextFocusDown

Android

TV



Designates the next view to receive focus when the user navigates down.
See the Android documentation .

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusForward

Android

TV



Designates the next view to receive focus when the user navigates
forward. See the Android documentation .

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusLeft

Android

TV



Designates the next view to receive focus when the user navigates left.
See the Android documentation .

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusRight

Android

TV



Designates the next view to receive focus when the user navigates right.
See the Android documentation .

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusUp

Android

TV



Designates the next view to receive focus when the user navigates up.
See the Android documentation .

  Type
  --------
  number

------------------------------------------------------------------------

 testID 

Used to locate this view in end-to-end tests.

  Type
  --------
  string

------------------------------------------------------------------------

 touchSoundDisabled

Android



If  true , doesn't play system sound on touch.

  Type      Default
  --------- ---------
  boolean    false

# Color Reference #
  ____      _              ____       __                              
 / ___|___ | | ___  _ __  |  _ \ ___ / _| ___ _ __ ___ _ __   ___ ___ 
| |   / _ \| |/ _ \| '__| | |_) / _ \ |_ / _ \ '__/ _ \ '_ \ / __/ _ \
| |__| (_) | | (_) | |    |  _ <  __/  _|  __/ | |  __/ | | | (_|  __/
 \____\___/|_|\___/|_|    |_| \_\___|_|  \___|_|  \___|_| |_|\___\___|
                                                                      
-   Color APIs
-   Color representations
    -   Red Green Blue (RGB)
    -   Hue Saturation Lightness (HSL)
    -   Hue Whiteness Blackness (HWB)
    -   Color ints
    -   Named colors
Color Reference

Components in React Native are styled using JavaScript . Color
properties usually match how CSS works on the web . General guides on
the color usage on each platform could be found below:

-   Android
-   iOS

Color APIs 

React Native has several color APIs designed to allow you to take full
advantage of your platform's design and user preferences.

-   PlatformColor lets you reference the platform's color system.
-   DynamicColorIOS is iOS specific and allows you to specify which
    colors should be used in light or Dark Mode.

Color representations 

Red Green Blue (RGB) 

React Native supports  rgb() and  rgba() in both hexadecimal and
functional notation:

-    '#f0f' (#rgb)
-    '#ff00ff' (#rrggbb)
-    '#f0ff' (#rgba)
-    '#ff00ff00' (#rrggbbaa)
-    'rgb(255, 0, 255)'
-    'rgb(255 0 255)'
-    'rgba(255, 0, 255, 1.0)'
-    'rgba(255 0 255 / 1.0)'

Hue Saturation Lightness (HSL) 

React Native supports  hsl() and  hsla() in functional notation:

-    'hsl(360, 100%, 100%)'
-    'hsl(360 100% 100%)'
-    'hsla(360, 100%, 100%, 1.0)'
-    'hsla(360 100% 100% / 1.0)'

Hue Whiteness Blackness (HWB) 

React Native supports  hwb() in functional notation:

-    'hwb(0, 0%, 100%)'
-    'hwb(360, 100%, 100%)'
-    'hwb(0 0% 0%)'
-    'hwb(70 50% 0%)'

Color ints 

React Native supports also colors as an  int values (in RGB color mode):

-    0xff00ff00 (0xrrggbbaa)

 caution

This might appear similar to the Android Color ints representation but
on Android values are stored in SRGB color mode (0xaarrggbb).

Named colors 

In React Native you can also use color name strings as values.

 info

React Native only supports lowercase color names. Uppercase color names
are not supported.

 transparent 

This is a shortcut for  rgba(0,0,0,0) , same like in CSS3 .

Color keywords 

Named colors implementation follows the CSS3/SVG specification :

-    aliceblue (  #f0f8ff )
-    antiquewhite (  #faebd7 )
-    aqua (  #00ffff )
-    aquamarine (  #7fffd4 )
-    azure (  #f0ffff )
-    beige (  #f5f5dc )
-    bisque (  #ffe4c4 )
-    black (  #000000 )
-    blanchedalmond (  #ffebcd )
-    blue (  #0000ff )
-    blueviolet (  #8a2be2 )
-    brown (  #a52a2a )
-    burlywood (  #deb887 )
-    cadetblue (  #5f9ea0 )
-    chartreuse (  #7fff00 )
-    chocolate (  #d2691e )
-    coral (  #ff7f50 )
-    cornflowerblue (  #6495ed )
-    cornsilk (  #fff8dc )
-    crimson (  #dc143c )
-    cyan (  #00ffff )
-    darkblue (  #00008b )
-    darkcyan (  #008b8b )
-    darkgoldenrod (  #b8860b )
-    darkgray (  #a9a9a9 )
-    darkgreen (  #006400 )
-    darkgrey (  #a9a9a9 )
-    darkkhaki (  #bdb76b )
-    darkmagenta (  #8b008b )
-    darkolivegreen (  #556b2f )
-    darkorange (  #ff8c00 )
-    darkorchid (  #9932cc )
-    darkred (  #8b0000 )
-    darksalmon (  #e9967a )
-    darkseagreen (  #8fbc8f )
-    darkslateblue (  #483d8b )
-    darkslategrey (  #2f4f4f )
-    darkturquoise (  #00ced1 )
-    darkviolet (  #9400d3 )
-    deeppink (  #ff1493 )
-    deepskyblue (  #00bfff )
-    dimgray (  #696969 )
-    dimgrey (  #696969 )
-    dodgerblue (  #1e90ff )
-    firebrick (  #b22222 )
-    floralwhite (  #fffaf0 )
-    forestgreen (  #228b22 )
-    fuchsia (  #ff00ff )
-    gainsboro (  #dcdcdc )
-    ghostwhite (  #f8f8ff )
-    gold (  #ffd700 )
-    goldenrod (  #daa520 )
-    gray (  #808080 )
-    green (  #008000 )
-    greenyellow (  #adff2f )
-    grey (  #808080 )
-    honeydew (  #f0fff0 )
-    hotpink (  #ff69b4 )
-    indianred (  #cd5c5c )
-    indigo (  #4b0082 )
-    ivory (  #fffff0 )
-    khaki (  #f0e68c )
-    lavender (  #e6e6fa )
-    lavenderblush (  #fff0f5 )
-    lawngreen (  #7cfc00 )
-    lemonchiffon (  #fffacd )
-    lightblue (  #add8e6 )
-    lightcoral (  #f08080 )
-    lightcyan (  #e0ffff )
-    lightgoldenrodyellow (  #fafad2 )
-    lightgray (  #d3d3d3 )
-    lightgreen (  #90ee90 )
-    lightgrey (  #d3d3d3 )
-    lightpink (  #ffb6c1 )
-    lightsalmon (  #ffa07a )
-    lightseagreen (  #20b2aa )
-    lightskyblue (  #87cefa )
-    lightslategrey (  #778899 )
-    lightsteelblue (  #b0c4de )
-    lightyellow (  #ffffe0 )
-    lime (  #00ff00 )
-    limegreen (  #32cd32 )
-    linen (  #faf0e6 )
-    magenta (  #ff00ff )
-    maroon (  #800000 )
-    mediumaquamarine (  #66cdaa )
-    mediumblue (  #0000cd )
-    mediumorchid (  #ba55d3 )
-    mediumpurple (  #9370db )
-    mediumseagreen (  #3cb371 )
-    mediumslateblue (  #7b68ee )
-    mediumspringgreen (  #00fa9a )
-    mediumturquoise (  #48d1cc )
-    mediumvioletred (  #c71585 )
-    midnightblue (  #191970 )
-    mintcream (  #f5fffa )
-    mistyrose (  #ffe4e1 )
-    moccasin (  #ffe4b5 )
-    navajowhite (  #ffdead )
-    navy (  #000080 )
-    oldlace (  #fdf5e6 )
-    olive (  #808000 )
-    olivedrab (  #6b8e23 )
-    orange (  #ffa500 )
-    orangered (  #ff4500 )
-    orchid (  #da70d6 )
-    palegoldenrod (  #eee8aa )
-    palegreen (  #98fb98 )
-    paleturquoise (  #afeeee )
-    palevioletred (  #db7093 )
-    papayawhip (  #ffefd5 )
-    peachpuff (  #ffdab9 )
-    peru (  #cd853f )
-    pink (  #ffc0cb )
-    plum (  #dda0dd )
-    powderblue (  #b0e0e6 )
-    purple (  #800080 )
-    rebeccapurple (  #663399 )
-    red (  #ff0000 )
-    rosybrown (  #bc8f8f )
-    royalblue (  #4169e1 )
-    saddlebrown (  #8b4513 )
-    salmon (  #fa8072 )
-    sandybrown (  #f4a460 )
-    seagreen (  #2e8b57 )
-    seashell (  #fff5ee )
-    sienna (  #a0522d )
-    silver (  #c0c0c0 )
-    skyblue (  #87ceeb )
-    slateblue (  #6a5acd )
-    slategray (  #708090 )
-    snow (  #fffafa )
-    springgreen (  #00ff7f )
-    steelblue (  #4682b4 )
-    tan (  #d2b48c )
-    teal (  #008080 )
-    thistle (  #d8bfd8 )
-    tomato (  #ff6347 )
-    turquoise (  #40e0d0 )
-    violet (  #ee82ee )
-    wheat (  #f5deb3 )
-    white (  #ffffff )
-    whitesmoke (  #f5f5f5 )
-    yellow (  #ffff00 )
-    yellowgreen (  #9acd32 )

# Communication between native and React Native #
  ____                                      _           _   _             
 / ___|___  _ __ ___  _ __ ___  _   _ _ __ (_) ___ __ _| |_(_) ___  _ __  
| |   / _ \| '_ ` _ \| '_ ` _ \| | | | '_ \| |/ __/ _` | __| |/ _ \| '_ \ 
| |__| (_) | | | | | | | | | | | |_| | | | | | (_| (_| | |_| | (_) | | | |
 \____\___/|_| |_| |_|_| |_| |_|\__,_|_| |_|_|\___\__,_|\__|_|\___/|_| |_|
                                                                          
 _          _                                         _   _           
| |__   ___| |___      _____  ___ _ __    _ __   __ _| |_(_)_   _____ 
| '_ \ / _ \ __\ \ /\ / / _ \/ _ \ '_ \  | '_ \ / _` | __| \ \ / / _ \
| |_) |  __/ |_ \ V  V /  __/  __/ | | | | | | | (_| | |_| |\ V /  __/
|_.__/ \___|\__| \_/\_/ \___|\___|_| |_| |_| |_|\__,_|\__|_| \_/ \___|
                                                                      
                 _   ____                 _     _   _       _   _           
  __ _ _ __   __| | |  _ \ ___  __ _  ___| |_  | \ | | __ _| |_(_)_   _____ 
 / _` | '_ \ / _` | | |_) / _ \/ _` |/ __| __| |  \| |/ _` | __| \ \ / / _ \
| (_| | | | | (_| | |  _ <  __/ (_| | (__| |_  | |\  | (_| | |_| |\ V /  __/
 \__,_|_| |_|\__,_| |_| \_\___|\__,_|\___|\__| |_| \_|\__,_|\__|_| \_/ \___|
                                                                            
-   Introduction
-   Properties
    -   Passing properties from native to React Native
    -   Passing properties from React Native to native
    -   Limits of properties
-   Other ways of cross-language interaction (events and native modules)
    -   Calling React Native functions from native (events)
    -   Calling native functions from React Native (native modules)
-   Layout computation flow
    -   Layout of a native component embedded in React Native
    -   Layout of a React Native component embedded in native
Communication between native and React Native

In Integrating with Existing Apps guide and Native UI Components guide
we learn how to embed React Native in a native component and vice versa.
When we mix native and React Native components, we'll eventually find a
need to communicate between these two worlds. Some ways to achieve that
have been already mentioned in other guides. This article summarizes
available techniques.

Introduction 

React Native is inspired by React, so the basic idea of the information
flow is similar. The flow in React is one-directional. We maintain a
hierarchy of components, in which each component depends only on its
parent and its own internal state. We do this with properties: data is
passed from a parent to its children in a top-down manner. If an
ancestor component relies on the state of its descendant, one should
pass down a callback to be used by the descendant to update the
ancestor.

The same concept applies to React Native. As long as we are building our
application purely within the framework, we can drive our app with
properties and callbacks. But, when we mix React Native and native
components, we need some specific, cross-language mechanisms that would
allow us to pass information between them.

Properties 

Properties are the most straightforward way of cross-component
communication. So we need a way to pass properties both from native to
React Native, and from React Native to native.

Passing properties from native to React Native 

In order to embed a React Native view in a native component, we use
 RCTRootView .  RCTRootView is a  UIView that holds a React Native app.
It also provides an interface between native side and the hosted app.

 RCTRootView has an initializer that allows you to pass arbitrary
properties down to the React Native app. The  initialProperties
parameter has to be an instance of  NSDictionary . The dictionary is
internally converted into a JSON object that the top-level JS component
can reference.

    NSArray *imageList = @[@"https://dummyimage.com/600x400/ffffff/000000.png",
                           @"https://dummyimage.com/600x400/000000/ffffff.png"];

    NSDictionary *props = @{@"images" : imageList};

    RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge
                                                     moduleName:@"ImageBrowserApp"
                                              initialProperties:props];

 

    import React from 'react';
    import {View, Image} from 'react-native';

    export default class ImageBrowserApp extends React.Component {
      renderImage(imgURI) {
        return <Image source={{uri: imgURI}} />;
      }
      render() {
        return <View>{this.props.images.map(this.renderImage)}</View>;
      }
    }

 

 RCTRootView also provides a read-write property  appProperties . After
 appProperties is set, the React Native app is re-rendered with new
properties. The update is only performed when the new updated properties
differ from the previous ones.

    NSArray *imageList = @[@"https://dummyimage.com/600x400/ff0000/000000.png",
                           @"https://dummyimage.com/600x400/ffffff/ff0000.png"];

    rootView.appProperties = @{@"images" : imageList};

 

It is fine to update properties anytime. However, updates have to be
performed on the main thread. You use the getter on any thread.

 note

Currently, there is a known issue where setting appProperties during the
bridge startup, the change can be lost. See
https://github.com/facebook/react-native/issues/20115 for more
information.

There is no way to update only a few properties at a time. We suggest
that you build it into your own wrapper instead.

Passing properties from React Native to native 

The problem exposing properties of native components is covered in
detail in this article . In short, export properties with
 RCT_CUSTOM_VIEW_PROPERTY macro in your custom native component, then
use them in React Native as if the component was an ordinary React
Native component.

Limits of properties 

The main drawback of cross-language properties is that they do not
support callbacks, which would allow us to handle bottom-up data
bindings. Imagine you have a small RN view that you want to be removed
from the native parent view as a result of a JS action. There is no way
to do that with props, as the information would need to go bottom-up.

Although we have a flavor of cross-language callbacks ( described here
), these callbacks are not always the thing we need. The main problem is
that they are not intended to be passed as properties. Rather, this
mechanism allows us to trigger a native action from JS, and handle the
result of that action in JS.

Other ways of cross-language interaction (events and native modules) 

As stated in the previous chapter, using properties comes with some
limitations. Sometimes properties are not enough to drive the logic of
our app and we need a solution that gives more flexibility. This chapter
covers other communication techniques available in React Native. They
can be used for internal communication (between JS and native layers in
RN) as well as for external communication (between RN and the 'pure
native' part of your app).

React Native enables you to perform cross-language function calls. You
can execute custom native code from JS and vice versa. Unfortunately,
depending on the side we are working on, we achieve the same goal in
different ways. For native - we use events mechanism to schedule an
execution of a handler function in JS, while for React Native we
directly call methods exported by native modules.

Calling React Native functions from native (events) 

Events are described in detail in this article . Note that using events
gives us no guarantees about execution time, as the event is handled on
a separate thread.

Events are powerful, because they allow us to change React Native
components without needing a reference to them. However, there are some
pitfalls that you can fall into while using them:

-   As events can be sent from anywhere, they can introduce
    spaghetti-style dependencies into your project.
-   Events share namespace, which means that you may encounter some name
    collisions. Collisions will not be detected statically, which makes
    them hard to debug.
-   If you use several instances of the same React Native component and
    you want to distinguish them from the perspective of your event,
    you'll likely need to introduce identifiers and pass them along with
    events (you can use the native view's  reactTag as an identifier).

The common pattern we use when embedding native in React Native is to
make the native component's RCTViewManager a delegate for the views,
sending events back to JavaScript via the bridge. This keeps related
event calls in one place.

Calling native functions from React Native (native modules) 

Native modules are Objective-C classes that are available in JS.
Typically one instance of each module is created per JS bridge. They can
export arbitrary functions and constants to React Native. They have been
covered in detail in this article .

The fact that native modules are singletons limits the mechanism in the
context of embedding. Let's say we have a React Native component
embedded in a native view and we want to update the native, parent view.
Using the native module mechanism, we would export a function that not
only takes expected arguments, but also an identifier of the parent
native view. The identifier would be used to retrieve a reference to the
parent view to update. That said, we would need to keep a mapping from
identifiers to native views in the module.

Although this solution is complex, it is used in  RCTUIManager , which
is an internal React Native class that manages all React Native views.

Native modules can also be used to expose existing native libraries to
JS. The Geolocation library is a living example of the idea.

 caution

All native modules share the same namespace. Watch out for name
collisions when creating new ones.

Layout computation flow 

When integrating native and React Native, we also need a way to
consolidate two different layout systems. This section covers common
layout problems and provides a brief description of mechanisms to
address them.

Layout of a native component embedded in React Native 

This case is covered in this article . To summarize, since all our
native react views are subclasses of  UIView , most style and size
attributes will work like you would expect out of the box.

Layout of a React Native component embedded in native 

React Native content with fixed size 

The general scenario is when we have a React Native app with a fixed
size, which is known to the native side. In particular, a full-screen
React Native view falls into this case. If we want a smaller root view,
we can explicitly set RCTRootView's frame.

For instance, to make an RN app 200 (logical) pixels high, and the
hosting view's width wide, we could do:

SomeViewController.m

    - (void)viewDidLoad
    {
      [...]
      RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge
                                                       moduleName:appName
                                                initialProperties:props];
      rootView.frame = CGRectMake(0, 0, self.view.width, 200);
      [self.view addSubview:rootView];
    }

 

When we have a fixed size root view, we need to respect its bounds on
the JS side. In other words, we need to ensure that the React Native
content can be contained within the fixed-size root view. The easiest
way to ensure this is to use Flexbox layout. If you use absolute
positioning, and React components are visible outside the root view's
bounds, you'll get overlap with native views, causing some features to
behave unexpectedly. For instance, 'TouchableHighlight' will not
highlight your touches outside the root view's bounds.

It's totally fine to update root view's size dynamically by re-setting
its frame property. React Native will take care of the content's layout.

React Native content with flexible size 

In some cases we'd like to render content of initially unknown size.
Let's say the size will be defined dynamically in JS. We have two
solutions to this problem.

1.  You can wrap your React Native view in a  ScrollView component. This
    guarantees that your content will always be available and it won't
    overlap with native views.
2.  React Native allows you to determine, in JS, the size of the RN app
    and provide it to the owner of the hosting  RCTRootView . The owner
    is then responsible for re-laying out the subviews and keeping the
    UI consistent. We achieve this with  RCTRootView 's flexibility
    modes.

 RCTRootView supports 4 different size flexibility modes:

RCTRootView.h

    typedef NS_ENUM(NSInteger, RCTRootViewSizeFlexibility) {
      RCTRootViewSizeFlexibilityNone = 0,
      RCTRootViewSizeFlexibilityWidth,
      RCTRootViewSizeFlexibilityHeight,
      RCTRootViewSizeFlexibilityWidthAndHeight,
    };

 

 RCTRootViewSizeFlexibilityNone is the default value, which makes a root
view's size fixed (but it still can be updated with  setFrame: ). The
other three modes allow us to track React Native content's size updates.
For instance, setting mode to  RCTRootViewSizeFlexibilityHeight will
cause React Native to measure the content's height and pass that
information back to  RCTRootView 's delegate. An arbitrary action can be
performed within the delegate, including setting the root view's frame,
so the content fits. The delegate is called only when the size of the
content has changed.

 caution

Making a dimension flexible in both JS and native leads to undefined
behavior. For example - don't make a top-level React component's width
flexible (with  flexbox ) while you're using
 RCTRootViewSizeFlexibilityWidth on the hosting  RCTRootView .

Let's look at an example.

FlexibleSizeExampleView.m

    - (instancetype)initWithFrame:(CGRect)frame
    {
      [...]

      _rootView = [[RCTRootView alloc] initWithBridge:bridge
      moduleName:@"FlexibilityExampleApp"
      initialProperties:@{}];

      _rootView.delegate = self;
      _rootView.sizeFlexibility = RCTRootViewSizeFlexibilityHeight;
      _rootView.frame = CGRectMake(0, 0, self.frame.size.width, 0);
    }

    #pragma mark - RCTRootViewDelegate
    - (void)rootViewDidChangeIntrinsicSize:(RCTRootView *)rootView
    {
      CGRect newFrame = rootView.frame;
      newFrame.size = rootView.intrinsicContentSize;

      rootView.frame = newFrame;
    }

 

In the example we have a  FlexibleSizeExampleView view that holds a root
view. We create the root view, initialize it and set the delegate. The
delegate will handle size updates. Then, we set the root view's size
flexibility to  RCTRootViewSizeFlexibilityHeight , which means that
 rootViewDidChangeIntrinsicSize: method will be called every time the
React Native content changes its height. Finally, we set the root view's
width and position. Note that we set there height as well, but it has no
effect as we made the height RN-dependent.

You can checkout full source code of the example here .

It's fine to change root view's size flexibility mode dynamically.
Changing flexibility mode of a root view will schedule a layout
recalculation and the delegate  rootViewDidChangeIntrinsicSize: method
will be called once the content size is known.

 note

React Native layout calculation is performed on a separate thread, while
native UI view updates are done on the main thread. This may cause
temporary UI inconsistencies between native and React Native. This is a
known problem and our team is working on synchronizing UI updates coming
from different sources.

 note

React Native does not perform any layout calculations until the root
view becomes a subview of some other views. If you want to hide React
Native view until its dimensions are known, add the root view as a
subview and make it initially hidden (use  UIView 's  hidden property).
Then change its visibility in the delegate method.

# Core Components and APIs #
  ____               
 / ___|___  _ __ ___ 
| |   / _ \| '__/ _ \
| |__| (_) | | |  __/
 \____\___/|_|  \___|
                     
  ____                                             _                         _ 
 / ___|___  _ __ ___  _ __   ___  _ __   ___ _ __ | |_ ___    __ _ _ __   __| |
| |   / _ \| '_ ` _ \| '_ \ / _ \| '_ \ / _ \ '_ \| __/ __|  / _` | '_ \ / _` |
| |__| (_) | | | | | | |_) | (_) | | | |  __/ | | | |_\__ \ | (_| | | | | (_| |
 \____\___/|_| |_| |_| .__/ \___/|_| |_|\___|_| |_|\__|___/  \__,_|_| |_|\__,_|
                     |_|                                                       
    _    ____ ___     
   / \  |  _ \_ _|___ 
  / _ \ | |_) | |/ __|
 / ___ \|  __/| |\__ \
/_/   \_\_|  |___|___/
                      
-   Basic Components
-   User Interface
-   List Views
-   Android Components and APIs
-   iOS Components and APIs
-   Others
Core Components and APIs

React Native provides a number of built-in Core Components ready for you
to use in your app. You can find them all in the left sidebar (or menu
above, if you are on a narrow screen). If you're not sure where to get
started, take a look at the following categories:

-   Basic Components
-   User Interface
-   List Views
-   Android-specific
-   iOS-specific
-   Others

You're not limited to the components and APIs bundled with React Native.
React Native has a community of thousands of developers. If you're
looking for a library that does something specific, please refer to this
guide about finding libraries .

Basic Components 

Most apps will end up using one or more of these basic components.

View

The most fundamental component for building a UI.

Text

A component for displaying text.

Image

A component for displaying images.

TextInput

A component for inputting text into the app via a keyboard.

ScrollView

Provides a scrolling container that can host multiple components and
views.

StyleSheet

Provides an abstraction layer similar to CSS stylesheets.

User Interface 

These common user interface controls will render on any platform.

Button

A basic button component for handling touches that should render nicely
on any platform.

Switch

Renders a boolean input.

List Views 

Unlike the more generic  ScrollView , the following list view components
only render elements that are currently showing on the screen. This
makes them a performant choice for displaying long lists of data.

FlatList

A component for rendering performant scrollable lists.

SectionList

Like  FlatList , but for sectioned lists.

Android Components and APIs 

Many of the following components provide wrappers for commonly used
Android classes.

BackHandler

Detect hardware button presses for back navigation.

DrawerLayoutAndroid

Renders a  DrawerLayout on Android.

PermissionsAndroid

Provides access to the permissions model introduced in Android M.

ToastAndroid

Create an Android Toast alert.

iOS Components and APIs 

Many of the following components provide wrappers for commonly used
UIKit classes.

ActionSheetIOS

API to display an iOS action sheet or share sheet.

Others 

These components may be useful for certain applications. For an
exhaustive list of components and APIs, check out the sidebar to the
left (or menu above, if you are on a narrow screen).

ActivityIndicator

Displays a circular loading indicator.

Alert

Launches an alert dialog with the specified title and message.

Animated

A library for creating fluid, powerful animations that are easy to build
and maintain.

Dimensions

Provides an interface for getting device dimensions.

KeyboardAvoidingView

Provides a view that moves out of the way of the virtual keyboard
automatically.

Linking

Provides a general interface to interact with both incoming and outgoing
app links.

Modal

Provides a simple way to present content above an enclosing view.

PixelRatio

Provides access to the device pixel density.

RefreshControl

This component is used inside a  ScrollView to add pull to refresh
functionality.

StatusBar

Component to control the app status bar.

# Core Components and Native Components #
  ____               
 / ___|___  _ __ ___ 
| |   / _ \| '__/ _ \
| |__| (_) | | |  __/
 \____\___/|_|  \___|
                     
  ____                                             _                         _ 
 / ___|___  _ __ ___  _ __   ___  _ __   ___ _ __ | |_ ___    __ _ _ __   __| |
| |   / _ \| '_ ` _ \| '_ \ / _ \| '_ \ / _ \ '_ \| __/ __|  / _` | '_ \ / _` |
| |__| (_) | | | | | | |_) | (_) | | | |  __/ | | | |_\__ \ | (_| | | | | (_| |
 \____\___/|_| |_| |_| .__/ \___/|_| |_|\___|_| |_|\__|___/  \__,_|_| |_|\__,_|
                     |_|                                                       
 _   _       _   _           
| \ | | __ _| |_(_)_   _____ 
|  \| |/ _` | __| \ \ / / _ \
| |\  | (_| | |_| |\ V /  __/
|_| \_|\__,_|\__|_| \_/ \___|
                             
  ____                                             _       
 / ___|___  _ __ ___  _ __   ___  _ __   ___ _ __ | |_ ___ 
| |   / _ \| '_ ` _ \| '_ \ / _ \| '_ \ / _ \ '_ \| __/ __|
| |__| (_) | | | | | | |_) | (_) | | | |  __/ | | | |_\__ \
 \____\___/|_| |_| |_| .__/ \___/|_| |_|\___|_| |_|\__|___/
                     |_|                                   
-   Views and mobile development
-   Native Components
-   Core Components
Core Components and Native Components

React Native is an open source framework for building Android and iOS
applications using React and the app platform’s native capabilities.
With React Native, you use JavaScript to access your platform’s APIs as
well as to describe the appearance and behavior of your UI using React
components: bundles of reusable, nestable code. You can learn more about
React in the next section. But first, let’s cover how components work in
React Native.

Views and mobile development 

In Android and iOS development, a view is the basic building block of
UI: a small rectangular element on the screen which can be used to
display text, images, or respond to user input. Even the smallest visual
elements of an app, like a line of text or a button, are kinds of views.
Some kinds of views can contain other views. It’s views all the way
down!

[Just a sampling of the many views used in Android and iOS apps.]

Native Components 

In Android development, you write views in Kotlin or Java; in iOS
development, you use Swift or Objective-C. With React Native, you can
invoke these views with JavaScript using React components. At runtime,
React Native creates the corresponding Android and iOS views for those
components. Because React Native components are backed by the same views
as Android and iOS, React Native apps look, feel, and perform like any
other apps. We call these platform-backed components Native Components.

React Native comes with a set of essential, ready-to-use Native
Components you can use to start building your app today. These are React
Native's Core Components .

React Native also lets you build your own Native Components for Android
and iOS to suit your app’s unique needs. We also have a thriving
ecosystem of these community-contributed components. Check out Native
Directory to find what the community has been creating.

Core Components 

React Native has many Core Components for everything from controls to
activity indicators. You can find them all documented in the API section
. You will mostly work with the following Core Components:

  React Native UI Component   Android View    iOS View          Web Analog               Description
  --------------------------- --------------- ----------------- ------------------------ -------------------------------------------------------------------------------------------------------
   <View>                      <ViewGroup>     <UIView>         A non-scrolling  <div>   A container that supports layout with flexbox, style, some touch handling, and accessibility controls
   <Text>                      <TextView>      <UITextView>      <p>                     Displays, styles, and nests strings of text and even handles touch events
   <Image>                     <ImageView>     <UIImageView>     <img>                   Displays different types of images
   <ScrollView>                <ScrollView>    <UIScrollView>    <div>                   A generic scrolling container that can contain multiple components and views
   <TextInput>                 <EditText>      <UITextField>     <input type="text">     Allows the user to enter text

In the next section, you will start combining these Core Components to
learn about how React works. Have a play with them here now!

------------------------------------------------------------------------

Because React Native uses the same API structure as React components,
you’ll need to understand React component APIs to get started. The next
section makes for a quick introduction or refresher on the topic.
However, if you’re already familiar with React, feel free to skip ahead
.

[A diagram showing React Native's Core Components are a subset of React
Components that ship with React Native.] [A diagram showing React
Native's Core Components are a subset of React Components that ship with
React Native.]

# 🚧 DatePickerIOS #
  /\/\    __   ____        _       ____  _      _            ___ ___  ____  
  >  <  _/ _) |  _ \  __ _| |_ ___|  _ \(_) ___| | _____ _ _|_ _/ _ \/ ___| 
 _\/\ |/ \ \  | | | |/ _` | __/ _ \ |_) | |/ __| |/ / _ \ '__| | | | \___ \ 
/ __` |\ \\ \ | |_| | (_| | ||  __/  __/| | (__|   <  __/ |  | | |_| |___) |
\____/  \ \_/ |____/ \__,_|\__\___|_|   |_|\___|_|\_\___|_| |___\___/|____/ 
       (__/                                                                 
-   Example
-   Props
    -    date
    -    onChange
    -    onDateChange
    -    maximumDate
    -    minimumDate
    -    minuteInterval
    -    mode
    -    locale
    -    timeZoneOffsetInMinutes
    -    initialDate
🚧 DatePickerIOS

  Removed. Use one of the community packages instead.

Use  DatePickerIOS to render a date/time picker (selector) on iOS. This
is a controlled component, so you must hook in to the  onDateChange
callback and update the  date prop in order for the component to update,
otherwise the user's change will be reverted immediately to reflect
 props.date as the source of truth.

Example 

------------------------------------------------------------------------

Reference

Props 

Inherits View Props .

 date 

The currently selected date.

  Type   Required
  ------ ----------
  Date   Yes

------------------------------------------------------------------------

 onChange 

Date change handler.

This is called when the user changes the date or time in the UI. The
first and only argument is an Event. For getting the date the picker was
changed to, use onDateChange instead.

  Type       Required
  ---------- ----------
  function   No

------------------------------------------------------------------------

 onDateChange 

Date change handler.

This is called when the user changes the date or time in the UI. The
first and only argument is a Date object representing the new date and
time.

  Type       Required
  ---------- ----------
  function   Yes

------------------------------------------------------------------------

 maximumDate 

Maximum date.

Restricts the range of possible date/time values.

  Type   Required
  ------ ----------
  Date   No

Example with  maximumDate set to December 31, 2017:



------------------------------------------------------------------------

 minimumDate 

Minimum date.

Restricts the range of possible date/time values.

  Type   Required
  ------ ----------
  Date   No

See  maximumDate for an example image.

------------------------------------------------------------------------

 minuteInterval 

The interval at which minutes can be selected.

  Type                                         Required
  -------------------------------------------- ----------
  enum(1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30)   No

Example with  minuteInterval set to  10 :



------------------------------------------------------------------------

 mode 

The date picker mode.

  Type                                            Required
  ----------------------------------------------- ----------
  enum('date', 'time', 'datetime', 'countdown')   No

Example with  mode set to  date ,  time , and  datetime : 

------------------------------------------------------------------------

 locale 

The locale for the date picker. Value needs to be a Locale ID .

  Type     Required
  -------- ----------
  String   No

------------------------------------------------------------------------

 timeZoneOffsetInMinutes 

Timezone offset in minutes.

By default, the date picker will use the device's timezone. With this
parameter, it is possible to force a certain timezone offset. For
instance, to show times in Pacific Standard Time, pass -7 * 60.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 initialDate 

Provides an initial value that will change when the user starts
selecting a date. It is useful for use-cases where you do not want to
deal with listening to events and updating the date prop to keep the
controlled state in sync. The controlled state has known bugs which
causes it to go out of sync with native. The initialDate prop is
intended to allow you to have native be source of truth.

  Type   Required
  ------ ----------
  Date   No

# Debugging Basics #
 ____       _                       _               ____            _          
|  _ \  ___| |__  _   _  __ _  __ _(_)_ __   __ _  | __ )  __ _ ___(_) ___ ___ 
| | | |/ _ \ '_ \| | | |/ _` |/ _` | | '_ \ / _` | |  _ \ / _` / __| |/ __/ __|
| |_| |  __/ |_) | |_| | (_| | (_| | | | | | (_| | | |_) | (_| \__ \ | (__\__ \
|____/ \___|_.__/ \__,_|\__, |\__, |_|_| |_|\__, | |____/ \__,_|___/_|\___|___/
                        |___/ |___/         |___/                              
-   Accessing the Dev Menu
-   Opening the Debugger
-   React DevTools
-   LogBox
    -   Console Errors and Warnings
    -   Syntax Errors
-   Performance Monitor
Debugging Basics

Accessing the Dev Menu 

React Native provides an in-app developer menu which offers several
debugging options. You can access the Dev Menu by shaking your device or
via keyboard shortcuts:

-   iOS Simulator: Cmd ⌘  + D (or Device > Shake)
-   Android emulators: Cmd ⌘  + M (macOS) or Ctrl  + M (Windows and
    Linux)

Alternatively for Android devices and emulators, you can run
 adb shell input keyevent 82 in your terminal.

[The React Native Dev Menu]

 note

The Dev Menu is disabled in release (production) builds.

Opening the Debugger 

The debugger allows you to understand and debug how your JavaScript code
is running, similar to a web browser.

 info

In Expo projects , press j in the CLI to directly open the Hermes
Debugger.

-   Hermes Debugger / Expo
-   Flipper
-   New Debugger (Experimental)

Hermes supports the Chrome debugger by implementing the Chrome DevTools
Protocol. This means Chrome's tools can be used to directly debug
JavaScript running on Hermes, on an emulator or on a physical device.

1.  In a Chrome browser window, navigate to  chrome://inspect .
2.  Use the "Configure..." button to add the dev server address
    (typically  localhost:8081 ).
3.  You should now see a "Hermes React Native" target with an "inspect"
    link. Click this to open the debugger.

[Overview of Chrome&#39;s inspect interface and a connected Hermes
debugger window]

Flipper is a native debugging tool which provides JavaScript debugging
capabilities for React Native via an embedded Chrome DevTools panel.

To debug JavaScript code in Flipper, select "Open Debugger" from the Dev
Menu. Learn more about Flipper here .

 info

To debug using Flipper, the Flipper app must be installed on your system
.

[The Flipper desktop app opened to the Hermes debugger panel]

 warning

Debugging React Native apps with Flipper is deprecated in React Native
0.73 . We will eventually remove out-of-the box support for JS debugging
via Flipper.

 note

This is an experimental feature and several features may not work
reliably today. When this feature does launch in future, we intend for
it to work more completely than the current debugging methods.

The React Native team is working on a new JavaScript debugger
experience, intended to replace Flipper, with a preview available as of
React Native 0.73.

The new debugger can be enabled via React Native CLI. This will also
enable j to debug.

    npx react-native start --experimental-debugger

 

When selecting "Open Debugger" in the Dev Menu, this will launch the new
debugger using Google Chrome or Microsoft Edge.

[The new debugger frontend opened to the &quot;Welcome&quot; pane]

React DevTools 

You can use React DevTools to inspect the React element tree, props, and
state.

    npx react-devtools

 

[A React DevTools window]

 tip

Learn how to use React DevTools!

-   React DevTools guide
-   React Developer Tools on react.dev

LogBox 

Errors and warnings in development builds are displayed in LogBox inside
your app.

[A LogBox warning and an expanded LogBox syntax error]

 note

LogBox is disabled in release (production) builds.

Console Errors and Warnings 

Console errors and warnings are displayed as on-screen notifications
with a red or yellow badge, and a notification count. To see more about
an error or warning, tap the notification to see an expanded view and to
paginate through other logs.

LogBox notifications can be disabled using  LogBox.ignoreAllLogs() .
This can be useful when giving product demos, for example. Additionally,
notifications can be disabled on a per-log basis via
 LogBox.ignoreLogs() . This can be useful for noisy warnings or those
that cannot be fixed, e.g. in a third-party dependency.

 info

Ignore logs as a last resort and create a task to fix any logs that are
ignored.

    import {LogBox} from 'react-native';

    // Ignore log notification by message
    LogBox.ignoreLogs([
      // Exact message
      'Warning: componentWillReceiveProps has been renamed',

      // Substring or regex match
      /GraphQL error: .*/,
    ]);

    // Ignore all log notifications
    LogBox.ignoreAllLogs();

 

Syntax Errors 

When a JavaScript syntax error occurs, LogBox will open with the
location of the error. In this state, LogBox is not dismissable since
your code cannot be executed. LogBox will automatically dismiss once the
syntax error is fixed — either via Fast Refresh or after a manual
reload.

Performance Monitor 

On Android and iOS, an in-app performance overlay can be toggled during
development by selecting "Perf Monitor" in the Dev Menu. Learn more
about this feature here .

[The Performance Monitor overlay on iOS and Android]

 info

The Performance Monitor runs in-app and is a guide. We recommend
investigating the native tooling under Android Studio and Xcode for
accurate performance measurements.

# Debugging Release Builds #
 ____       _                       _             
|  _ \  ___| |__  _   _  __ _  __ _(_)_ __   __ _ 
| | | |/ _ \ '_ \| | | |/ _` |/ _` | | '_ \ / _` |
| |_| |  __/ |_) | |_| | (_| | (_| | | | | | (_| |
|____/ \___|_.__/ \__,_|\__, |\__, |_|_| |_|\__, |
                        |___/ |___/         |___/ 
 ____      _                       ____        _ _     _     
|  _ \ ___| | ___  __ _ ___  ___  | __ ) _   _(_) | __| |___ 
| |_) / _ \ |/ _ \/ _` / __|/ _ \ |  _ \| | | | | |/ _` / __|
|  _ <  __/ |  __/ (_| \__ \  __/ | |_) | |_| | | | (_| \__ \
|_| \_\___|_|\___|\__,_|___/\___| |____/ \__,_|_|_|\__,_|___/
                                                             
-   Symbolicating a stack trace
    -   Enabling source maps
    -   Using  metro-symbolicate
    -   Notes on source maps
Debugging Release Builds

Symbolicating a stack trace 

If a React Native app throws an unhandled exception in a release build,
the output may be obfuscated and hard to read.

    07-15 10:58:25.820 18979 18998 E AndroidRuntime: FATAL EXCEPTION: mqt_native_modules
    07-15 10:58:25.820 18979 18998 E AndroidRuntime: Process: com.awesomeproject, PID: 18979 07-15 10:58:25.820 18979 18998 E AndroidRuntime: com.facebook.react.common.JavascriptException: Failed, js engine: hermes, stack:
    07-15 10:58:25.820 18979 18998 E AndroidRuntime: p@1:132161
    07-15 10:58:25.820 18979 18998 E AndroidRuntime: p@1:132084
    07-15 10:58:25.820 18979 18998 E AndroidRuntime: f@1:131854
    07-15 10:58:25.820 18979 18998 E AndroidRuntime: anonymous@1:131119

 

In the above stack trace, entries like  p@1:132161 are minified function
names and bytecode offsets. To debug these calls, we want to translate
these into file, line, and function name, e.g.
 AwesomeProject/App.js:54:initializeMap . This is known as
symbolication.

You can symbolicate minified function names and bytecode like the above
by passing the stack trace and a generated source map to
 metro-symbolicate .

Enabling source maps 

Source maps are required to symbolicate stack traces. Make sure that
source maps are enabled within the build config for the target platform.

-   Android
-   iOS

 info

On Android, source maps are enabled by default.

To enable source map generation, ensure the following  hermesFlags are
present in  android/app/build.gradle .

    react {
        hermesFlags = ["-O", "-output-source-map"]
    }

 

If done correctly you should see the output location of the source map
during Metro build output.

    Writing bundle output to:, android/app/build/generated/assets/react/release/index.android.bundle
    Writing sourcemap output to:, android/app/build/intermediates/sourcemaps/react/release/index.android.bundle.packager.map

 

 info

On iOS, source maps are disabled by default. Use the following
instructions to enable them.

To enable source map generation:

-   Open Xcode and edit the build phase "Bundle React Native code and
    images".
-   Above the other exports, add a  SOURCEMAP_FILE entry with the
    desired output path.

    + SOURCEMAP_FILE="$(pwd)/../main.jsbundle.map";
      WITH_ENVIRONMENT="../node_modules/react-native/scripts/xcode/with-environment.sh"

 

If done correctly you should see the output location of the source map
during Metro build output.

    Writing bundle output to:, Build/Intermediates.noindex/ArchiveIntermediates/application/BuildProductsPath/Release-iphoneos/main.jsbundle
    Writing sourcemap output to:, Build/Intermediates.noindex/ArchiveIntermediates/application/BuildProductsPath/Release-iphoneos/main.jsbundle.map

 

Using  metro-symbolicate 

With source maps being generated, we can now translate our stack traces.

    # Print usage instructions
    npx metro-symbolicate

    # From a file containing the stack trace
    npx metro-symbolicate android/app/build/generated/sourcemaps/react/release/index.android.bundle.map < stacktrace.txt

    # From adb logcat (Android)
    adb logcat -d | npx metro-symbolicate android/app/build/generated/sourcemaps/react/release/index.android.bundle.map

 

Notes on source maps 

-   Multiple source maps may be generated by the build process. Make
    sure to use the one in the location shown in the examples.
-   Make sure that the source map you use corresponds to the exact
    commit of the crashing app. Small changes in source code can cause
    large differences in offsets.
-   If  metro-symbolicate exits immediately with success, make sure the
    input comes from a pipe or redirection and not from a terminal.

# DevSettings #
 ____              ____       _   _   _                 
|  _ \  _____   __/ ___|  ___| |_| |_(_)_ __   __ _ ___ 
| | | |/ _ \ \ / /\___ \ / _ \ __| __| | '_ \ / _` / __|
| |_| |  __/\ V /  ___) |  __/ |_| |_| | | | | (_| \__ \
|____/ \___| \_/  |____/ \___|\__|\__|_|_| |_|\__, |___/
                                              |___/     
-   Methods
    -    addMenuItem()
    -    reload()
DevSettings

The  DevSettings module exposes methods for customizing settings for
developers in development.

------------------------------------------------------------------------

Reference

Methods 

 addMenuItem() 

    static addMenuItem(title: string, handler: () => any);

 

Add a custom menu item to the Dev Menu.

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| title                             | string                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+
| handler                           | function                          |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

Example:

    DevSettings.addMenuItem('Show Secret Dev Screen', () => {
      Alert.alert('Showing secret dev screen!');
    });

 

------------------------------------------------------------------------

 reload() 

    static reload(reason?: string): void;

 

Reload the application. Can be invoked directly or on user interaction.

Example:

    <Button title="Reload" onPress={() => DevSettings.reload()} />

 

# Dimensions #
 ____  _                          _                 
|  _ \(_)_ __ ___   ___ _ __  ___(_) ___  _ __  ___ 
| | | | | '_ ` _ \ / _ \ '_ \/ __| |/ _ \| '_ \/ __|
| |_| | | | | | | |  __/ | | \__ \ | (_) | | | \__ \
|____/|_|_| |_| |_|\___|_| |_|___/_|\___/|_| |_|___/
                                                    
-   Example
-   Methods
    -    addEventListener()
    -    get()
-   Type Definitions
    -   DimensionsValue
    -   ScaledSize
Dimensions

   useWindowDimensions is the preferred API for React components. Unlike
   Dimensions , it updates as the window's dimensions update. This works
  nicely with the React paradigm.

    import {Dimensions} from 'react-native';

 

You can get the application window's width and height using the
following code:

    const windowWidth = Dimensions.get('window').width;
    const windowHeight = Dimensions.get('window').height;

 

  Although dimensions are available immediately, they may change (e.g
  due to device rotation, foldable devices etc) so any rendering logic
  or styles that depend on these constants should try to call this
  function on every render, rather than caching the value (for example,
  using inline styles rather than setting a value in a  StyleSheet ).

If you are targeting foldable devices or devices which can change the
screen size or app window size, you can use the event listener available
in the Dimensions module as shown in the below example.

Example 

Reference

Methods 

 addEventListener() 

    static addEventListener(
      type: 'change',
      handler: ({
        window,
        screen,
      }: DimensionsValue) => void,
    ): EmitterSubscription;

 

Add an event handler. Supported events:

-    change : Fires when a property within the  Dimensions object
    changes. The argument to the event handler is a  DimensionsValue
    type object.

------------------------------------------------------------------------

 get() 

    static get(dim: 'window' | 'screen'): ScaledSize;

 

Initial dimensions are set before  runApplication is called so they
should be available before any other require's are run, but may be
updated later.

Example:  const {height, width} = Dimensions.get('window');

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| dim                   | string                | Name of dimension as  |
|                       |                       | defined when calling  |
| Required              |                       |  set . Returns value  |
|                       |                       | for the dimension.    |
+-----------------------+-----------------------+-----------------------+

  For Android the  window dimension will exclude the size used by the
   status bar (if not translucent) and  bottom navigation bar

------------------------------------------------------------------------

Type Definitions 

DimensionsValue 

Properties:

  Name     Type         Description
  -------- ------------ -----------------------------------------
  window   ScaledSize   Size of the visible Application window.
  screen   ScaledSize   Size of the device's screen.

ScaledSize 

  Type
  --------
  object

Properties:

  Name        Type
  ----------- --------
  width       number
  height      number
  scale       number
  fontScale   number

# Direct Manipulation #
 ____  _               _   
|  _ \(_)_ __ ___  ___| |_ 
| | | | | '__/ _ \/ __| __|
| |_| | | | |  __/ (__| |_ 
|____/|_|_|  \___|\___|\__|
                           
 __  __             _             _       _   _             
|  \/  | __ _ _ __ (_)_ __  _   _| | __ _| |_(_) ___  _ __  
| |\/| |/ _` | '_ \| | '_ \| | | | |/ _` | __| |/ _ \| '_ \ 
| |  | | (_| | | | | | |_) | |_| | | (_| | |_| | (_) | | | |
|_|  |_|\__,_|_| |_|_| .__/ \__,_|_|\__,_|\__|_|\___/|_| |_|
                     |_|                                    
-   setNativeProps with TouchableOpacity
-   Composite components and setNativeProps
-   setNativeProps to edit TextInput value
-   Avoiding conflicts with the render function
-   setNativeProps & shouldComponentUpdate
-   Other native methods
    -   measure(callback)
    -   measureInWindow(callback)
    -   measureLayout(relativeToNativeComponentRef, onSuccess, onFail)
    -   focus()
    -   blur()
Direct Manipulation

It is sometimes necessary to make changes directly to a component
without using state/props to trigger a re-render of the entire subtree.
When using React in the browser for example, you sometimes need to
directly modify a DOM node, and the same is true for views in mobile
apps.  setNativeProps is the React Native equivalent to setting
properties directly on a DOM node.

 caution

Use  setNativeProps when frequent re-rendering creates a performance
bottleneck!

Direct manipulation will not be a tool that you reach for frequently.
You will typically only be using it for creating continuous animations
to avoid the overhead of rendering the component hierarchy and
reconciling many views.  setNativeProps is imperative and stores state
in the native layer (DOM, UIView, etc.) and not within your React
components, which makes your code more difficult to reason about.

Before you use it, try to solve your problem with  setState and
 shouldComponentUpdate .

setNativeProps with TouchableOpacity 

TouchableOpacity uses  setNativeProps internally to update the opacity
of its child component:

    const viewRef = useRef<View>();
    const setOpacityTo = useCallback(value => {
      // Redacted: animation related code
      viewRef.current.setNativeProps({
        opacity: value,
      });
    }, );

 

This allows us to write the following code and know that the child will
have its opacity updated in response to taps, without the child having
any knowledge of that fact or requiring any changes to its
implementation:

    <TouchableOpacity onPress={handlePress}>
      <View>
        <Text>Press me!</Text>
      </View>
    </TouchableOpacity>

 

Let's imagine that  setNativeProps was not available. One way that we
might implement it with that constraint is to store the opacity value in
the state, then update that value whenever  onPress is fired:

    const [buttonOpacity, setButtonOpacity] = useState(1);
    return (
      <TouchableOpacity
        onPressIn={() => setButtonOpacity(0.5)}
        onPressOut={() => setButtonOpacity(1)}>
        <View style={{opacity: buttonOpacity}}>
          <Text>Press me!</Text>
        </View>
      </TouchableOpacity>
    );

 

This is computationally intensive compared to the original example -
React needs to re-render the component hierarchy each time the opacity
changes, even though other properties of the view and its children
haven't changed. Usually this overhead isn't a concern but when
performing continuous animations and responding to gestures, judiciously
optimizing your components can improve your animations' fidelity.

If you look at the implementation of  setNativeProps in
NativeMethodsMixin you will notice that it is a wrapper around
 RCTUIManager.updateView - this is the exact same function call that
results from re-rendering - see receiveComponent in
ReactNativeBaseComponent .

Composite components and setNativeProps 

Composite components are not backed by a native view, so you cannot call
 setNativeProps on them. Consider this example:

-   TypeScript
-   JavaScript

If you run this you will immediately see this error:
 Touchable child must either be native or forward setNativeProps to a native component
. This occurs because  MyButton isn't directly backed by a native view
whose opacity should be set. You can think about it like this: if you
define a component with  createReactClass you would not expect to be
able to set a style prop on it and have that work - you would need to
pass the style prop down to a child, unless you are wrapping a native
component. Similarly, we are going to forward  setNativeProps to a
native-backed child component.

Forward setNativeProps to a child 

Since the  setNativeProps method exists on any ref to a  View component,
it is enough to forward a ref on your custom component to one of the
 <View /> components that it renders. This means that a call to
 setNativeProps on the custom component will have the same effect as if
you called  setNativeProps on the wrapped  View component itself.

-   TypeScript
-   JavaScript

You can now use  MyButton inside of  TouchableOpacity !

You may have noticed that we passed all of the props down to the child
view using  {...props} . The reason for this is that  TouchableOpacity
is actually a composite component, and so in addition to depending on
 setNativeProps on its child, it also requires that the child perform
touch handling. To do this, it passes on various props that call back to
the  TouchableOpacity component.  TouchableHighlight , in contrast, is
backed by a native view and only requires that we implement
 setNativeProps .

setNativeProps to edit TextInput value 

Another very common use case of  setNativeProps is to edit the value of
the TextInput. The  controlled prop of TextInput can sometimes drop
characters when the  bufferDelay is low and the user types very quickly.
Some developers prefer to skip this prop entirely and instead use
 setNativeProps to directly manipulate the TextInput value when
necessary. For example, the following code demonstrates editing the
input when you tap a button:

-   TypeScript
-   JavaScript

You can use the  clear method to clear the  TextInput which clears the
current input text using the same approach.

Avoiding conflicts with the render function 

If you update a property that is also managed by the render function,
you might end up with some unpredictable and confusing bugs because
anytime the component re-renders and that property changes, whatever
value was previously set from  setNativeProps will be completely ignored
and overridden.

setNativeProps & shouldComponentUpdate 

By intelligently applying  shouldComponentUpdate you can avoid the
unnecessary overhead involved in reconciling unchanged component
subtrees, to the point where it may be performant enough to use
 setState instead of  setNativeProps .

Other native methods 

The methods described here are available on most of the default
components provided by React Native. Note, however, that they are not
available on composite components that aren't directly backed by a
native view. This will generally include most components that you define
in your own app.

measure(callback) 

Determines the location on screen, width, and height in the viewport of
the given view and returns the values via an async callback. If
successful, the callback will be called with the following arguments:

-   x
-   y
-   width
-   height
-   pageX
-   pageY

Note that these measurements are not available until after the rendering
has been completed in native. If you need the measurements as soon as
possible and you don't need  pageX and  pageY , consider using the
 onLayout property instead.

Also the width and height returned by  measure() are the width and
height of the component in the viewport. If you need the actual size of
the component, consider using the  onLayout property instead.

measureInWindow(callback) 

Determines the location of the given view in the window and returns the
values via an async callback. If the React root view is embedded in
another native view, this will give you the absolute coordinates. If
successful, the callback will be called with the following arguments:

-   x
-   y
-   width
-   height

measureLayout(relativeToNativeComponentRef, onSuccess, onFail) 

Like  measure() , but measures the view relative to an ancestor,
specified with  relativeToNativeComponentRef reference. This means that
the returned coordinates are relative to the origin  x ,  y of the
ancestor view.

 note

This method can also be called with a  relativeToNativeNode handler
(instead of reference), but this variant is deprecated.

-   TypeScript
-   JavaScript

focus() 

Requests focus for the given input or view. The exact behavior triggered
will depend on the platform and type of view.

blur() 

Removes focus from an input or view. This is the opposite of  focus() .

# DrawerLayoutAndroid #
 ____                              _                            _      _    
|  _ \ _ __ __ ___      _____ _ __| |    __ _ _   _  ___  _   _| |_   / \   
| | | | '__/ _` \ \ /\ / / _ \ '__| |   / _` | | | |/ _ \| | | | __| / _ \  
| |_| | | | (_| |\ V  V /  __/ |  | |__| (_| | |_| | (_) | |_| | |_ / ___ \ 
|____/|_|  \__,_| \_/\_/ \___|_|  |_____\__,_|\__, |\___/ \__,_|\__/_/   \_\
                                              |___/                         
           _           _     _ 
 _ __   __| |_ __ ___ (_) __| |
| '_ \ / _` | '__/ _ \| |/ _` |
| | | | (_| | | | (_) | | (_| |
|_| |_|\__,_|_|  \___/|_|\__,_|
                               
-   Example
-   Props
    -   View Props
    -    drawerBackgroundColor
    -    drawerLockMode
    -    drawerPosition
    -    drawerWidth
    -    keyboardDismissMode
    -    onDrawerClose
    -    onDrawerOpen
    -    onDrawerSlide
    -    onDrawerStateChanged
    -    renderNavigationView
    -    statusBarBackgroundColor
-   Methods
    -    closeDrawer()
    -    openDrawer()
DrawerLayoutAndroid

React component that wraps the platform  DrawerLayout (Android only).
The Drawer (typically used for navigation) is rendered with
 renderNavigationView and direct children are the main view (where your
content goes). The navigation view is initially not visible on the
screen, but can be pulled in from the side of the window specified by
the  drawerPosition prop and its width can be set by the  drawerWidth
prop.

Example 

-   TypeScript
-   JavaScript

------------------------------------------------------------------------

Reference

Props 

View Props 

Inherits View Props .

------------------------------------------------------------------------

 drawerBackgroundColor 

Specifies the background color of the drawer. The default value is
 white . If you want to set the opacity of the drawer, use rgba.
Example:

    return (
      <DrawerLayoutAndroid drawerBackgroundColor="rgba(0,0,0,0.5)" />
    );

 

  Type    Required
  ------- ----------
  color   No

------------------------------------------------------------------------

 drawerLockMode 

Specifies the lock mode of the drawer. The drawer can be locked in 3
states:

-   unlocked (default), meaning that the drawer will respond
    (open/close) to touch gestures.
-   locked-closed, meaning that the drawer will stay closed and not
    respond to gestures.
-   locked-open, meaning that the drawer will stay opened and not
    respond to gestures. The drawer may still be opened and closed
    programmatically (  openDrawer /  closeDrawer ).

  Type                                               Required
  -------------------------------------------------- ----------
  enum('unlocked', 'locked-closed', 'locked-open')   No

------------------------------------------------------------------------

 drawerPosition 

Specifies the side of the screen from which the drawer will slide in. By
default it is set to  left .

  Type                    Required
  ----------------------- ----------
  enum('left', 'right')   No

------------------------------------------------------------------------

 drawerWidth 

Specifies the width of the drawer, more precisely the width of the view
that be pulled in from the edge of the window.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 keyboardDismissMode 

Determines whether the keyboard gets dismissed in response to a drag.

-   'none' (the default), drags do not dismiss the keyboard.
-   'on-drag', the keyboard is dismissed when a drag begins.

  Type                      Required
  ------------------------- ----------
  enum('none', 'on-drag')   No

------------------------------------------------------------------------

 onDrawerClose 

Function called whenever the navigation view has been closed.

  Type       Required
  ---------- ----------
  function   No

------------------------------------------------------------------------

 onDrawerOpen 

Function called whenever the navigation view has been opened.

  Type       Required
  ---------- ----------
  function   No

------------------------------------------------------------------------

 onDrawerSlide 

Function called whenever there is an interaction with the navigation
view.

  Type       Required
  ---------- ----------
  function   No

------------------------------------------------------------------------

 onDrawerStateChanged 

Function called when the drawer state has changed. The drawer can be in
3 states:

-   idle, meaning there is no interaction with the navigation view
    happening at the time
-   dragging, meaning there is currently an interaction with the
    navigation view
-   settling, meaning that there was an interaction with the navigation
    view, and the navigation view is now finishing its closing or
    opening animation

  Type       Required
  ---------- ----------
  function   No

------------------------------------------------------------------------

 renderNavigationView 

The navigation view that will be rendered to the side of the screen and
can be pulled in.

  Type       Required
  ---------- ----------
  function   Yes

------------------------------------------------------------------------

 statusBarBackgroundColor 

Make the drawer take the entire screen and draw the background of the
status bar to allow it to open over the status bar. It will only have an
effect on API 21+.

  Type    Required
  ------- ----------
  color   No

Methods 

 closeDrawer() 

    closeDrawer();

 

Closes the drawer.

------------------------------------------------------------------------

 openDrawer() 

    openDrawer();

 

Opens the drawer.

# DynamicColorIOS #
 ____                              _       ____      _           ___ ___  
|  _ \ _   _ _ __   __ _ _ __ ___ (_) ___ / ___|___ | | ___  _ _|_ _/ _ \ 
| | | | | | | '_ \ / _` | '_ ` _ \| |/ __| |   / _ \| |/ _ \| '__| | | | |
| |_| | |_| | | | | (_| | | | | | | | (__| |__| (_) | | (_) | |  | | |_| |
|____/ \__, |_| |_|\__,_|_| |_| |_|_|\___|\____\___/|_|\___/|_| |___\___/ 
       |___/                                                              
 ____  
/ ___| 
\___ \ 
 ___) |
|____/ 
       
-   Example
DynamicColorIOS

The  DynamicColorIOS function is a platform color type specific to iOS.

    DynamicColorIOS({
      light: color,
      dark: color,
      highContrastLight: color, // (optional) will fallback to "light" if not provided
      highContrastDark: color, // (optional) will fallback to "dark" if not provided
    });

 

 DynamicColorIOS takes a single argument as an object with two mandatory
keys:  dark and  light , and two optional keys  highContrastLight and
 highContrastDark . These correspond to the colors you want to use for
"light mode" and "dark mode" on iOS, and when high contrast
accessibility mode is enabled, high contrast version of them.

At runtime, the system will choose which of the colors to display
depending on the current system appearance and accessibility settings.
Dynamic colors are useful for branding colors or other app specific
colors that still respond automatically to system setting changes.

Developer notes 

-   iOS
-   Web

  If you’re familiar with  @media (prefers-color-scheme: dark) in CSS,
  this is similar! Only instead of defining all the colors in a media
  query, you define which color to use under what circumstances right
  there where you're using it. Neat!

  The  DynamicColorIOS function is similar to the iOS native methods
   UIColor colorWithDynamicProvider:

Example 

    import {DynamicColorIOS} from 'react-native';

    const customDynamicTextColor = DynamicColorIOS({
      dark: 'lightskyblue',
      light: 'midnightblue',
    });

    const customContrastDynamicTextColor = DynamicColorIOS({
      dark: 'darkgray',
      light: 'lightgray',
      highContrastDark: 'black',
      highContrastLight: 'white',
    });

 

# Easing #
 _____          _             
| ____|__ _ ___(_)_ __   __ _ 
|  _| / _` / __| | '_ \ / _` |
| |__| (_| \__ \ | | | | (_| |
|_____\__,_|___/_|_| |_|\__, |
                        |___/ 
-   Predefined animations
-   Standard functions
-   Additional functions
-   Example
-   Methods
    -    step0()
    -    step1()
    -    linear()
    -    ease()
    -    quad()
    -    cubic()
    -    poly()
    -    sin()
    -    circle()
    -    exp()
    -    elastic()
    -    back()
    -    bounce()
    -    bezier()
    -    in()
    -    out()
    -    inOut()
Easing

The  Easing module implements common easing functions. This module is
used by  Animated.timing() to convey physically believable motion in
animations.

You can find a visualization of some common easing functions at
https://easings.net/

Predefined animations 

The  Easing module provides several predefined animations through the
following methods:

-    back provides a basic animation where the object goes slightly back
    before moving forward
-    bounce provides a bouncing animation
-    ease provides a basic inertial animation
-    elastic provides a basic spring interaction

Standard functions 

Three standard easing functions are provided:

-    linear
-    quad
-    cubic

The  poly function can be used to implement quartic, quintic, and other
higher power functions.

Additional functions 

Additional mathematical functions are provided by the following methods:

-    bezier provides a cubic bezier curve
-    circle provides a circular function
-    sin provides a sinusoidal function
-    exp provides an exponential function

The following helpers are used to modify other easing functions.

-    in runs an easing function forwards
-    inOut makes any easing function symmetrical
-    out runs an easing function backwards

Example 

-   TypeScript
-   JavaScript

------------------------------------------------------------------------

Reference

Methods 

 step0() 

    static step0(n: number);

 

A stepping function, returns 1 for any positive value of  n .

------------------------------------------------------------------------

 step1() 

    static step1(n: number);

 

A stepping function, returns 1 if  n is greater than or equal to 1.

------------------------------------------------------------------------

 linear() 

    static linear(t: number);

 

A linear function,  f(t) = t . Position correlates to elapsed time one
to one.

https://cubic-bezier.com/#0,0,1,1

------------------------------------------------------------------------

 ease() 

    static ease(t: number);

 

A basic inertial interaction, similar to an object slowly accelerating
to speed.

https://cubic-bezier.com/#.42,0,1,1

------------------------------------------------------------------------

 quad() 

    static quad(t: number);

 

A quadratic function,  f(t) = t * t . Position equals the square of
elapsed time.

https://easings.net/#easeInQuad

------------------------------------------------------------------------

 cubic() 

    static cubic(t: number);

 

A cubic function,  f(t) = t * t * t . Position equals the cube of
elapsed time.

https://easings.net/#easeInCubic

------------------------------------------------------------------------

 poly() 

    static poly(n: number);

 

A power function. Position is equal to the Nth power of elapsed time.

n = 4: https://easings.net/#easeInQuart n = 5:
https://easings.net/#easeInQuint

------------------------------------------------------------------------

 sin() 

    static sin(t: number);

 

A sinusoidal function.

https://easings.net/#easeInSine

------------------------------------------------------------------------

 circle() 

    static circle(t: number);

 

A circular function.

https://easings.net/#easeInCirc

------------------------------------------------------------------------

 exp() 

    static exp(t: number);

 

An exponential function.

https://easings.net/#easeInExpo

------------------------------------------------------------------------

 elastic() 

    static elastic(bounciness: number);

 

A basic elastic interaction, similar to a spring oscillating back and
forth.

Default bounciness is 1, which overshoots a little bit once. 0
bounciness doesn't overshoot at all, and bounciness of N > 1 will
overshoot about N times.

https://easings.net/#easeInElastic

------------------------------------------------------------------------

 back() 

    static back(s)

 

Use with  Animated.parallel() to create a basic effect where the object
animates back slightly as the animation starts.

------------------------------------------------------------------------

 bounce() 

    static bounce(t: number);

 

Provides a basic bouncing effect.

https://easings.net/#easeInBounce

------------------------------------------------------------------------

 bezier() 

    static bezier(x1: number, y1: number, x2: number, y2: number);

 

Provides a cubic bezier curve, equivalent to CSS Transitions'
 transition-timing-function .

A useful tool to visualize cubic bezier curves can be found at
https://cubic-bezier.com/

------------------------------------------------------------------------

 in() 

    static in(easing: number);

 

Runs an easing function forwards.

------------------------------------------------------------------------

 out() 

    static out(easing: number);

 

Runs an easing function backwards.

------------------------------------------------------------------------

 inOut() 

    static inOut(easing: number);

 

Makes any easing function symmetrical. The easing function will run
forwards for half of the duration, then backwards for the rest of the
duration.

# Fast Refresh #
 _____         _     ____       __               _     
|  ___|_ _ ___| |_  |  _ \ ___ / _|_ __ ___  ___| |__  
| |_ / _` / __| __| | |_) / _ \ |_| '__/ _ \/ __| '_ \ 
|  _| (_| \__ \ |_  |  _ <  __/  _| | |  __/\__ \ | | |
|_|  \__,_|___/\__| |_| \_\___|_| |_|  \___||___/_| |_|
                                                       
-   How It Works
-   Error Resilience
-   Limitations
-   Tips
-   Fast Refresh and Hooks
Fast Refresh

Fast Refresh is a React Native feature that allows you to get
near-instant feedback for changes in your React components. Fast Refresh
is enabled by default, and you can toggle "Enable Fast Refresh" in the
React Native Dev Menu . With Fast Refresh enabled, most edits should be
visible within a second or two.

How It Works 

-   If you edit a module that only exports React component(s) , Fast
    Refresh will update the code only for that module, and re-render
    your component. You can edit anything in that file, including
    styles, rendering logic, event handlers, or effects.
-   If you edit a module with exports that aren't React components, Fast
    Refresh will re-run both that module, and the other modules
    importing it. So if both  Button.js and  Modal.js import  Theme.js ,
    editing  Theme.js will update both components.
-   Finally, if you edit a file that's imported by modules outside of
    the React tree , Fast Refresh will fall back to doing a full reload
    . You might have a file which renders a React component but also
    exports a value that is imported by a non-React component . For
    example, maybe your component also exports a constant, and a
    non-React utility module imports it. In that case, consider
    migrating the constant to a separate file and importing it into both
    files. This will re-enable Fast Refresh to work. Other cases can
    usually be solved in a similar way.

Error Resilience 

If you make a syntax error during a Fast Refresh session, you can fix it
and save the file again. The redbox will disappear. Modules with syntax
errors are prevented from running, so you won't need to reload the app.

If you make a runtime error during the module initialization (for
example, typing  Style.create instead of  StyleSheet.create ), the Fast
Refresh session will continue once you fix the error. The redbox will
disappear, and the module will be updated.

If you make a mistake that leads to a runtime error inside your
component , the Fast Refresh session will also continue after you fix
the error. In that case, React will remount your application using the
updated code.

If you have error boundaries in your app (which is a good idea for
graceful failures in production), they will retry rendering on the next
edit after a redbox. In that sense, having an error boundary can prevent
you from always getting kicked out to the root app screen. However, keep
in mind that error boundaries shouldn't be too granular. They are used
by React in production, and should always be designed intentionally.

Limitations 

Fast Refresh tries to preserve local React state in the component you're
editing, but only if it's safe to do so. Here's a few reasons why you
might see local state being reset on every edit to a file:

-   Local state is not preserved for class components (only function
    components and Hooks preserve state).
-   The module you're editing might have other exports in addition to a
    React component.
-   Sometimes, a module would export the result of calling higher-order
    component like  createNavigationContainer(MyScreen) . If the
    returned component is a class, state will be reset.

In the longer term, as more of your codebase moves to function
components and Hooks, you can expect state to be preserved in more
cases.

Tips 

-   Fast Refresh preserves React local state in function components (and
    Hooks) by default.
-   Sometimes you might want to force the state to be reset, and a
    component to be remounted. For example, this can be handy if you're
    tweaking an animation that only happens on mount. To do this, you
    can add  // @refresh reset anywhere in the file you're editing. This
    directive is local to the file, and instructs Fast Refresh to
    remount components defined in that file on every edit.

Fast Refresh and Hooks 

When possible, Fast Refresh attempts to preserve the state of your
component between edits. In particular,  useState and  useRef preserve
their previous values as long as you don't change their arguments or the
order of the Hook calls.

Hooks with dependencies—such as  useEffect ,  useMemo , and  useCallback
—will always update during Fast Refresh. Their list of dependencies will
be ignored while Fast Refresh is happening.

For example, when you edit  useMemo(() => x * 2, [x]) to
 useMemo(() => x * 10, [x]) , it will re-run even though  x (the
dependency) has not changed. If React didn't do that, your edit wouldn't
reflect on the screen!

Sometimes, this can lead to unexpected results. For example, even a
 useEffect with an empty array of dependencies would still re-run once
during Fast Refresh. However, writing code resilient to an occasional
re-running of  useEffect is a good practice even without Fast Refresh.
This makes it easier for you to later introduce new dependencies to it.

# FlatList #
 _____ _       _   _     _     _   
|  ___| | __ _| |_| |   (_)___| |_ 
| |_  | |/ _` | __| |   | / __| __|
|  _| | | (_| | |_| |___| \__ \ |_ 
|_|   |_|\__,_|\__|_____|_|___/\__|
                                   
-   Example
-   Props
    -   VirtualizedList Props
    -   
        Required

         renderItem
    -   
        Required

         data
    -    ItemSeparatorComponent
    -    ListEmptyComponent
    -    ListFooterComponent
    -    ListFooterComponentStyle
    -    ListHeaderComponent
    -    ListHeaderComponentStyle
    -    columnWrapperStyle
    -    extraData
    -    getItemLayout
    -    horizontal
    -    initialNumToRender
    -    initialScrollIndex
    -    inverted
    -    keyExtractor
    -    numColumns
    -    onRefresh
    -    onViewableItemsChanged
    -    progressViewOffset
    -    refreshing
    -    removeClippedSubviews
    -    viewabilityConfig
    -    viewabilityConfigCallbackPairs
-   Methods
    -    flashScrollIndicators()
    -    getNativeScrollRef()
    -    getScrollResponder()
    -    getScrollableNode()
    -    scrollToEnd()
    -    scrollToIndex()
    -    scrollToItem()
    -    scrollToOffset()
FlatList

A performant interface for rendering basic, flat lists, supporting the
most handy features:

-   Fully cross-platform.
-   Optional horizontal mode.
-   Configurable viewability callbacks.
-   Header support.
-   Footer support.
-   Separator support.
-   Pull to Refresh.
-   Scroll loading.
-   ScrollToIndex support.
-   Multiple column support.

If you need section support, use  <SectionList> .

Example 

-   TypeScript
-   JavaScript

To render multiple columns, use the  numColumns prop. Using this
approach instead of a  flexWrap layout can prevent conflicts with the
item height logic.

More complex, selectable example below.

-   By passing  extraData={selectedId} to  FlatList we make sure
     FlatList itself will re-render when the state changes. Without
    setting this prop,  FlatList would not know it needs to re-render
    any items because it is a  PureComponent and the prop comparison
    will not show any changes.
-    keyExtractor tells the list to use the  id s for the react keys
    instead of the default  key property.

-   TypeScript
-   JavaScript

This is a convenience wrapper around  <VirtualizedList> , and thus
inherits its props (as well as those of  <ScrollView> ) that aren't
explicitly listed here, along with the following caveats:

-   Internal state is not preserved when content scrolls out of the
    render window. Make sure all your data is captured in the item data
    or external stores like Flux, Redux, or Relay.
-   This is a  PureComponent which means that it will not re-render if
     props remain shallow-equal. Make sure that everything your
     renderItem function depends on is passed as a prop (e.g.  extraData
    ) that is not  === after updates, otherwise your UI may not update
    on changes. This includes the  data prop and parent component state.
-   In order to constrain memory and enable smooth scrolling, content is
    rendered asynchronously offscreen. This means it's possible to
    scroll faster than the fill rate and momentarily see blank content.
    This is a tradeoff that can be adjusted to suit the needs of each
    application, and we are working on improving it behind the scenes.
-   By default, the list looks for a  key prop on each item and uses
    that for the React key. Alternatively, you can provide a custom
     keyExtractor prop.

------------------------------------------------------------------------

Reference

Props 

VirtualizedList Props 

Inherits VirtualizedList Props .

------------------------------------------------------------------------

Required

 renderItem 

    renderItem({
      item: ItemT,
      index: number,
      separators: {
        highlight: () => void;
        unhighlight: () => void;
        updateProps: (select: 'leading' | 'trailing', newProps: any) => void;
      }
    }): JSX.Element;

 

Takes an item from  data and renders it into the list.

Provides additional metadata like  index if you need it, as well as a
more generic  separators.updateProps function which let you set whatever
props you want to change the rendering of either the leading separator
or trailing separator in case the more common  highlight and
 unhighlight (which set the  highlighted: boolean prop) are insufficient
for your use case.

  Type
  ----------
  function

-    item (Object): The item from  data being rendered.
-    index (number): The index corresponding to this item in the  data
    array.
-    separators (Object)
    -    highlight (Function)
    -    unhighlight (Function)
    -    updateProps (Function)
        -    select (enum('leading', 'trailing'))
        -    newProps (Object)

Example usage:

    <FlatList
      ItemSeparatorComponent={
        Platform.OS !== 'android' &&
        (({highlighted}) => (
          <View
            style={[style.separator, highlighted && {marginLeft: 0}]}
          />
        ))
      }
      data={[{title: 'Title Text', key: 'item1'}]}
      renderItem={({item, index, separators}) => (
        <TouchableHighlight
          key={item.key}
          onPress={() => this._onPress(item)}
          onShowUnderlay={separators.highlight}
          onHideUnderlay={separators.unhighlight}>
          <View style={{backgroundColor: 'white'}}>
            <Text>{item.title}</Text>
          </View>
        </TouchableHighlight>
      )}
    />

 

------------------------------------------------------------------------

Required

 data 

An array (or array-like list) of items to render. Other data types can
be used by targetting  VirtualizedList directly.

  Type
  -----------
  ArrayLike

------------------------------------------------------------------------

 ItemSeparatorComponent 

Rendered in between each item, but not at the top or bottom. By default,
 highlighted and  leadingItem props are provided.  renderItem provides
 separators.highlight /  unhighlight which will update the  highlighted
prop, but you can also add custom props with  separators.updateProps .
Can be a React Component (e.g.  SomeComponent ), or a React element
(e.g.  <SomeComponent /> ).

  Type
  ------------------------------
  component, function, element

------------------------------------------------------------------------

 ListEmptyComponent 

Rendered when the list is empty. Can be a React Component (e.g.
 SomeComponent ), or a React element (e.g.  <SomeComponent /> ).

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 ListFooterComponent 

Rendered at the bottom of all the items. Can be a React Component (e.g.
 SomeComponent ), or a React element (e.g.  <SomeComponent /> ).

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 ListFooterComponentStyle 

Styling for internal View for  ListFooterComponent .

  Type
  ------------
  View Style

------------------------------------------------------------------------

 ListHeaderComponent 

Rendered at the top of all the items. Can be a React Component (e.g.
 SomeComponent ), or a React element (e.g.  <SomeComponent /> ).

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 ListHeaderComponentStyle 

Styling for internal View for  ListHeaderComponent .

  Type
  ------------
  View Style

------------------------------------------------------------------------

 columnWrapperStyle 

Optional custom style for multi-item rows generated when  numColumns > 1
.

  Type
  ------------
  View Style

------------------------------------------------------------------------

 extraData 

A marker property for telling the list to re-render (since it implements
 PureComponent ). If any of your  renderItem , Header, Footer, etc.
functions depend on anything outside of the  data prop, stick it here
and treat it immutably.

  Type
  ------
  any

------------------------------------------------------------------------

 getItemLayout 

    (data, index) => {length: number, offset: number, index: number}

 

 getItemLayout is an optional optimization that allows skipping the
measurement of dynamic content if you know the size (height or width) of
items ahead of time.  getItemLayout is efficient if you have fixed size
items, for example:

      getItemLayout={(data, index) => (
        {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index}
      )}

 

Adding  getItemLayout can be a great performance boost for lists of
several hundred items. Remember to include separator length (height or
width) in your offset calculation if you specify  ItemSeparatorComponent
.

  Type
  ----------
  function

------------------------------------------------------------------------

 horizontal 

If  true , renders items next to each other horizontally instead of
stacked vertically.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 initialNumToRender 

How many items to render in the initial batch. This should be enough to
fill the screen but not much more. Note these items will never be
unmounted as part of the windowed rendering in order to improve
perceived performance of scroll-to-top actions.

  Type     Default
  -------- ---------
  number    10

------------------------------------------------------------------------

 initialScrollIndex 

Instead of starting at the top with the first item, start at
 initialScrollIndex . This disables the "scroll to top" optimization
that keeps the first  initialNumToRender items always rendered and
immediately renders the items starting at this initial index. Requires
 getItemLayout to be implemented.

  Type
  --------
  number

------------------------------------------------------------------------

 inverted 

Reverses the direction of scroll. Uses scale transforms of  -1 .

  Type
  ---------
  boolean

------------------------------------------------------------------------

 keyExtractor 

    (item: ItemT, index: number) => string;

 

Used to extract a unique key for a given item at the specified index.
Key is used for caching and as the react key to track item re-ordering.
The default extractor checks  item.key , then  item.id , and then falls
back to using the index, like React does.

  Type
  ----------
  function

------------------------------------------------------------------------

 numColumns 

Multiple columns can only be rendered with  horizontal={false} and will
zig-zag like a  flexWrap layout. Items should all be the same height -
masonry layouts are not supported.

  Type
  --------
  number

------------------------------------------------------------------------

 onRefresh 

    () => void;

 

If provided, a standard RefreshControl will be added for "Pull to
Refresh" functionality. Make sure to also set the  refreshing prop
correctly.

  Type
  ----------
  function

------------------------------------------------------------------------

 onViewableItemsChanged 

Called when the viewability of rows changes, as defined by the
 viewabilityConfig prop.

  Type
  -------------------------------------------------------------------------------
   (callback: {changed:  ViewToken  , viewableItems:  ViewToken  } => void;

------------------------------------------------------------------------

 progressViewOffset 

Set this when offset is needed for the loading indicator to show
correctly.

  Type
  --------
  number

------------------------------------------------------------------------

 refreshing 

Set this true while waiting for new data from a refresh.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 removeClippedSubviews 

This may improve scroll performance for large lists. On Android the
default value is  true .

  Note: May have bugs (missing content) in some circumstances - use at
  your own risk.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 viewabilityConfig 

See  ViewabilityHelper.js for flow type and further documentation.

  Type
  -------------------
  ViewabilityConfig

 viewabilityConfig takes a type  ViewabilityConfig an object with
following properties

  Property                           Type
  ---------------------------------- ---------
  minimumViewTime                    number
  viewAreaCoveragePercentThreshold   number
  itemVisiblePercentThreshold        number
  waitForInteraction                 boolean

At least one of the  viewAreaCoveragePercentThreshold or
 itemVisiblePercentThreshold is required. This needs to be done in the
 constructor to avoid following error ( ref ):

      Error: Changing viewabilityConfig on the fly is not supported

 

    constructor (props) {
      super(props)

      this.viewabilityConfig = {
          waitForInteraction: true,
          viewAreaCoveragePercentThreshold: 95
      }
    }

 

    <FlatList
        viewabilityConfig={this.viewabilityConfig}
      ...

 

minimumViewTime 

Minimum amount of time (in milliseconds) that an item must be physically
viewable before the viewability callback will be fired. A high number
means that scrolling through content without stopping will not mark the
content as viewable.

viewAreaCoveragePercentThreshold 

Percent of viewport that must be covered for a partially occluded item
to count as "viewable", 0-100. Fully visible items are always considered
viewable. A value of 0 means that a single pixel in the viewport makes
the item viewable, and a value of 100 means that an item must be either
entirely visible or cover the entire viewport to count as viewable.

itemVisiblePercentThreshold 

Similar to  viewAreaCoveragePercentThreshold , but considers the percent
of the item that is visible, rather than the fraction of the viewable
area it covers.

waitForInteraction 

Nothing is considered viewable until the user scrolls or
 recordInteraction is called after render.

------------------------------------------------------------------------

 viewabilityConfigCallbackPairs 

List of  ViewabilityConfig /  onViewableItemsChanged pairs. A specific
 onViewableItemsChanged will be called when its corresponding
 ViewabilityConfig 's conditions are met. See  ViewabilityHelper.js for
flow type and further documentation.

  Type
  ----------------------------------------
  array of ViewabilityConfigCallbackPair

Methods 

 flashScrollIndicators() 

    flashScrollIndicators();

 

Displays the scroll indicators momentarily.

------------------------------------------------------------------------

 getNativeScrollRef() 

    getNativeScrollRef(): React.ElementRef<typeof ScrollViewComponent>;

 

Provides a reference to the underlying scroll component

------------------------------------------------------------------------

 getScrollResponder() 

    getScrollResponder(): ScrollResponderMixin;

 

Provides a handle to the underlying scroll responder.

------------------------------------------------------------------------

 getScrollableNode() 

    getScrollableNode(): any;

 

Provides a handle to the underlying scroll node.

 scrollToEnd() 

    scrollToEnd(params?: {animated?: boolean});

 

Scrolls to the end of the content. May be janky without  getItemLayout
prop.

Parameters:

  Name     Type
  -------- --------
  params   object

Valid  params keys are:

-   'animated' (boolean) - Whether the list should do an animation while
    scrolling. Defaults to  true .

------------------------------------------------------------------------

 scrollToIndex() 

    scrollToIndex: (params: {
      index: number;
      animated?: boolean;
      viewOffset?: number;
      viewPosition?: number;
    });

 

Scrolls to the item at the specified index such that it is positioned in
the viewable area such that  viewPosition 0 places it at the top, 1 at
the bottom, and 0.5 centered in the middle.

  Note: Cannot scroll to locations outside the render window without
  specifying the  getItemLayout prop.

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| params                            | object                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

Valid  params keys are:

-   'animated' (boolean) - Whether the list should do an animation while
    scrolling. Defaults to  true .
-   'index' (number) - The index to scroll to. Required.
-   'viewOffset' (number) - A fixed number of pixels to offset the final
    target position.
-   'viewPosition' (number) - A value of  0 places the item specified by
    index at the top,  1 at the bottom, and  0.5 centered in the middle.

------------------------------------------------------------------------

 scrollToItem() 

    scrollToItem(params: {
      animated?: ?boolean,
      item: Item,
      viewPosition?: number,
    });

 

Requires linear scan through data - use  scrollToIndex instead if
possible.

  Note: Cannot scroll to locations outside the render window without
  specifying the  getItemLayout prop.

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| params                            | object                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

Valid  params keys are:

-   'animated' (boolean) - Whether the list should do an animation while
    scrolling. Defaults to  true .
-   'item' (object) - The item to scroll to. Required.
-   'viewPosition' (number)

------------------------------------------------------------------------

 scrollToOffset() 

    scrollToOffset(params: {
      offset: number;
      animated?: boolean;
    });

 

Scroll to a specific content pixel offset in the list.

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| params                            | object                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

Valid  params keys are:

-   'offset' (number) - The offset to scroll to. In case of  horizontal
    being true, the offset is the x-value, in any other case the offset
    is the y-value. Required.
-   'animated' (boolean) - Whether the list should do an animation while
    scrolling. Defaults to  true .

# Gesture Responder System #
  ____           _                  
 / ___| ___  ___| |_ _   _ _ __ ___ 
| |  _ / _ \/ __| __| | | | '__/ _ \
| |_| |  __/\__ \ |_| |_| | | |  __/
 \____|\___||___/\__|\__,_|_|  \___|
                                    
 ____                                 _           
|  _ \ ___  ___ _ __   ___  _ __   __| | ___ _ __ 
| |_) / _ \/ __| '_ \ / _ \| '_ \ / _` |/ _ \ '__|
|  _ <  __/\__ \ |_) | (_) | | | | (_| |  __/ |   
|_| \_\___||___/ .__/ \___/|_| |_|\__,_|\___|_|   
               |_|                                
 ____            _                 
/ ___| _   _ ___| |_ ___ _ __ ___  
\___ \| | | / __| __/ _ \ '_ ` _ \ 
 ___) | |_| \__ \ ||  __/ | | | | |
|____/ \__, |___/\__\___|_| |_| |_|
       |___/                       
-   Best Practices
-   TouchableHighlight and Touchable*
-   Responder Lifecycle
    -   Capture ShouldSet Handlers
    -   PanResponder
Gesture Responder System

The gesture responder system manages the lifecycle of gestures in your
app. A touch can go through several phases as the app determines what
the user's intention is. For example, the app needs to determine if the
touch is scrolling, sliding on a widget, or tapping. This can even
change during the duration of a touch. There can also be multiple
simultaneous touches.

The touch responder system is needed to allow components to negotiate
these touch interactions without any additional knowledge about their
parent or child components.

Best Practices 

To make your app feel great, every action should have the following
attributes:

-   Feedback/highlighting- show the user what is handling their touch,
    and what will happen when they release the gesture
-   Cancel-ability- when making an action, the user should be able to
    abort it mid-touch by dragging their finger away

These features make users more comfortable while using an app, because
it allows people to experiment and interact without fear of making
mistakes.

TouchableHighlight and Touchable* 

The responder system can be complicated to use. So we have provided an
abstract  Touchable implementation for things that should be "tappable".
This uses the responder system and allows you to configure tap
interactions declaratively. Use  TouchableHighlight anywhere where you
would use a button or link on web.

Responder Lifecycle 

A view can become the touch responder by implementing the correct
negotiation methods. There are two methods to ask the view if it wants
to become responder:

-    View.props.onStartShouldSetResponder: evt => true, - Does this view
    want to become responder on the start of a touch?
-    View.props.onMoveShouldSetResponder: evt => true, - Called for
    every touch move on the View when it is not the responder: does this
    view want to "claim" touch responsiveness?

If the View returns true and attempts to become the responder, one of
the following will happen:

-    View.props.onResponderGrant: evt => {} - The View is now responding
    for touch events. This is the time to highlight and show the user
    what is happening
-    View.props.onResponderReject: evt => {} - Something else is the
    responder right now and will not release it

If the view is responding, the following handlers can be called:

-    View.props.onResponderMove: evt => {} - The user is moving their
    finger
-    View.props.onResponderRelease: evt => {} - Fired at the end of the
    touch, ie "touchUp"
-    View.props.onResponderTerminationRequest: evt => true - Something
    else wants to become responder. Should this view release the
    responder? Returning true allows release
-    View.props.onResponderTerminate: evt => {} - The responder has been
    taken from the View. Might be taken by other views after a call to
     onResponderTerminationRequest , or might be taken by the OS without
    asking (happens with control center/ notification center on iOS)

 evt is a synthetic touch event with the following form:

-    nativeEvent
    -    changedTouches - Array of all touch events that have changed
        since the last event
    -    identifier - The ID of the touch
    -    locationX - The X position of the touch, relative to the
        element
    -    locationY - The Y position of the touch, relative to the
        element
    -    pageX - The X position of the touch, relative to the root
        element
    -    pageY - The Y position of the touch, relative to the root
        element
    -    target - The node id of the element receiving the touch event
    -    timestamp - A time identifier for the touch, useful for
        velocity calculation
    -    touches - Array of all current touches on the screen

Capture ShouldSet Handlers 

 onStartShouldSetResponder and  onMoveShouldSetResponder are called with
a bubbling pattern, where the deepest node is called first. That means
that the deepest component will become responder when multiple Views
return true for  *ShouldSetResponder handlers. This is desirable in most
cases, because it makes sure all controls and buttons are usable.

However, sometimes a parent will want to make sure that it becomes
responder. This can be handled by using the capture phase. Before the
responder system bubbles up from the deepest component, it will do a
capture phase, firing  on*ShouldSetResponderCapture . So if a parent
View wants to prevent the child from becoming responder on a touch
start, it should have a  onStartShouldSetResponderCapture handler which
returns true.

-    View.props.onStartShouldSetResponderCapture: evt => true,
-    View.props.onMoveShouldSetResponderCapture: evt => true,

PanResponder 

For higher-level gesture interpretation, check out PanResponder .

# Handling Text Input #
 _   _                 _ _ _               _____         _   
| | | | __ _ _ __   __| | (_)_ __   __ _  |_   _|____  _| |_ 
| |_| |/ _` | '_ \ / _` | | | '_ \ / _` |   | |/ _ \ \/ / __|
|  _  | (_| | | | | (_| | | | | | | (_| |   | |  __/>  <| |_ 
|_| |_|\__,_|_| |_|\__,_|_|_|_| |_|\__, |   |_|\___/_/\_\\__|
                                   |___/                     
 ___                   _   
|_ _|_ __  _ __  _   _| |_ 
 | || '_ \| '_ \| | | | __|
 | || | | | |_) | |_| | |_ 
|___|_| |_| .__/ \__,_|\__|
          |_|              

Handling Text Input

 TextInput is a Core Component that allows the user to enter text. It
has an  onChangeText prop that takes a function to be called every time
the text changed, and an  onSubmitEditing prop that takes a function to
be called when the text is submitted.

For example, let's say that as the user types, you're translating their
words into a different language. In this new language, every single word
is written the same way: 🍕. So the sentence "Hello there Bob" would be
translated as "🍕 🍕 🍕".

In this example, we store  text in the state, because it changes over
time.

There are a lot more things you might want to do with a text input. For
example, you could validate the text inside while the user types. For
more detailed examples, see the React docs on controlled components , or
the reference docs for TextInput .

Text input is one of the ways the user interacts with the app. Next,
let's look at another type of input and learn how to handle touches .

# Handling Touches #
 _   _                 _ _ _             
| | | | __ _ _ __   __| | (_)_ __   __ _ 
| |_| |/ _` | '_ \ / _` | | | '_ \ / _` |
|  _  | (_| | | | | (_| | | | | | | (_| |
|_| |_|\__,_|_| |_|\__,_|_|_|_| |_|\__, |
                                   |___/ 
 _____                _               
|_   _|__  _   _  ___| |__   ___  ___ 
  | |/ _ \| | | |/ __| '_ \ / _ \/ __|
  | | (_) | |_| | (__| | | |  __/\__ \
  |_|\___/ \__,_|\___|_| |_|\___||___/
                                      
-   Displaying a basic button
-   Touchables
-   Scrolling and swiping
-   Known issues
Handling Touches

Users interact with mobile apps mainly through touch. They can use a
combination of gestures, such as tapping on a button, scrolling a list,
or zooming on a map. React Native provides components to handle all
sorts of common gestures, as well as a comprehensive gesture responder
system to allow for more advanced gesture recognition, but the one
component you will most likely be interested in is the basic Button.

Displaying a basic button 

Button provides a basic button component that is rendered nicely on all
platforms. The minimal example to display a button looks like this:

    <Button
      onPress={() => {
        console.log('You tapped the button!');
      }}
      title="Press Me"
    />

 

This will render a blue label on iOS, and a blue rounded rectangle with
light text on Android. Pressing the button will call the "onPress"
function, which in this case displays an alert popup. If you like, you
can specify a "color" prop to change the color of your button.



Go ahead and play around with the  Button component using the example
below. You can select which platform your app is previewed in by
clicking on the toggle in the bottom right and then clicking on "Tap to
Play" to preview the app.

Touchables 

If the basic button doesn't look right for your app, you can build your
own button using any of the "Touchable" components provided by React
Native. The "Touchable" components provide the capability to capture
tapping gestures, and can display feedback when a gesture is recognized.
These components do not provide any default styling, however, so you
will need to do a bit of work to get them looking nicely in your app.

Which "Touchable" component you use will depend on what kind of feedback
you want to provide:

-   Generally, you can use TouchableHighlight anywhere you would use a
    button or link on web. The view's background will be darkened when
    the user presses down on the button.

-   You may consider using TouchableNativeFeedback on Android to display
    ink surface reaction ripples that respond to the user's touch.

-   TouchableOpacity can be used to provide feedback by reducing the
    opacity of the button, allowing the background to be seen through
    while the user is pressing down.

-   If you need to handle a tap gesture but you don't want any feedback
    to be displayed, use TouchableWithoutFeedback .

In some cases, you may want to detect when a user presses and holds a
view for a set amount of time. These long presses can be handled by
passing a function to the  onLongPress props of any of the "Touchable"
components.

Let's see all of these in action:

Scrolling and swiping 

Gestures commonly used on devices with touchable screens include swipes
and pans. These allow the user to scroll through a list of items, or
swipe through pages of content. For these, check out the ScrollView Core
Component.

Known issues 

-   react-native#29308 : The touch area never extends past the parent
    view bounds and on Android negative margin is not supported.

# Headless JS #
 _   _                _ _                     _ ____  
| | | | ___  __ _  __| | | ___  ___ ___      | / ___| 
| |_| |/ _ \/ _` |/ _` | |/ _ \/ __/ __|  _  | \___ \ 
|  _  |  __/ (_| | (_| | |  __/\__ \__ \ | |_| |___) |
|_| |_|\___|\__,_|\__,_|_|\___||___/___/  \___/|____/ 
                                                      
-   The JS API
-   The Platform API
-   Retries
-   Caveats
-   Example Usage
Headless JS

Headless JS is a way to run tasks in JavaScript while your app is in the
background. It can be used, for example, to sync fresh data, handle push
notifications, or play music.

The JS API 

A task is an async function that you register on  AppRegistry , similar
to registering React applications:

    import {AppRegistry} from 'react-native';
    AppRegistry.registerHeadlessTask('SomeTaskName', () =>
      require('SomeTaskName'),
    );

 

Then, in  SomeTaskName.js :

    module.exports = async taskData => {
      // do stuff
    };

 

You can do anything in your task such as network requests, timers and so
on, as long as it doesn't touch UI. Once your task completes (i.e. the
promise is resolved), React Native will go into "paused" mode (unless
there are other tasks running, or there is a foreground app).

The Platform API 

Yes, this does still require some native code, but it's pretty thin. You
need to extend  HeadlessJsTaskService and override  getTaskConfig ,
e.g.:

-   Java
-   Kotlin

    package com.your_application_name;

    import android.content.Intent;
    import android.os.Bundle;
    import com.facebook.react.HeadlessJsTaskService;
    import com.facebook.react.bridge.Arguments;
    import com.facebook.react.jstasks.HeadlessJsTaskConfig;
    import javax.annotation.Nullable;

    public class MyTaskService extends HeadlessJsTaskService {

      @Override
      protected @Nullable HeadlessJsTaskConfig getTaskConfig(Intent intent) {
        Bundle extras = intent.getExtras();
        if (extras != null) {
          return new HeadlessJsTaskConfig(
              "SomeTaskName",
              Arguments.fromBundle(extras),
              5000, // timeout in milliseconds for the task
              false // optional: defines whether or not the task is allowed in foreground. Default is false
            );
        }
        return null;
      }
    }

 

    package com.your_application_name;

    import android.content.Intent
    import com.facebook.react.HeadlessJsTaskService
    import com.facebook.react.bridge.Arguments
    import com.facebook.react.jstasks.HeadlessJsTaskConfig

    class MyTaskService : HeadlessJsTaskService() {
        override fun getTaskConfig(intent: Intent): HeadlessJsTaskConfig? {
            return intent.extras?.let {
                HeadlessJsTaskConfig(
                    "SomeTaskName",
                    Arguments.fromBundle(it),
                    5000, // timeout for the task
                    false // optional: defines whether or not the task is allowed in foreground.
                    // Default is false
                )
            }
        }
    }

 

Then add the service to your  AndroidManifest.xml file inside the
 application tag:

    <service android:name="com.example.MyTaskService" />

 

Now, whenever you start your service , e.g. as a periodic task or in
response to some system event / broadcast, JS will spin up, run your
task, then spin down.

Example:

-   Java
-   Kotlin

    Intent service = new Intent(getApplicationContext(), MyTaskService.class);
    Bundle bundle = new Bundle();

    bundle.putString("foo", "bar");
    service.putExtras(bundle);

    getApplicationContext().startService(service);

 

    val service = Intent(applicationContext, MyTaskService::class.java)
    val bundle = Bundle()

    bundle.putString("foo", "bar")

    service.putExtras(bundle)

    applicationContext.startService(service)

 

Retries 

By default, the headless JS task will not perform any retries. In order
to do so, you need to create a  HeadlessJsRetryPolicy and throw a
specific  Error .

 LinearCountingRetryPolicy is an implementation of
 HeadlessJsRetryPolicy that allows you to specify a maximum number of
retries with a fixed delay between each attempt. If that does not suit
your needs then you can implement your own  HeadlessJsRetryPolicy .
These policies can be passed as an extra argument to the
 HeadlessJsTaskConfig constructor, e.g.

-   Java
-   Kotlin

    HeadlessJsRetryPolicy retryPolicy = new LinearCountingRetryPolicy(
      3, // Max number of retry attempts
      1000 // Delay between each retry attempt
    );

    return new HeadlessJsTaskConfig(
      'SomeTaskName',
      Arguments.fromBundle(extras),
      5000,
      false,
      retryPolicy
    );

 

    val retryPolicy: HeadlessJsTaskRetryPolicy =
        LinearCountingRetryPolicy(
            3, // Max number of retry attempts
            1000 // Delay between each retry attempt
        )

    return HeadlessJsTaskConfig("SomeTaskName", Arguments.fromBundle(extras), 5000, false, retryPolicy)

 

A retry attempt will only be made when a specific  Error is thrown.
Inside a headless JS task, you can import the error and throw it when a
retry attempt is required.

Example:

    import {HeadlessJsTaskError} from 'HeadlessJsTask';

    module.exports = async taskData => {
      const condition = ...;
      if (!condition) {
        throw new HeadlessJsTaskError();
      }
    };

 

If you wish all errors to cause a retry attempt, you will need to catch
them and throw the above error.

Caveats 

-   By default, your app will crash if you try to run a task while the
    app is in the foreground. This is to prevent developers from
    shooting themselves in the foot by doing a lot of work in a task and
    slowing the UI. You can pass a fourth  boolean argument to control
    this behaviour.
-   If you start your service from a  BroadcastReceiver , make sure to
    call  HeadlessJsTaskService.acquireWakeLockNow() before returning
    from  onReceive() .

Example Usage 

Service can be started from Java API. First you need to decide when the
service should be started and implement your solution accordingly. Here
is an example that reacts to network connection change.

Following lines shows part of Android manifest file for registering
broadcast receiver.

    <receiver android:name=".NetworkChangeReceiver" >
      <intent-filter>
        <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
      </intent-filter>
    </receiver>

 

Broadcast receiver then handles intent that was broadcasted in onReceive
function. This is a great place to check whether your app is on
foreground or not. If app is not on foreground we can prepare our intent
to be started, with no information or additional information bundled
using  putExtra (keep in mind bundle can handle only parcelable values).
In the end service is started and wakelock is acquired.

-   Java
-   Kotlin

    import android.app.ActivityManager;
    import android.content.BroadcastReceiver;
    import android.content.Context;
    import android.content.Intent;
    import android.net.ConnectivityManager;
    import android.net.Network;
    import android.net.NetworkCapabilities;
    import android.net.NetworkInfo;
    import android.os.Build;

    import com.facebook.react.HeadlessJsTaskService;

    public class NetworkChangeReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(final Context context, final Intent intent) {
            /**
             This part will be called every time network connection is changed
             e.g. Connected -> Not Connected
             **/
            if (!isAppOnForeground((context))) {
                /**
                 We will start our service and send extra info about
                 network connections
                 **/
                boolean hasInternet = isNetworkAvailable(context);
                Intent serviceIntent = new Intent(context, MyTaskService.class);
                serviceIntent.putExtra("hasInternet", hasInternet);
                context.startService(serviceIntent);
                HeadlessJsTaskService.acquireWakeLockNow(context);
            }
        }

        private boolean isAppOnForeground(Context context) {
            /**
             We need to check if app is in foreground otherwise the app will crash.
             https://stackoverflow.com/questions/8489993/check-android-application-is-in-foreground-or-not
             **/
            ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            List<ActivityManager.RunningAppProcessInfo> appProcesses =
                    activityManager.getRunningAppProcesses();
            if (appProcesses == null) {
                return false;
            }
            final String packageName = context.getPackageName();
            for (ActivityManager.RunningAppProcessInfo appProcess : appProcesses) {
                if (appProcess.importance ==
                        ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND &&
                        appProcess.processName.equals(packageName)) {
                    return true;
                }
            }
            return false;
        }

        public static boolean isNetworkAvailable(Context context) {
            ConnectivityManager cm = (ConnectivityManager)
                    context.getSystemService(Context.CONNECTIVITY_SERVICE);

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                Network networkCapabilities = cm.getActiveNetwork();

                if(networkCapabilities == null) {
                    return false;
                }

                NetworkCapabilities actNw = cm.getNetworkCapabilities(networkCapabilities);

                if(actNw == null) {
                    return false;
                }

                if(actNw.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) || actNw.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) || actNw.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)) {
                    return true;
                }

                return false;
            }

            // deprecated in API level 29
            NetworkInfo netInfo = cm.getActiveNetworkInfo();
            return (netInfo != null && netInfo.isConnected());
        }
    }

 

    import android.app.ActivityManager
    import android.app.ActivityManager.RunningAppProcessInfo
    import android.content.BroadcastReceiver
    import android.content.Context
    import android.content.Intent
    import android.net.ConnectivityManager
    import android.net.NetworkCapabilities
    import android.os.Build
    import com.facebook.react.HeadlessJsTaskService

    class NetworkChangeReceiver : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent?) {
            /**
             * This part will be called every time network connection is changed e.g. Connected -> Not
             * Connected
             */
            if (!isAppOnForeground(context)) {
                /** We will start our service and send extra info about network connections */
                val hasInternet = isNetworkAvailable(context)
                val serviceIntent = Intent(context, MyTaskService::class.java)
                serviceIntent.putExtra("hasInternet", hasInternet)
                context.startService(serviceIntent)
                HeadlessJsTaskService.acquireWakeLockNow(context)
            }
        }

        private fun isAppOnForeground(context: Context): Boolean {
            /**
             * We need to check if app is in foreground otherwise the app will crash.
             * https://stackoverflow.com/questions/8489993/check-android-application-is-in-foreground-or-not
             */
            val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
            val appProcesses = activityManager.runningAppProcesses ?: return false
            val packageName: String = context.getPackageName()
            for (appProcess in appProcesses) {
                if (appProcess.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND &&
                        appProcess.processName == packageName
                ) {
                    return true
                }
            }
            return false
        }

        companion object {
            fun isNetworkAvailable(context: Context): Boolean {
                val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
                var result = false

                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    val networkCapabilities = cm.activeNetwork ?: return false

                    val actNw = cm.getNetworkCapabilities(networkCapabilities) ?: return false

                    result =
                        when {
                            actNw.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -> true
                            actNw.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -> true
                            actNw.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) -> true
                            else -> false
                        }

                    return result
                } else {
                    cm.run {
                        // deprecated in API level 29
                        cm.activeNetworkInfo?.run {
                            result =
                                when (type) {
                                    ConnectivityManager.TYPE_WIFI -> true
                                    ConnectivityManager.TYPE_MOBILE -> true
                                    ConnectivityManager.TYPE_ETHERNET -> true
                                    else -> false
                                }
                        }
                    }
                }
                return result
            }
        }
    }

 

# Height and Width #
 _   _      _       _     _                     _ 
| | | | ___(_) __ _| |__ | |_    __ _ _ __   __| |
| |_| |/ _ \ |/ _` | '_ \| __|  / _` | '_ \ / _` |
|  _  |  __/ | (_| | | | | |_  | (_| | | | | (_| |
|_| |_|\___|_|\__, |_| |_|\__|  \__,_|_| |_|\__,_|
              |___/                               
__        ___     _ _   _     
\ \      / (_) __| | |_| |__  
 \ \ /\ / /| |/ _` | __| '_ \ 
  \ V  V / | | (_| | |_| | | |
   \_/\_/  |_|\__,_|\__|_| |_|
                              
-   Fixed Dimensions
-   Flex Dimensions
-   Percentage Dimensions
Height and Width

A component's height and width determine its size on the screen.

Fixed Dimensions 

The general way to set the dimensions of a component is by adding a
fixed  width and  height to style. All dimensions in React Native are
unitless, and represent density-independent pixels.

Setting dimensions this way is common for components whose size should
always be fixed to a number of points and not calculated based on screen
size.

 caution

There is no universal mapping from points to physical units of
measurement. This means that a component with fixed dimensions might not
have the same physical size, across different devices and screen sizes.
However, this difference is unnoticeable for most use cases.

Flex Dimensions 

Use  flex in a component's style to have the component expand and shrink
dynamically based on available space. Normally you will use  flex: 1 ,
which tells a component to fill all available space, shared evenly
amongst other components with the same parent. The larger the  flex
given, the higher the ratio of space a component will take compared to
its siblings.

 info

A component can only expand to fill available space if its parent has
dimensions greater than  0 . If a parent does not have either a fixed
 width and  height or  flex , the parent will have dimensions of  0 and
the  flex children will not be visible.

After you can control a component's size, the next step is to learn how
to lay it out on the screen .

Percentage Dimensions 

If you want to fill a certain portion of the screen, but you don't want
to use the  flex layout, you can use percentage values in the
component's style. Similar to flex dimensions, percentage dimensions
require parent with a defined size.

# Image #
 ___                            
|_ _|_ __ ___   __ _  __ _  ___ 
 | || '_ ` _ \ / _` |/ _` |/ _ \
 | || | | | | | (_| | (_| |  __/
|___|_| |_| |_|\__,_|\__, |\___|
                     |___/      
-   Examples
-   GIF and WebP support on Android
-   Props
    -   View Props
    -    accessible
    -    accessibilityLabel
    -    alt
    -    blurRadius
    -    capInsets
        iOS
    -    crossOrigin
    -    defaultSource
    -    fadeDuration
        Android
    -    height
    -    loadingIndicatorSource
    -    onError
    -    onLayout
    -    onLoad
    -    onLoadEnd
    -    onLoadStart
    -    onPartialLoad
        iOS
    -    onProgress
    -    progressiveRenderingEnabled
        Android
    -    resizeMethod
        Android
    -    referrerPolicy
    -    resizeMode
    -    source
    -    src
    -    srcSet
    -    style
    -    testID
    -    tintColor
    -    width
-   Methods
    -    abortPrefetch()
        Android
    -    getSize()
    -    getSizeWithHeaders()
    -    prefetch()
    -    queryCache()
    -    resolveAssetSource()
-   Type Definitions
    -   ImageCacheEnum
        iOS
    -   ImageLoadEvent
    -   ImageSource
Image

A React component for displaying different types of images, including
network images, static resources, temporary local images, and images
from local disk, such as the camera roll.

This example shows fetching and displaying an image from local storage
as well as one from network and even from data provided in the  'data:'
uri scheme.

  Note that for network and data images, you will need to manually
  specify the dimensions of your image!

Examples 

You can also add  style to an image:

GIF and WebP support on Android 

When building your own native code, GIF and WebP are not supported by
default on Android.

You will need to add some optional modules in  android/app/build.gradle
, depending on the needs of your app.

    dependencies {
      // If your app supports Android versions before Ice Cream Sandwich (API level 14)
      implementation 'com.facebook.fresco:animated-base-support:1.3.0'

      // For animated GIF support
      implementation 'com.facebook.fresco:animated-gif:2.5.0'

      // For WebP support, including animated WebP
      implementation 'com.facebook.fresco:animated-webp:2.5.0'
      implementation 'com.facebook.fresco:webpsupport:2.5.0'

      // For WebP support, without animations
      implementation 'com.facebook.fresco:webpsupport:2.5.0'
    }

 

  Note: the version listed above may not be updated in time. Please
  check  ReactAndroid/gradle.properties in the main repo to see which
  fresco version is being used in a specific tagged version.

------------------------------------------------------------------------

Reference

Props 

View Props 

Inherits View Props .

------------------------------------------------------------------------

 accessible 

When true, indicates the image is an accessibility element.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 accessibilityLabel 

The text that's read by the screen reader when the user interacts with
the image.

  Type
  --------
  string

------------------------------------------------------------------------

 alt 

A string that defines an alternative text description of the image,
which will be read by the screen reader when the user interacts with it.
Using this will automatically mark this element as accessible.

  Type
  --------
  string

------------------------------------------------------------------------

 blurRadius 

blurRadius: the blur radius of the blur filter added to the image.

  Type
  --------
  number

  Tip: On IOS, you will need to increase  blurRadius by more than  5 .

------------------------------------------------------------------------

 capInsets

iOS



When the image is resized, the corners of the size specified by
 capInsets will stay a fixed size, but the center content and borders of
the image will be stretched. This is useful for creating resizable
rounded buttons, shadows, and other resizable assets. More info in the
official Apple documentation .

  Type
  ------
  Rect

------------------------------------------------------------------------

 crossOrigin 

A string of a keyword specifying the CORS mode to use when fetching the
image resource. It works similar to crossorigin attribute in HTML.

-    anonymous : No exchange of user credentials in the image request.
-    use-credentials : Sets  Access-Control-Allow-Credentials header
    value to  true in the image request.

  Type                                        Default
  ------------------------------------------- --------------
  enum(  'anonymous' ,  'use-credentials' )    'anonymous'

------------------------------------------------------------------------

 defaultSource 

A static image to display while loading the image source.

  Type
  -------------
  ImageSource

  Note: On Android, the default source prop is ignored on debug builds.

------------------------------------------------------------------------

 fadeDuration

Android



Fade animation duration in milliseconds.

  Type     Default
  -------- ---------
  number    300

------------------------------------------------------------------------

 height 

Height of the image component.

  Type
  --------
  number

------------------------------------------------------------------------

 loadingIndicatorSource 

Similarly to  source , this property represents the resource used to
render the loading indicator for the image. The loading indicator is
displayed until image is ready to be displayed, typically after the
image is downloaded.

  Type
  ----------------------------------
  ImageSource (  uri only), number

------------------------------------------------------------------------

 onError 

Invoked on load error.

  Type
  --------------------------------------
  (  {nativeEvent: {error} } ) => void

------------------------------------------------------------------------

 onLayout 

Invoked on mount and on layout changes.

  Type
  -----------------------------------------
   ({nativeEvent:  LayoutEvent  } => void

------------------------------------------------------------------------

 onLoad 

Invoked when load completes successfully.

Example:
 onLoad={({nativeEvent: {source: {width, height}}}) => setImageRealSize({width, height})}

  Type
  --------------------------------------------
   ({nativeEvent:  ImageLoadEvent  } => void

------------------------------------------------------------------------

 onLoadEnd 

Invoked when load either succeeds or fails.

  Type
  ------------
  () => void

------------------------------------------------------------------------

 onLoadStart 

Invoked on load start.

Example:  onLoadStart={() => this.setState({loading: true})}

  Type
  ------------
  () => void

------------------------------------------------------------------------

 onPartialLoad

iOS



Invoked when a partial load of the image is complete. The definition of
what constitutes a "partial load" is loader specific though this is
meant for progressive JPEG loads.

  Type
  ------------
  () => void

------------------------------------------------------------------------

 onProgress 

Invoked on download progress.

  Type
  ----------------------------------------------
  (  {nativeEvent: {loaded, total} } ) => void

------------------------------------------------------------------------

 progressiveRenderingEnabled

Android



When  true , enables progressive jpeg streaming -
https://frescolib.org/docs/progressive-jpegs .

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 resizeMethod

Android



The mechanism that should be used to resize the image when the image's
dimensions differ from the image view's dimensions. Defaults to  auto .

-    auto : Use heuristics to pick between  resize and  scale .

-    resize : A software operation which changes the encoded image in
    memory before it gets decoded. This should be used instead of  scale
    when the image is much larger than the view.

-    scale : The image gets drawn downscaled or upscaled. Compared to
     resize ,  scale is faster (usually hardware accelerated) and
    produces higher quality images. This should be used if the image is
    smaller than the view. It should also be used if the image is
    slightly bigger than the view.

More details about  resize and  scale can be found at
https://frescolib.org/docs/resizing .

  Type                                     Default
  ---------------------------------------- ---------
  enum(  'auto' ,  'resize' ,  'scale' )    'auto'

------------------------------------------------------------------------

 referrerPolicy 

A string indicating which referrer to use when fetching the resource.
Sets the value for  Referrer-Policy header in the image request. Works
similar to  referrerpolicy attribute in HTML.

  Type                                                                                                                                                                                        Default
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ------------------------------------
  enum(  'no-referrer' ,  'no-referrer-when-downgrade' ,  'origin' ,  'origin-when-cross-origin' ,  'same-origin' ,  'strict-origin' ,  'strict-origin-when-cross-origin' ,  'unsafe-url' )    'strict-origin-when-cross-origin'

------------------------------------------------------------------------

 resizeMode 

Determines how to resize the image when the frame doesn't match the raw
image dimensions. Defaults to  cover .

-    cover : Scale the image uniformly (maintain the image's aspect
    ratio) so that

    -   both dimensions (width and height) of the image will be equal to
        or larger than the corresponding dimension of the view (minus
        padding)
    -   at least one dimension of the scaled image will be equal to the
        corresponding dimension of the view (minus padding)

-    contain : Scale the image uniformly (maintain the image's aspect
    ratio) so that both dimensions (width and height) of the image will
    be equal to or less than the corresponding dimension of the view
    (minus padding).

-    stretch : Scale width and height independently, This may change the
    aspect ratio of the src.

-    repeat : Repeat the image to cover the frame of the view. The image
    will keep its size and aspect ratio, unless it is larger than the
    view, in which case it will be scaled down uniformly so that it is
    contained in the view.

-    center : Center the image in the view along both dimensions. If the
    image is larger than the view, scale it down uniformly so that it is
    contained in the view.

  Type                                                                 Default
  -------------------------------------------------------------------- ----------
  enum(  'cover' ,  'contain' ,  'stretch' ,  'repeat' ,  'center' )    'cover'

------------------------------------------------------------------------

 source 

The image source (either a remote URL or a local file resource).

This prop can also contain several remote URLs, specified together with
their width and height and potentially with scale/other URI arguments.
The native side will then choose the best  uri to display based on the
measured size of the image container. A  cache property can be added to
control how networked request interacts with the local cache. (For more
information see Cache Control for Images ).

The currently supported formats are  png ,  jpg ,  jpeg ,  bmp ,  gif ,
 webp ,  psd (iOS only). In addition, iOS supports several RAW image
formats. Refer to Apple's documentation for the current list of
supported camera models (for iOS 12, see
https://support.apple.com/en-ca/HT208967 ).

  Type
  -------------
  ImageSource

------------------------------------------------------------------------

 src 

A string representing the remote URL of the image. This prop has
precedence over  source prop.

Example:  src={'https://reactnative.dev/img/tiny_logo.png'}

  Type
  --------
  string

------------------------------------------------------------------------

 srcSet 

A string representing comma separated list of possible candidate image
source. Each image source contains a URL of an image and a pixel density
descriptor. If no descriptor is specified, it defaults to descriptor of
 1x .

If  srcSet does not contain a  1x descriptor, the value in  src is used
as image source with  1x descriptor (if provided).

This prop has precedence over both the  src and  source props.

Example:
 srcSet={'https://reactnative.dev/img/tiny_logo.png 1x, https://reactnative.dev/img/header_logo.svg 2x'}

  Type
  --------
  string

------------------------------------------------------------------------

 style 

  Type
  --------------------------------------------------------------
  Image Style Props , Layout Props , Shadow Props , Transforms

------------------------------------------------------------------------

 testID 

A unique identifier for this element to be used in UI Automation testing
scripts.

  Type
  --------
  string

------------------------------------------------------------------------

 tintColor 

Changes the color of all non-transparent pixels to the  tintColor .

  Type
  -------
  color

------------------------------------------------------------------------

 width 

Width of the image component.

  Type
  --------
  number

Methods 

 abortPrefetch()

Android



    static abortPrefetch(requestId: number);

 

Abort prefetch request.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| requestId             | number                | Request id as         |
|                       |                       | returned by           |
| Required              |                       |  prefetch() .         |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 getSize() 

    static getSize(
      uri: string,
      success: (width: number, height: number) => void,
      failure?: (error: any) => void,
    ): any;

 

Retrieve the width and height (in pixels) of an image prior to
displaying it. This method can fail if the image cannot be found, or
fails to download.

In order to retrieve the image dimensions, the image may first need to
be loaded or downloaded, after which it will be cached. This means that
in principle you could use this method to preload images, however it is
not optimized for that purpose, and may in future be implemented in a
way that does not fully load/download the image data. A proper,
supported way to preload images will be provided as a separate API.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| uri                   | string                | The location of the   |
|                       |                       | image.                |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+
| success               | function              | The function that     |
|                       |                       | will be called if the |
| Required              |                       | image was             |
|                       |                       | successfully found    |
|                       |                       | and width and height  |
|                       |                       | retrieved.            |
+-----------------------+-----------------------+-----------------------+
| failure               | function              | The function that     |
|                       |                       | will be called if     |
|                       |                       | there was an error,   |
|                       |                       | such as failing to    |
|                       |                       | retrieve the image.   |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 getSizeWithHeaders() 

    static getSizeWithHeaders(
      uri: string,
      headers: {[index: string]: string},
      success: (width: number, height: number) => void,
      failure?: (error: any) => void,
    ): any;

 

Retrieve the width and height (in pixels) of an image prior to
displaying it with the ability to provide the headers for the request.
This method can fail if the image cannot be found, or fails to download.
It also does not work for static image resources.

In order to retrieve the image dimensions, the image may first need to
be loaded or downloaded, after which it will be cached. This means that
in principle you could use this method to preload images, however it is
not optimized for that purpose, and may in future be implemented in a
way that does not fully load/download the image data. A proper,
supported way to preload images will be provided as a separate API.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| uri                   | string                | The location of the   |
|                       |                       | image.                |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+
| headers               | object                | The headers for the   |
|                       |                       | request.              |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+
| success               | function              | The function that     |
|                       |                       | will be called if the |
| Required              |                       | image was             |
|                       |                       | successfully found    |
|                       |                       | and width and height  |
|                       |                       | retrieved.            |
+-----------------------+-----------------------+-----------------------+
| failure               | function              | The function that     |
|                       |                       | will be called if     |
|                       |                       | there was an error,   |
|                       |                       | such as failing to    |
|                       |                       | retrieve the image.   |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 prefetch() 

    await Image.prefetch(url);

 

Prefetches a remote image for later use by downloading it to the disk
cache. Returns a promise which resolves to a boolean.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| url                   | string                | The remote location   |
|                       |                       | of the image.         |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+
| callback              | function              | The function that     |
|                       |                       | will be called with   |
|                       | Android               | the  requestId .      |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 queryCache() 

    static queryCache(
      urls: string,
    ): Promise<Record<string, 'memory' | 'disk' | 'disk/memory'>>;

 

Perform cache interrogation. Returns a promise which resolves to a
mapping from URL to cache status, such as "disk", "memory" or
"disk/memory". If a requested URL is not in the mapping, it means it's
not in the cache.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| urls                  | array                 | List of image URLs to |
|                       |                       | check the cache for.  |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 resolveAssetSource() 

    static resolveAssetSource(source: ImageSourcePropType): {
      height: number;
      width: number;
      scale: number;
      uri: string;
    };

 

Resolves an asset reference into an object which has the properties  uri
,  scale ,  width , and  height .

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| source                | ImageSource , number  | A number (opaque type |
|                       |                       | returned by           |
| Required              |                       |  require('./foo.png') |
|                       |                       | ) or an ImageSource.  |
+-----------------------+-----------------------+-----------------------+

Type Definitions 

ImageCacheEnum

iOS



Enum which can be used to set the cache handling or stategy for the
potentially cached responses.

  Type                                                                  Default
  --------------------------------------------------------------------- ------------
  enum(  'default' ,  'reload' ,  'force-cache' ,  'only-if-cached' )    'default'

-    default : Use the native platforms default strategy.
-    reload : The data for the URL will be loaded from the originating
    source. No existing cache data should be used to satisfy a URL load
    request.
-    force-cache : The existing cached data will be used to satisfy the
    request, regardless of its age or expiration date. If there is no
    existing data in the cache corresponding the request, the data is
    loaded from the originating source.
-    only-if-cached : The existing cache data will be used to satisfy a
    request, regardless of its age or expiration date. If there is no
    existing data in the cache corresponding to a URL load request, no
    attempt is made to load the data from the originating source, and
    the load is considered to have failed.

ImageLoadEvent 

Object returned in the  onLoad callback.

  Type
  --------
  object

Properties:

  Name     Type     Description
  -------- -------- -------------------
  source   object   The source object

Source Object 

Properties:

  Name     Type     Description
  -------- -------- --------------------------------------------------------------
  width    number   The width of loaded image.
  height   number   The height of loaded image.
  uri      string   A string representing the resource identifier for the image.

ImageSource 

  Type
  ----------------------------------
  object, array of objects, number

Properties (if passing as object or array of objects):

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| uri                   | string                | A string representing |
|                       |                       | the resource          |
|                       |                       | identifier for the    |
|                       |                       | image, which could be |
|                       |                       | an http address, a    |
|                       |                       | local file path, or   |
|                       |                       | the name of a static  |
|                       |                       | image resource.       |
+-----------------------+-----------------------+-----------------------+
| width                 | number                | Can be specified if   |
|                       |                       | known at build time,  |
|                       |                       | in which case the     |
|                       |                       | value will be used to |
|                       |                       | set the default       |
|                       |                       |  <Image/> component   |
|                       |                       | dimension.            |
+-----------------------+-----------------------+-----------------------+
| height                | number                | Can be specified if   |
|                       |                       | known at build time,  |
|                       |                       | in which case the     |
|                       |                       | value will be used to |
|                       |                       | set the default       |
|                       |                       |  <Image/> component   |
|                       |                       | dimension.            |
+-----------------------+-----------------------+-----------------------+
| scale                 | number                | Used to indicate the  |
|                       |                       | scale factor of the   |
|                       |                       | image. Defaults to    |
|                       |                       |  1.0 if unspecified,  |
|                       |                       | meaning that one      |
|                       |                       | image pixel equates   |
|                       |                       | to one display point  |
|                       |                       | / DIP.                |
+-----------------------+-----------------------+-----------------------+
| bundle                | string                | The iOS asset bundle  |
|                       |                       | which the image is    |
| iOS                   |                       | included in. This     |
|                       |                       | will default to       |
|                       |                       |                       |
|                       |                       | [NSBundle mainBundle] |
|                       |                       | if not set.           |
+-----------------------+-----------------------+-----------------------+
| method                | string                | The HTTP Method to    |
|                       |                       | use. Defaults to      |
|                       |                       |  'GET' if not         |
|                       |                       | specified.            |
+-----------------------+-----------------------+-----------------------+
| headers               | object                | An object             |
|                       |                       | representing the HTTP |
|                       |                       | headers to send along |
|                       |                       | with the request for  |
|                       |                       | a remote image.       |
+-----------------------+-----------------------+-----------------------+
| body                  | string                | The HTTP body to send |
|                       |                       | with the request.     |
|                       |                       | This must be a valid  |
|                       |                       | UTF-8 string, and     |
|                       |                       | will be sent exactly  |
|                       |                       | as specified, with no |
|                       |                       | additional encoding   |
|                       |                       | (e.g. URL-escaping or |
|                       |                       | base64) applied.      |
+-----------------------+-----------------------+-----------------------+
| cache                 | ImageCacheEnum        | Determines how the    |
|                       |                       | requests handles      |
| iOS                   |                       | potentially cached    |
|                       |                       | responses.            |
+-----------------------+-----------------------+-----------------------+

If passing a number:

-    number - opaque type returned by something like
     require('./image.jpg') .

# ImageBackground #
 ___                            ____             _                         
|_ _|_ __ ___   __ _  __ _  ___| __ )  __ _  ___| | ____ _ _ __ ___  _   _ 
 | || '_ ` _ \ / _` |/ _` |/ _ \  _ \ / _` |/ __| |/ / _` | '__/ _ \| | | |
 | || | | | | | (_| | (_| |  __/ |_) | (_| | (__|   < (_| | | | (_) | |_| |
|___|_| |_| |_|\__,_|\__, |\___|____/ \__,_|\___|_|\_\__, |_|  \___/ \__,_|
                     |___/                           |___/                 
           _ 
 _ __   __| |
| '_ \ / _` |
| | | | (_| |
|_| |_|\__,_|
             
-   Example
-   Props
    -   Image Props
    -    imageStyle
    -    imageRef
    -    style
ImageBackground

A common feature request from developers familiar with the web is
 background-image . To handle this use case, you can use the
 <ImageBackground> component, which has the same props as  <Image> , and
add whatever children to it you would like to layer on top of it.

You might not want to use  <ImageBackground> in some cases, since the
implementation is basic. Refer to  <ImageBackground> 's source code for
more insight, and create your own custom component when needed.

Note that you must specify some width and height style attributes.

Example 

------------------------------------------------------------------------

Reference

Props 

Image Props 

Inherits Image Props .

------------------------------------------------------------------------

 imageStyle 

  Type
  -------------
  Image Style

------------------------------------------------------------------------

 imageRef 

Allows to set a reference to the inner  Image component

  Type
  ------
  Ref

------------------------------------------------------------------------

 style 

  Type
  ------------
  View Style

# Images #
 ___                                 
|_ _|_ __ ___   __ _  __ _  ___  ___ 
 | || '_ ` _ \ / _` |/ _` |/ _ \/ __|
 | || | | | | | (_| | (_| |  __/\__ \
|___|_| |_| |_|\__,_|\__, |\___||___/
                     |___/           
-   Static Image Resources
-   Static Non-Image Resources
-   Images From Hybrid App's Resources
-   Network Images
    -   Network Requests for Images
-   URI Data Images
    -   Cache Control (iOS Only)
-   Local Filesystem Images
    -   Best Camera Roll Image
-   Why Not Automatically Size Everything?
-   Source as an object
-   Background Image via Nesting
-   iOS Border Radius Styles
-   Off-thread Decoding
-   Configuring iOS Image Cache Limits
Images

Static Image Resources 

React Native provides a unified way of managing images and other media
assets in your Android and iOS apps. To add a static image to your app,
place it somewhere in your source code tree and reference it like this:

    <Image source={require('./my-icon.png')} />

 

The image name is resolved the same way JS modules are resolved. In the
example above, the bundler will look for  my-icon.png in the same folder
as the component that requires it.

You can use the  @2x and  @3x suffixes to provide images for different
screen densities. If you have the following file structure:

    .
    ├── button.js
    └── img
        ├── check.png
        ├── check@2x.png
        └── check@3x.png

 

...and  button.js code contains:

    <Image source={require('./img/check.png')} />

 

...the bundler will bundle and serve the image corresponding to device's
screen density. For example,  check@2x.png , will be used on an iPhone
7, while  check@3x.png will be used on an iPhone 7 Plus or a Nexus 5. If
there is no image matching the screen density, the closest best option
will be selected.

On Windows, you might need to restart the bundler if you add new images
to your project.

Here are some benefits that you get:

1.  Same system on Android and iOS.
2.  Images live in the same folder as your JavaScript code. Components
    are self-contained.
3.  No global namespace, i.e. you don't have to worry about name
    collisions.
4.  Only the images that are actually used will be packaged into your
    app.
5.  Adding and changing images doesn't require app recompilation, you
    can refresh the simulator as you normally do.
6.  The bundler knows the image dimensions, no need to duplicate it in
    the code.
7.  Images can be distributed via npm packages.

In order for this to work, the image name in  require has to be known
statically.

    // GOOD
    <Image source={require('./my-icon.png')} />;

    // BAD
    const icon = this.props.active
      ? 'my-icon-active'
      : 'my-icon-inactive';
    <Image source={require('./' + icon + '.png')} />;

    // GOOD
    const icon = this.props.active
      ? require('./my-icon-active.png')
      : require('./my-icon-inactive.png');
    <Image source={icon} />;

 

Note that image sources required this way include size (width, height)
info for the Image. If you need to scale the image dynamically (i.e. via
flex), you may need to manually set
 {width: undefined, height: undefined} on the style attribute.

Static Non-Image Resources 

The  require syntax described above can be used to statically include
audio, video or document files in your project as well. Most common file
types are supported including  .mp3 ,  .wav ,  .mp4 ,  .mov ,  .html and
 .pdf . See bundler defaults for the full list.

You can add support for other types by adding an  assetExts resolver
option in your Metro configuration .

A caveat is that videos must use absolute positioning instead of
 flexGrow , since size info is not currently passed for non-image
assets. This limitation doesn't occur for videos that are linked
directly into Xcode or the Assets folder for Android.

Images From Hybrid App's Resources 

If you are building a hybrid app (some UIs in React Native, some UIs in
platform code) you can still use images that are already bundled into
the app.

For images included via Xcode asset catalogs or in the Android drawable
folder, use the image name without the extension:

    <Image
      source={{uri: 'app_icon'}}
      style={{width: 40, height: 40}}
    />

 

For images in the Android assets folder, use the  asset:/ scheme:

    <Image
      source={{uri: 'asset:/app_icon.png'}}
      style={{width: 40, height: 40}}
    />

 

These approaches provide no safety checks. It's up to you to guarantee
that those images are available in the application. Also you have to
specify image dimensions manually.

Network Images 

Many of the images you will display in your app will not be available at
compile time, or you will want to load some dynamically to keep the
binary size down. Unlike with static resources, you will need to
manually specify the dimensions of your image . It's highly recommended
that you use https as well in order to satisfy App Transport Security
requirements on iOS.

    // GOOD
    <Image source={{uri: 'https://reactjs.org/logo-og.png'}}
           style={{width: 400, height: 400}} />

    // BAD
    <Image source={{uri: 'https://reactjs.org/logo-og.png'}} />

 

Network Requests for Images 

If you would like to set such things as the HTTP-Verb, Headers or a Body
along with the image request, you may do this by defining these
properties on the source object:

    <Image
      source={{
        uri: 'https://reactjs.org/logo-og.png',
        method: 'POST',
        headers: {
          Pragma: 'no-cache',
        },
        body: 'Your Body goes here',
      }}
      style={{width: 400, height: 400}}
    />

 

URI Data Images 

Sometimes, you might be getting encoded image data from a REST API call.
You can use the  'data:' URI scheme to use these images. Same as for
network resources, you will need to manually specify the dimensions of
your image .

 info

This is recommended for very small and dynamic images only, like icons
in a list from a DB.

    // include at least width and height!
    <Image
      style={{
        width: 51,
        height: 51,
        resizeMode: 'contain',
      }}
      source={{
        uri: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==',
      }}
    />

 

Cache Control (iOS Only) 

In some cases you might only want to display an image if it is already
in the local cache, i.e. a low resolution placeholder until a higher
resolution is available. In other cases you do not care if the image is
outdated and are willing to display an outdated image to save bandwidth.
The  cache source property gives you control over how the network layer
interacts with the cache.

-    default : Use the native platforms default strategy.
-    reload : The data for the URL will be loaded from the originating
    source. No existing cache data should be used to satisfy a URL load
    request.
-    force-cache : The existing cached data will be used to satisfy the
    request, regardless of its age or expiration date. If there is no
    existing data in the cache corresponding the request, the data is
    loaded from the originating source.
-    only-if-cached : The existing cache data will be used to satisfy a
    request, regardless of its age or expiration date. If there is no
    existing data in the cache corresponding to a URL load request, no
    attempt is made to load the data from the originating source, and
    the load is considered to have failed.

    <Image
      source={{
        uri: 'https://reactjs.org/logo-og.png',
        cache: 'only-if-cached',
      }}
      style={{width: 400, height: 400}}
    />

 

Local Filesystem Images 

See CameraRoll for an example of using local resources that are outside
of  Images.xcassets .

Best Camera Roll Image 

iOS saves multiple sizes for the same image in your Camera Roll, it is
very important to pick the one that's as close as possible for
performance reasons. You wouldn't want to use the full quality 3264x2448
image as source when displaying a 200x200 thumbnail. If there's an exact
match, React Native will pick it, otherwise it's going to use the first
one that's at least 50% bigger in order to avoid blur when resizing from
a close size. All of this is done by default so you don't have to worry
about writing the tedious (and error prone) code to do it yourself.

Why Not Automatically Size Everything? 

In the browser if you don't give a size to an image, the browser is
going to render a 0x0 element, download the image, and then render the
image based with the correct size. The big issue with this behavior is
that your UI is going to jump all around as images load, this makes for
a very bad user experience.

In React Native this behavior is intentionally not implemented. It is
more work for the developer to know the dimensions (or aspect ratio) of
the remote image in advance, but we believe that it leads to a better
user experience. Static images loaded from the app bundle via the
 require('./my-icon.png') syntax can be automatically sized because
their dimensions are available immediately at the time of mounting.

For example, the result of  require('./my-icon.png') might be:

    {"__packager_asset":true,"uri":"my-icon.png","width":591,"height":573}

 

Source as an object 

In React Native, one interesting decision is that the  src attribute is
named  source and doesn't take a string but an object with a  uri
attribute.

    <Image source={{uri: 'something.jpg'}} />

 

On the infrastructure side, the reason is that it allows us to attach
metadata to this object. For example if you are using
 require('./my-icon.png') , then we add information about its actual
location and size (don't rely on this fact, it might change in the
future!). This is also future proofing, for example we may want to
support sprites at some point, instead of outputting  {uri: ...} , we
can output  {uri: ..., crop: {left: 10, top: 50, width: 20, height: 40}}
and transparently support spriting on all the existing call sites.

On the user side, this lets you annotate the object with useful
attributes such as the dimension of the image in order to compute the
size it's going to be displayed in. Feel free to use it as your data
structure to store more information about your image.

Background Image via Nesting 

A common feature request from developers familiar with the web is
 background-image . To handle this use case, you can use the
 <ImageBackground> component, which has the same props as  <Image> , and
add whatever children to it you would like to layer on top of it.

You might not want to use  <ImageBackground> in some cases, since the
implementation is basic. Refer to  <ImageBackground> 's documentation
for more insight, and create your own custom component when needed.

    return (
      <ImageBackground source={...} style={{width: '100%', height: '100%'}}>
        <Text>Inside</Text>
      </ImageBackground>
    );

 

Note that you must specify some width and height style attributes.

iOS Border Radius Styles 

Please note that the following corner specific, border radius style
properties might be ignored by iOS's image component:

-    borderTopLeftRadius
-    borderTopRightRadius
-    borderBottomLeftRadius
-    borderBottomRightRadius

Off-thread Decoding 

Image decoding can take more than a frame-worth of time. This is one of
the major sources of frame drops on the web because decoding is done in
the main thread. In React Native, image decoding is done in a different
thread. In practice, you already need to handle the case when the image
is not downloaded yet, so displaying the placeholder for a few more
frames while it is decoding does not require any code change.

Configuring iOS Image Cache Limits 

On iOS, we expose an API to override React Native's default image cache
limits. This should be called from within your native AppDelegate code
(e.g. within  didFinishLaunchingWithOptions ).

    RCTSetImageCacheLimits(4*1024*1024, 200*1024*1024);

 

Parameters:

  Name             Type     Required   Description
  ---------------- -------- ---------- -------------------------
  imageSizeLimit   number   Yes        Image cache size limit.
  totalCostLimit   number   Yes        Total cache cost limit.

In the above code example the image size limit is set to 4 MB and the
total cost limit is set to 200 MB.

# Image Style Props #
 ___                              ____  _         _      
|_ _|_ __ ___   __ _  __ _  ___  / ___|| |_ _   _| | ___ 
 | || '_ ` _ \ / _` |/ _` |/ _ \ \___ \| __| | | | |/ _ \
 | || | | | | | (_| | (_| |  __/  ___) | |_| |_| | |  __/
|___|_| |_| |_|\__,_|\__, |\___| |____/ \__|\__, |_|\___|
                     |___/                  |___/        
 ____                      
|  _ \ _ __ ___  _ __  ___ 
| |_) | '__/ _ \| '_ \/ __|
|  __/| | | (_) | |_) \__ \
|_|   |_|  \___/| .__/|___/
                |_|        
-   Examples
    -   Image Resize Mode
    -   Image Border
    -   Image Border Radius
    -   Image Tint
-   Props
    -    backfaceVisibility
    -    backgroundColor
    -    borderBottomLeftRadius
    -    borderBottomRightRadius
    -    borderColor
    -    borderRadius
    -    borderTopLeftRadius
    -    borderTopRightRadius
    -    borderWidth
    -    opacity
    -    overflow
    -    overlayColor
        Android
    -    resizeMode
    -    objectFit
    -    tintColor
Image Style Props

Examples 

Image Resize Mode 

Image Border 

Image Border Radius 

Image Tint 

Reference

Props 

 backfaceVisibility 

The property defines whether or not the back face of a rotated image
should be visible.

  Type                             Default
  -------------------------------- ------------
  enum(  'visible' ,  'hidden' )    'visible'

------------------------------------------------------------------------

 backgroundColor 

  Type
  -------
  color

------------------------------------------------------------------------

 borderBottomLeftRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderBottomRightRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderColor 

  Type
  -------
  color

------------------------------------------------------------------------

 borderRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderTopLeftRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderTopRightRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderWidth 

  Type
  --------
  number

------------------------------------------------------------------------

 opacity 

Set an opacity value for the image. The number should be in the range
from  0.0 to  1.0 .

  Type     Default
  -------- ---------
  number    1.0

------------------------------------------------------------------------

 overflow 

  Type                             Default
  -------------------------------- ------------
  enum(  'visible' ,  'hidden' )    'visible'

------------------------------------------------------------------------

 overlayColor

Android



When the image has rounded corners, specifying an overlayColor will
cause the remaining space in the corners to be filled with a solid
color. This is useful in cases which are not supported by the Android
implementation of rounded corners:

-   Certain resize modes, such as  'contain'
-   Animated GIFs

A typical way to use this prop is with images displayed on a solid
background and setting the  overlayColor to the same color as the
background.

For details of how this works under the hood, see Fresco documentation .

  Type
  --------
  string

------------------------------------------------------------------------

 resizeMode 

Determines how to resize the image when the frame doesn't match the raw
image dimensions. Defaults to  cover .

-    cover : Scale the image uniformly (maintain the image's aspect
    ratio) so that:

    -   Both dimensions (width and height) of the image will be equal to
        or larger than the corresponding dimension of the view (minus
        padding)
    -   At least one dimension of the scaled image will be equal to the
        corresponding dimension of the view (minus padding)

-    contain : Scale the image uniformly (maintain the image's aspect
    ratio) so that both dimensions (width and height) of the image will
    be equal to or less than the corresponding dimension of the view
    (minus padding).

-    stretch : Scale width and height independently, This may change the
    aspect ratio of the src.

-    repeat : Repeat the image to cover the frame of the view. The image
    will keep its size and aspect ratio, unless it is larger than the
    view, in which case it will be scaled down uniformly so that it is
    contained in the view.

-    center : Center the image in the view along both dimensions. If the
    image is larger than the view, scale it down uniformly so that it is
    contained in the view.

  Type                                                                 Default
  -------------------------------------------------------------------- ----------
  enum(  'cover' ,  'contain' ,  'stretch' ,  'repeat' ,  'center' )    'cover'

------------------------------------------------------------------------

 objectFit 

Determines how to resize the image when the frame doesn't match the raw
image dimensions.

  Type                                                      Default
  --------------------------------------------------------- ----------
  enum(  'cover' ,  'contain' ,  'fill' ,  'scale-down' )    'cover'

------------------------------------------------------------------------

 tintColor 

Changes the color of all the non-transparent pixels to the tintColor.

  Type
  -------
  color

# Improving User Experience #
 ___                                _               _   _               
|_ _|_ __ ___  _ __  _ __ _____   _(_)_ __   __ _  | | | |___  ___ _ __ 
 | || '_ ` _ \| '_ \| '__/ _ \ \ / / | '_ \ / _` | | | | / __|/ _ \ '__|
 | || | | | | | |_) | | | (_) \ V /| | | | | (_| | | |_| \__ \  __/ |   
|___|_| |_| |_| .__/|_|  \___/ \_/ |_|_| |_|\__, |  \___/|___/\___|_|   
              |_|                           |___/                       
 _____                      _                     
| ____|_  ___ __   ___ _ __(_) ___ _ __   ___ ___ 
|  _| \ \/ / '_ \ / _ \ '__| |/ _ \ '_ \ / __/ _ \
| |___ >  <| |_) |  __/ |  | |  __/ | | | (_|  __/
|_____/_/\_\ .__/ \___|_|  |_|\___|_| |_|\___\___|
           |_|                                    
-   Configure text inputs
-   Manage layout when keyboard is visible
-   Make tappable areas larger
-   Use Android Ripple
-   Screen orientation lock
Improving User Experience

Configure text inputs 

Entering text on touch phone is a challenge - small screen, software
keyboard. But based on what kind of data you need, you can make it
easier by properly configuring the text inputs:

-   Focus the first field automatically
-   Use placeholder text as an example of expected data format
-   Enable or disable autocapitalization and autocorrect
-   Choose keyboard type (e.g. email, numeric)
-   Make sure the return button focuses the next field or submits the
    form

Check out  TextInput docs for more configuration options.

-   TypeScript
-   JavaScript

Manage layout when keyboard is visible 

Software keyboard takes almost half of the screen. If you have
interactive elements that can get covered by the keyboard, make sure
they are still accessible by using the  KeyboardAvoidingView component .

-   TypeScript
-   JavaScript

Make tappable areas larger 

On mobile phones it's hard to be very precise when pressing buttons.
Make sure all interactive elements are 44x44 or larger. One way to do
this is to leave enough space for the element,  padding ,  minWidth and
 minHeight style values can be useful for that. Alternatively, you can
use  hitSlop prop to increase interactive area without affecting the
layout. Here's a demo:

Use Android Ripple 

Android API 21+ uses the material design ripple to provide user with
feedback when they touch an interactable area on the screen. React
Native exposes this through the  TouchableNativeFeedback component .
Using this touchable effect instead of opacity or highlight will often
make your app feel much more fitting on the platform. That said, you
need to be careful when using it because it doesn't work on iOS or on
Android API < 21, so you will need to fallback to using one of the other
Touchable components on iOS. You can use a library like
react-native-platform-touchable to handle the platform differences for
you.

Screen orientation lock 

Multiple screen orientations should work fine by default unless you're
using  Dimensions API and don't handle orientation changes. If you don't
want to support multiple screen orientations, you can lock the screen
orientation to either portrait or landscape.

On iOS, in the General tab and Deployment Info section of Xcode enable
the Device Orientation you want to support (ensure you have selected
iPhone from the Devices menu when making the changes). For Android, open
the AndroidManifest.xml file and within the activity element add
 'android:screenOrientation="portrait"' to lock to portrait or
 'android:screenOrientation="landscape"' to lock to landscape.

Learn more

Material Design and Human Interface Guidelines are great resources for
learning more about designing for mobile platforms.

# InputAccessoryView #
 ___                   _      _                                          
|_ _|_ __  _ __  _   _| |_   / \   ___ ___ ___  ___ ___  ___  _ __ _   _ 
 | || '_ \| '_ \| | | | __| / _ \ / __/ __/ _ \/ __/ __|/ _ \| '__| | | |
 | || | | | |_) | |_| | |_ / ___ \ (_| (_|  __/\__ \__ \ (_) | |  | |_| |
|___|_| |_| .__/ \__,_|\__/_/   \_\___\___\___||___/___/\___/|_|   \__, |
          |_|                                                      |___/ 
__     ___               
\ \   / (_) _____      __
 \ \ / /| |/ _ \ \ /\ / /
  \ V / | |  __/\ V  V / 
   \_/  |_|\___| \_/\_/  
                         
-   Props
    -    backgroundColor
    -    nativeID
    -    style
InputAccessoryView

A component which enables customization of the keyboard input accessory
view on iOS. The input accessory view is displayed above the keyboard
whenever a  TextInput has focus. This component can be used to create
custom toolbars.

To use this component wrap your custom toolbar with the
InputAccessoryView component, and set a  nativeID . Then, pass that
 nativeID as the  inputAccessoryViewID of whatever  TextInput you
desire. A basic example:

This component can also be used to create sticky text inputs (text
inputs which are anchored to the top of the keyboard). To do this, wrap
a  TextInput with the  InputAccessoryView component, and don't set a
 nativeID . For an example, look at InputAccessoryViewExample.js .

------------------------------------------------------------------------

Reference

Props 

 backgroundColor 

  Type
  -------
  color

------------------------------------------------------------------------

 nativeID 

An ID which is used to associate this  InputAccessoryView to specified
TextInput(s).

  Type
  --------
  string

------------------------------------------------------------------------

 style 

  Type
  ------------
  View Style

Known issues

-   react-native#18997 : Doesn't support multiline  TextInput
-   react-native#20157 : Can't use with a bottom tab bar

# Integration with an Android Fragment #
 ___       _                       _   _                        _ _   _     
|_ _|_ __ | |_ ___  __ _ _ __ __ _| |_(_) ___  _ __   __      _(_) |_| |__  
 | || '_ \| __/ _ \/ _` | '__/ _` | __| |/ _ \| '_ \  \ \ /\ / / | __| '_ \ 
 | || | | | ||  __/ (_| | | | (_| | |_| | (_) | | | |  \ V  V /| | |_| | | |
|___|_| |_|\__\___|\__, |_|  \__,_|\__|_|\___/|_| |_|   \_/\_/ |_|\__|_| |_|
                   |___/                                                    
                  _              _           _     _ 
  __ _ _ __      / \   _ __   __| |_ __ ___ (_) __| |
 / _` | '_ \    / _ \ | '_ \ / _` | '__/ _ \| |/ _` |
| (_| | | | |  / ___ \| | | | (_| | | | (_) | | (_| |
 \__,_|_| |_| /_/   \_\_| |_|\__,_|_|  \___/|_|\__,_|
                                                     
 _____                                     _   
|  ___| __ __ _  __ _ _ __ ___   ___ _ __ | |_ 
| |_ | '__/ _` |/ _` | '_ ` _ \ / _ \ '_ \| __|
|  _|| | | (_| | (_| | | | | | |  __/ | | | |_ 
|_|  |_|  \__,_|\__, |_| |_| |_|\___|_| |_|\__|
                |___/                          
-   1. Add React Native to your app
-   2. Integrating your App with a React Native Fragment
-   Step 3. Add a FrameLayout for the React Native Fragment
-   Step 4. Add a React Native Fragment to the FrameLayout
-   Step 5. Test your integration
-   Step 6. Additional setup - Native modules
Integration with an Android Fragment

The guide for Integration with Existing Apps details how to integrate a
full-screen React Native app into an existing Android app as an
Activity. To use React Native components within Fragments in an existing
app requires some additional setup. The benefit of this is that it
allows for a native app to integrate React Native components alongside
native fragments in an Activity.

1. Add React Native to your app 

Follow the guide for Integration with Existing Apps until the Code
integration section. Continue to follow Step 1. Create an
 index.android.js file and Step 2. Add your React Native code from this
section.

2. Integrating your App with a React Native Fragment 

You can render your React Native component into a Fragment instead of a
full screen React Native Activity. The component may be termed a
"screen" or "fragment" and it will function in the same manner as an
Android fragment, likely containing child components. These components
can be placed in a  /fragments folder and the child components used to
compose the fragment can be placed in a  /components folder.

You will need to implement the  ReactApplication interface in your main
Application Java/Kotlin class. If you have created a new project from
Android Studio with a default activity, you will need to create a new
class (e.g.  MyReactApplication.java or  MyReactApplication.kt ). If it
is an existing class you can find this main class in your
 AndroidManifest.xml file. Under the  <application /> tag you should see
a property  android:name e.g.  android:name=".MyReactApplication" . This
value is the class you want to implement and provide the required
methods to.

Ensure your main Application class implements ReactApplication:

-   Java
-   Kotlin

    class MyReactApplication: Application(), ReactApplication {...}

 

    public class MyReactApplication extends Application implements ReactApplication {...}

 

Override the required methods  getUseDeveloperSupport ,  getPackages and
 getReactNativeHost :

-   Java
-   Kotlin

    class MyReactApplication : Application(), ReactApplication {
        override fun onCreate() {
            super.onCreate()
            SoLoader.init(this, false)
        }
        private val reactNativeHost =
            object : DefaultReactNativeHost(this) {
                override fun getUseDeveloperSupport() = BuildConfig.DEBUG
                override fun getPackages(): List<ReactPackage> {
                    val packages = PackageList(this).getPackages().toMutableList()
                    // Packages that cannot be autolinked yet can be added manually here
                    return packages
                }
            }
        override fun getReactNativeHost(): ReactNativeHost = reactNativeHost
    }

 

    public class MyReactApplication extends Application implements ReactApplication {
        @Override
        public void onCreate() {
            super.onCreate();
            SoLoader.init(this, false);
        }

        private final ReactNativeHost mReactNativeHost = new DefaultReactNativeHost(this) {
            @Override
            public boolean getUseDeveloperSupport() {
                return BuildConfig.DEBUG;
            }

            protected List<ReactPackage> getPackages() {
                List<ReactPackage> packages = new PackageList(this).getPackages();
                // Packages that cannot be autolinked yet can be added manually here
                return packages;
            }
        };

        @Override
        public ReactNativeHost getReactNativeHost() {
            return mReactNativeHost;
        }
    }

 

If you are using Android Studio, use Alt + Enter to add all missing
imports in your class. Alternatively these are the required imports to
include manually:

-   Java
-   Kotlin

    import android.app.Application

    import com.facebook.react.PackageList
    import com.facebook.react.ReactApplication
    import com.facebook.react.ReactNativeHost
    import com.facebook.react.ReactPackage
    import com.facebook.react.defaults.DefaultReactNativeHost
    import com.facebook.soloader.SoLoader

 

    import android.app.Application;

    import com.facebook.react.PackageList;
    import com.facebook.react.ReactApplication;
    import com.facebook.react.ReactNativeHost;
    import com.facebook.react.ReactPackage;
    import com.facebook.react.defaults.DefaultReactNativeHost;
    import com.facebook.soloader.SoLoader;

    import java.util.List;

 

Perform a "Sync Project files with Gradle" operation.

Step 3. Add a FrameLayout for the React Native Fragment 

You will now add your React Native Fragment to an Activity. For a new
project this Activity will be  MainActivity but it could be any Activity
and more fragments can be added to additional Activities as you
integrate more React Native components into your app.

First add the React Native Fragment to your Activity's layout. For
example  main_activity.xml in the  res/layouts folder.

Add a  <FrameLayout> with an id, width and height. This is the layout
you will find and render your React Native Fragment into.

    <FrameLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:id="@+id/reactNativeFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

 

Step 4. Add a React Native Fragment to the FrameLayout 

To add your React Native Fragment to your layout you need to have an
Activity. As mentioned in a new project this will be  MainActivity . In
this Activity add a button and an event listener. On button click you
will render your React Native Fragment.

Modify your Activity layout to add the button:

    <Button
        android:layout_margin="10dp"
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Show react fragment" />

 

Now in your Activity class (e.g.  MainActivity.java or  MainActivity.kt
) you need to add an  OnClickListener for the button, instantiate your
 ReactFragment and add it to the frame layout.

Add the button field to the top of your Activity:

-   Java
-   Kotlin

    private lateinit var button: Button

 

    private Button mButton;

 

Update your Activity's  onCreate method as follows:

-   Java
-   Kotlin

    override fun onCreate(savedInstanceState: Bundle) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.main_activity)
        button = findViewById<Button>(R.id.button)
        button.setOnClickListener {
            val reactNativeFragment = ReactFragment.Builder()
                    .setComponentName("HelloWorld")
                    .setLaunchOptions(getLaunchOptions("test message"))
                    .build()
            getSupportFragmentManager()
                    .beginTransaction()
                    .add(R.id.reactNativeFragment, reactNativeFragment)
                    .commit()
        }
    }

 

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main_activity);

        mButton = findViewById(R.id.button);
        mButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                Fragment reactNativeFragment = new ReactFragment.Builder()
                        .setComponentName("HelloWorld")
                        .setLaunchOptions(getLaunchOptions("test message"))
                        .build();

                getSupportFragmentManager()
                        .beginTransaction()
                        .add(R.id.reactNativeFragment, reactNativeFragment)
                        .commit();

            }
        });
    }

 

In the code above
 Fragment reactNativeFragment = new ReactFragment.Builder() creates the
ReactFragment and  getSupportFragmentManager().beginTransaction().add()
adds the Fragment to the Frame Layout.

If you are using a starter kit for React Native, replace the
"HelloWorld" string with the one in your  index.js or  index.android.js
file (it’s the first argument to the AppRegistry.registerComponent()
method).

Add the  getLaunchOptions method which will allow you to pass props
through to your component. This is optional and you can remove
 setLaunchOptions if you don't need to pass any props.

-   Java
-   Kotlin

    private fun getLaunchOptions(message: String) = Bundle().apply {
        putString("message", message)
    }

 

    private Bundle getLaunchOptions(String message) {
        Bundle initialProperties = new Bundle();
        initialProperties.putString("message", message);
        return initialProperties;
    }

 

Add all missing imports in your Activity class. Be careful to use your
package’s BuildConfig and not the one from the facebook package!
Alternatively these are the required imports to include manually:

-   Java
-   Kotlin

    import android.app.Application

    import com.facebook.react.ReactApplication
    import com.facebook.react.ReactNativeHost
    import com.facebook.react.ReactPackage
    import com.facebook.react.shell.MainReactPackage
    import com.facebook.soloader.SoLoader

 

    import android.app.Application;

    import com.facebook.react.ReactApplication;
    import com.facebook.react.ReactNativeHost;
    import com.facebook.react.ReactPackage;
    import com.facebook.react.shell.MainReactPackage;
    import com.facebook.soloader.SoLoader;

 

Perform a "Sync Project files with Gradle" operation.

Step 5. Test your integration 

Make sure you run  yarn to install your react-native dependencies and
run  yarn native to start the metro bundler. Run your android app in
Android Studio and it should load the JavaScript code from the
development server and display it in your React Native Fragment in the
Activity.

Step 6. Additional setup - Native modules 

You may need to call out to existing Java/Kotlin code from your react
component. Native modules allow you to call out to native code and run
methods in your native app. Follow the setup here native-modules-android

# Integration with Existing Apps #
 ___       _                       _   _                        _ _   _     
|_ _|_ __ | |_ ___  __ _ _ __ __ _| |_(_) ___  _ __   __      _(_) |_| |__  
 | || '_ \| __/ _ \/ _` | '__/ _` | __| |/ _ \| '_ \  \ \ /\ / / | __| '_ \ 
 | || | | | ||  __/ (_| | | | (_| | |_| | (_) | | | |  \ V  V /| | |_| | | |
|___|_| |_|\__\___|\__, |_|  \__,_|\__|_|\___/|_| |_|   \_/\_/ |_|\__|_| |_|
                   |___/                                                    
 _____      _     _   _                  _                    
| ____|_  _(_)___| |_(_)_ __   __ _     / \   _ __  _ __  ___ 
|  _| \ \/ / / __| __| | '_ \ / _` |   / _ \ | '_ \| '_ \/ __|
| |___ >  <| \__ \ |_| | | | | (_| |  / ___ \| |_) | |_) \__ \
|_____/_/\_\_|___/\__|_|_| |_|\__, | /_/   \_\ .__/| .__/|___/
                              |___/          |_|   |_|        

Integration with Existing Apps

React Native is great when you are starting a new mobile app from
scratch. However, it also works well for adding a single view or user
flow to existing native applications. With a few steps, you can add new
React Native based features, screens, views, etc.

The specific steps are different depending on what platform you're
targeting.

-   Android (Kotlin)
-   Android (Java)
-   iOS (Objective-C)
-   iOS (Swift)

Key Concepts 

The keys to integrating React Native components into your Android
application are to:

1.  Set up React Native dependencies and directory structure.
2.  Develop your React Native components in JavaScript.
3.  Add a  ReactRootView to your Android app. This view will serve as
    the container for your React Native component.
4.  Start the React Native server and run your native application.
5.  Verify that the React Native aspect of your application works as
    expected.

Prerequisites 

Follow the React Native CLI Quickstart in the environment setup guide to
configure your development environment for building React Native apps
for Android.

1. Set up directory structure 

To ensure a smooth experience, create a new folder for your integrated
React Native project, then copy your existing Android project to an
 /android subfolder.

2. Install JavaScript dependencies 

Go to the root directory for your project and create a new  package.json
file with the following contents:

    {
      "name": "MyReactNativeApp",
      "version": "0.0.1",
      "private": true,
      "scripts": {
        "start": "yarn react-native start"
      }
    }

 

Next, install the  react and  react-native packages. Open a terminal or
command prompt, then navigate to the directory with your  package.json
file and run:

-   npm
-   Yarn

    npm install react-native

 

    yarn add react-native

 

This will print a message similar to the following (scroll up in the
installation command output to see it):

  warning "  react-native@0.70.5 " has unmet peer dependency "
   react@18.1.0 "

This is OK, it means we also need to install React:

-   npm
-   Yarn

    npm install react@version_printed_above

 

    yarn add react@version_printed_above

 

Installation process has created a new  /node_modules folder. This
folder stores all the JavaScript dependencies required to build your
project.

Add  node_modules/ to your  .gitignore file.

Adding React Native to your app 

Configuring Gradle 

React Native uses the React Native Gradle Plugin to configure your
dependencies and project setup.

First, let's edit your  settings.gradle file by adding this line:

    includeBuild('../node_modules/@react-native/gradle-plugin')

 

Then you need to open your top level  build.gradle and include this
line:

    buildscript {
        repositories {
            google()
            mavenCentral()
        }
        dependencies {
            classpath("com.android.tools.build:gradle:7.3.1")
    +       classpath("com.facebook.react:react-native-gradle-plugin")
        }
    }

 

This makes sure the React Native Gradle Plugin is available inside your
project. Finally, add those lines inside your app's  build.gradle file
(it's a different  build.gradle file inside your app folder):

    apply plugin: "com.android.application"
    +apply plugin: "com.facebook.react"

    repositories {
        mavenCentral()
    }

    dependencies {
        // Other dependencies here
    +   implementation "com.facebook.react:react-android"
    +   implementation "com.facebook.react:hermes-android"
    }

 

Those depedencies are available on  mavenCentral() so make sure you have
it defined in your  repositories{} block.

 info

We intentionally don't specify the version for those  implementation
dependencies as the React Native Gradle Plugin will take care of it. If
you don't use the React Native Gradle Plugin, you'll have to specify
version manually.

Enable native modules autolinking 

To use the power of autolinking , we have to apply it a few places.
First add the following entry to  settings.gradle :

    apply from: file("../node_modules/@react-native-community/cli-platform-android/native_modules.gradle"); applyNativeModulesSettingsGradle(settings)

 

Next add the following entry at the very bottom of the  app/build.gradle
:

    apply from: file("../../node_modules/@react-native-community/cli-platform-android/native_modules.gradle"); applyNativeModulesAppBuildGradle(project)

 

Configuring permissions 

Next, make sure you have the Internet permission in your
 AndroidManifest.xml :

    <uses-permission android:name="android.permission.INTERNET" />

 

If you need to access to the  DevSettingsActivity add to your
 AndroidManifest.xml :

    <activity android:name="com.facebook.react.devsupport.DevSettingsActivity" />

 

This is only used in dev mode when reloading JavaScript from the
development server, so you can strip this in release builds if you need
to.

Cleartext Traffic (API level 28+) 

  Starting with Android 9 (API level 28), cleartext traffic is disabled
  by default; this prevents your application from connecting to the
  Metro bundler . The changes below allow cleartext traffic in debug
  builds.

1. Apply the  usesCleartextTraffic option to your Debug  AndroidManifest.xml 

    <!-- ... -->
    <application
      android:usesCleartextTraffic="true" tools:targetApi="28" >
      <!-- ... -->
    </application>
    <!-- ... -->

 

This is not required for Release builds.

To learn more about Network Security Config and the cleartext traffic
policy see this link .

Code integration 

Now we will actually modify the native Android application to integrate
React Native.

The React Native component 

The first bit of code we will write is the actual React Native code for
the new "High Score" screen that will be integrated into our
application.

1. Create a  index.js file 

First, create an empty  index.js file in the root of your React Native
project.

 index.js is the starting point for React Native applications, and it is
always required. It can be a small file that  require s other file that
are part of your React Native component or application, or it can
contain all the code that is needed for it. In our case, we will put
everything in  index.js .

2. Add your React Native code 

In your  index.js , create your component. In our sample here, we will
add a  <Text> component within a styled  <View> :

    import React from 'react';
    import {AppRegistry, StyleSheet, Text, View} from 'react-native';

    const HelloWorld = () => {
      return (
        <View style={styles.container}>
          <Text style={styles.hello}>Hello, World</Text>
        </View>
      );
    };
    const styles = StyleSheet.create({
      container: {
        flex: 1,
        justifyContent: 'center',
      },
      hello: {
        fontSize: 20,
        textAlign: 'center',
        margin: 10,
      },
    });

    AppRegistry.registerComponent(
      'MyReactNativeApp',
      () => HelloWorld,
    );

 

3. Configure permissions for development error overlay 

If your app is targeting the Android  API level 23 or greater, make sure
you have the permission  android.permission.SYSTEM_ALERT_WINDOW enabled
for the development build. You can check this with
 Settings.canDrawOverlays(this) . This is required in dev builds because
React Native development errors must be displayed above all the other
windows. Due to the new permissions system introduced in the API level
23 (Android M), the user needs to approve it. This can be achieved by
adding the following code to your Activity's in  onCreate() method.

    companion object {
        const val OVERLAY_PERMISSION_REQ_CODE = 1  // Choose any value
    }

    ...

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        if(!Settings.canDrawOverlays(this)) {
            val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                                        Uri.parse("package: $packageName"))
            startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE);
        }
    }

 

Finally, the  onActivityResult() method (as shown in the code below) has
to be overridden to handle the permission Accepted or Denied cases for
consistent UX. Also, for integrating Native Modules which use
 startActivityForResult , we need to pass the result to the
 onActivityResult method of our  ReactInstanceManager instance.

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        if (requestCode == OVERLAY_PERMISSION_REQ_CODE) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                if (!Settings.canDrawOverlays(this)) {
                    // SYSTEM_ALERT_WINDOW permission not granted
                }
            }
        }
        reactInstanceManager?.onActivityResult(this, requestCode, resultCode, data)
    }

 

The Magic:  ReactRootView 

Let's add some native code in order to start the React Native runtime
and tell it to render our JS component. To do this, we're going to
create an  Activity that creates a  ReactRootView , starts a React
application inside it and sets it as the main content view.

  If you are targeting Android version <5, use the  AppCompatActivity
  class from the  com.android.support:appcompat package instead of
   Activity .

    class MyReactActivity : Activity(), DefaultHardwareBackBtnHandler {
        private lateinit var reactRootView: ReactRootView
        private lateinit var reactInstanceManager: ReactInstanceManager
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            SoLoader.init(this, false)
            reactRootView = ReactRootView(this)
            val packages: List<ReactPackage> = PackageList(application).packages
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // packages.add(MyReactNativePackage())
            // Remember to include them in `settings.gradle` and `app/build.gradle` too.
            reactInstanceManager = ReactInstanceManager.builder()
                .setApplication(application)
                .setCurrentActivity(this)
                .setBundleAssetName("index.android.bundle")
                .setJSMainModulePath("index")
                .addPackages(packages)
                .setUseDeveloperSupport(BuildConfig.DEBUG)
                .setInitialLifecycleState(LifecycleState.RESUMED)
                .build()
            // The string here (e.g. "MyReactNativeApp") has to match
            // the string in AppRegistry.registerComponent() in index.js
            reactRootView?.startReactApplication(reactInstanceManager, "MyReactNativeApp", null)
            setContentView(reactRootView)
        }

        override fun invokeDefaultOnBackPressed() {
            super.onBackPressed()
        }
    }

 

  If you are using a starter kit for React Native, replace the
  "HelloWorld" string with the one in your index.js file (it’s the first
  argument to the  AppRegistry.registerComponent() method).

Perform a “Sync Project files with Gradle” operation.

If you are using Android Studio, use  Alt + Enter to add all missing
imports in your MyReactActivity class. Be careful to use your package’s
 BuildConfig and not the one from the  facebook package.

We need set the theme of  MyReactActivity to
 Theme.AppCompat.Light.NoActionBar because some React Native UI
components rely on this theme.

    <activity
      android:name=".MyReactActivity"
      android:label="@string/app_name"
      android:theme="@style/Theme.AppCompat.Light.NoActionBar">
    </activity>

 

  A  ReactInstanceManager can be shared by multiple activities and/or
  fragments. You will want to make your own  ReactFragment or
   ReactActivity and have a singleton holder that holds a
   ReactInstanceManager . When you need the  ReactInstanceManager (e.g.,
  to hook up the  ReactInstanceManager to the lifecycle of those
  Activities or Fragments) use the one provided by the singleton.

Next, we need to pass some activity lifecycle callbacks to the
 ReactInstanceManager and  ReactRootView :

    override fun onPause() {
        super.onPause()
        reactInstanceManager.onHostPause(this)
    }

    override fun onResume() {
        super.onResume()
        reactInstanceManager.onHostResume(this, this)
    }

    override fun onDestroy() {
        super.onDestroy()
        reactInstanceManager.onHostDestroy(this)
        reactRootView.unmountReactApplication()
    }

 

We also need to pass back button events to React Native:

    override fun onBackPressed() {
        reactInstanceManager.onBackPressed()
        super.onBackPressed()
    }

 

This allows JavaScript to control what happens when the user presses the
hardware back button (e.g. to implement navigation). When JavaScript
doesn't handle the back button press, your  invokeDefaultOnBackPressed
method will be called. By default this finishes your  Activity .

Finally, we need to hook up the dev menu. By default, this is activated
by (rage) shaking the device, but this is not very useful in emulators.
So we make it show when you press the hardware menu button (use Ctrl  +
M if you're using Android Studio emulator):

    override fun onKeyUp(keyCode: Int, event: KeyEvent?): Boolean {
        if (keyCode == KeyEvent.KEYCODE_MENU && reactInstanceManager != null) {
            reactInstanceManager.showDevOptionsDialog()
            return true
        }
        return super.onKeyUp(keyCode, event)
    }

 

Now your activity is ready to run some JavaScript code.

Test your integration 

You have now done all the basic steps to integrate React Native with
your current application. Now we will start the Metro bundler to build
the  index.bundle package and the server running on localhost to serve
it.

1. Run the packager 

To run your app, you need to first start the development server. To do
this, run the following command in the root directory of your React
Native project:

-   npm
-   Yarn

    npm start

 

    yarn start

 

2. Run the app 

Now build and run your Android app as normal.

Once you reach your React-powered activity inside the app, it should
load the JavaScript code from the development server and display:

[Screenshot]

Creating a release build in Android Studio 

You can use Android Studio to create your release builds too! It’s as
quick as creating release builds of your previously-existing native
Android app.

If you use the React Native Gradle Plugin as described above, everything
should work when running app from Android Studio.

If you're not using the React Native Gradle Plugin, there’s one
additional step which you’ll have to do before every release build. You
need to execute the following to create a React Native bundle, which
will be included with your native Android app:

    $ npx react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/com/your-company-name/app-package-name/src/main/assets/index.android.bundle --assets-dest android/com/your-company-name/app-package-name/src/main/res/

 

  Don’t forget to replace the paths with correct ones and create the
  assets folder if it doesn’t exist.

Now, create a release build of your native app from within Android
Studio as usual and you should be good to go!

Now what? 

At this point you can continue developing your app as usual. Refer to
our debugging and deployment docs to learn more about working with React
Native.

Key Concepts 

The keys to integrating React Native components into your Android
application are to:

1.  Set up React Native dependencies and directory structure.
2.  Develop your React Native components in JavaScript.
3.  Add a  ReactRootView to your Android app. This view will serve as
    the container for your React Native component.
4.  Start the React Native server and run your native application.
5.  Verify that the React Native aspect of your application works as
    expected.

Prerequisites 

Follow the React Native CLI Quickstart in the environment setup guide to
configure your development environment for building React Native apps
for Android.

1. Set up directory structure 

To ensure a smooth experience, create a new folder for your integrated
React Native project, then copy your existing Android project to an
 /android subfolder.

2. Install JavaScript dependencies 

Go to the root directory for your project and create a new  package.json
file with the following contents:

    {
      "name": "MyReactNativeApp",
      "version": "0.0.1",
      "private": true,
      "scripts": {
        "start": "react-native start"
      }
    }

 

Next, install the  react and  react-native packages. Open a terminal or
command prompt, then navigate to the directory with your  package.json
file and run:

-   npm
-   Yarn

    npm install react-native

 

    yarn add react-native

 

This will print a message similar to the following (scroll up in the
installation command output to see it):

  warning "  react-native@0.70.5 " has unmet peer dependency "
   react@18.1.0 "

This is OK, it means we also need to install React:

-   npm
-   Yarn

    npm install react@version_printed_above

 

    yarn add react@version_printed_above

 

Installation process has created a new  /node_modules folder. This
folder stores all the JavaScript dependencies required to build your
project.

Add  node_modules/ to your  .gitignore file.

Adding React Native to your app 

Configuring Gradle 

React Native uses the React Native Gradle Plugin to configure your
dependencies and project setup.

First, let's edit your  settings.gradle file by adding this line:

    includeBuild('../node_modules/@react-native/gradle-plugin')

 

Then you need to open your top level  build.gradle and include this
line:

    buildscript {
        repositories {
            google()
            mavenCentral()
        }
        dependencies {
            classpath("com.android.tools.build:gradle:7.3.1")
    +       classpath("com.facebook.react:react-native-gradle-plugin")
        }
    }

 

This makes sure the React Native Gradle Plugin is available inside your
project. Finally, add those lines inside your app's  build.gradle file
(it's a different  build.gradle file inside your app folder):

    apply plugin: "com.android.application"
    +apply plugin: "com.facebook.react"

    repositories {
        mavenCentral()
    }

    dependencies {
        // Other dependencies here
    +   implementation "com.facebook.react:react-android"
    +   implementation "com.facebook.react:hermes-android"
    }

 

Those depedencies are available on  mavenCentral() so make sure you have
it defined in your  repositories{} block.

 info

We intentionally don't specify the version for those  implementation
dependencies as the React Native Gradle Plugin will take care of it. If
you don't use the React Native Gradle Plugin, you'll have to specify
version manually.

Enable native modules autolinking 

To use the power of autolinking , we have to apply it a few places.
First add the following entry to  settings.gradle :

    apply from: file("../node_modules/@react-native-community/cli-platform-android/native_modules.gradle"); applyNativeModulesSettingsGradle(settings)

 

Next add the following entry at the very bottom of the  app/build.gradle
:

    apply from: file("../../node_modules/@react-native-community/cli-platform-android/native_modules.gradle"); applyNativeModulesAppBuildGradle(project)

 

Configuring permissions 

Next, make sure you have the Internet permission in your
 AndroidManifest.xml :

    <uses-permission android:name="android.permission.INTERNET" />

 

If you need to access to the  DevSettingsActivity add to your
 AndroidManifest.xml :

    <activity android:name="com.facebook.react.devsupport.DevSettingsActivity" />

 

This is only used in dev mode when reloading JavaScript from the
development server, so you can strip this in release builds if you need
to.

Cleartext Traffic (API level 28+) 

  Starting with Android 9 (API level 28), cleartext traffic is disabled
  by default; this prevents your application from connecting to the
  Metro bundler . The changes below allow cleartext traffic in debug
  builds.

1. Apply the  usesCleartextTraffic option to your Debug  AndroidManifest.xml 

    <!-- ... -->
    <application
      android:usesCleartextTraffic="true" tools:targetApi="28" >
      <!-- ... -->
    </application>
    <!-- ... -->

 

This is not required for Release builds.

To learn more about Network Security Config and the cleartext traffic
policy see this link .

Code integration 

Now we will actually modify the native Android application to integrate
React Native.

The React Native component 

The first bit of code we will write is the actual React Native code for
the new "High Score" screen that will be integrated into our
application.

1. Create a  index.js file 

First, create an empty  index.js file in the root of your React Native
project.

 index.js is the starting point for React Native applications, and it is
always required. It can be a small file that  require s other file that
are part of your React Native component or application, or it can
contain all the code that is needed for it. In our case, we will put
everything in  index.js .

2. Add your React Native code 

In your  index.js , create your component. In our sample here, we will
add a  <Text> component within a styled  <View> :

    import React from 'react';
    import {AppRegistry, StyleSheet, Text, View} from 'react-native';

    const HelloWorld = () => {
      return (
        <View style={styles.container}>
          <Text style={styles.hello}>Hello, World</Text>
        </View>
      );
    };
    const styles = StyleSheet.create({
      container: {
        flex: 1,
        justifyContent: 'center',
      },
      hello: {
        fontSize: 20,
        textAlign: 'center',
        margin: 10,
      },
    });

    AppRegistry.registerComponent(
      'MyReactNativeApp',
      () => HelloWorld,
    );

 

3. Configure permissions for development error overlay 

If your app is targeting the Android  API level 23 or greater, make sure
you have the permission  android.permission.SYSTEM_ALERT_WINDOW enabled
for the development build. You can check this with
 Settings.canDrawOverlays(this); . This is required in dev builds
because React Native development errors must be displayed above all the
other windows. Due to the new permissions system introduced in the API
level 23 (Android M), the user needs to approve it. This can be achieved
by adding the following code to your Activity's in  onCreate() method.

    private final int OVERLAY_PERMISSION_REQ_CODE = 1;  // Choose any value

    ...

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        if (!Settings.canDrawOverlays(this)) {
            Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                                       Uri.parse("package:" + getPackageName()));
            startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE);
        }
    }

 

Finally, the  onActivityResult() method (as shown in the code below) has
to be overridden to handle the permission Accepted or Denied cases for
consistent UX. Also, for integrating Native Modules which use
 startActivityForResult , we need to pass the result to the
 onActivityResult method of our  ReactInstanceManager instance.

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == OVERLAY_PERMISSION_REQ_CODE) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                if (!Settings.canDrawOverlays(this)) {
                    // SYSTEM_ALERT_WINDOW permission not granted
                }
            }
        }
        mReactInstanceManager.onActivityResult( this, requestCode, resultCode, data );
    }

 

The Magic:  ReactRootView 

Let's add some native code in order to start the React Native runtime
and tell it to render our JS component. To do this, we're going to
create an  Activity that creates a  ReactRootView , starts a React
application inside it and sets it as the main content view.

  If you are targeting Android version <5, use the  AppCompatActivity
  class from the  com.android.support:appcompat package instead of
   Activity .

    public class MyReactActivity extends Activity implements DefaultHardwareBackBtnHandler {
        private ReactRootView mReactRootView;
        private ReactInstanceManager mReactInstanceManager;

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            SoLoader.init(this, false);

            mReactRootView = new ReactRootView(this);
            List<ReactPackage> packages = new PackageList(getApplication()).getPackages();
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // packages.add(new MyReactNativePackage());
            // Remember to include them in `settings.gradle` and `app/build.gradle` too.

            mReactInstanceManager = ReactInstanceManager.builder()
                    .setApplication(getApplication())
                    .setCurrentActivity(this)
                    .setBundleAssetName("index.android.bundle")
                    .setJSMainModulePath("index")
                    .addPackages(packages)
                    .setUseDeveloperSupport(BuildConfig.DEBUG)
                    .setInitialLifecycleState(LifecycleState.RESUMED)
                    .build();
            // The string here (e.g. "MyReactNativeApp") has to match
            // the string in AppRegistry.registerComponent() in index.js
            mReactRootView.startReactApplication(mReactInstanceManager, "MyReactNativeApp", null);

            setContentView(mReactRootView);
        }

        @Override
        public void invokeDefaultOnBackPressed() {
            super.onBackPressed();
        }
    }

 

  If you are using a starter kit for React Native, replace the
  "HelloWorld" string with the one in your index.js file (it’s the first
  argument to the  AppRegistry.registerComponent() method).

Perform a “Sync Project files with Gradle” operation.

If you are using Android Studio, use  Alt + Enter to add all missing
imports in your MyReactActivity class. Be careful to use your package’s
 BuildConfig and not the one from the  facebook package.

We need set the theme of  MyReactActivity to
 Theme.AppCompat.Light.NoActionBar because some React Native UI
components rely on this theme.

    <activity
      android:name=".MyReactActivity"
      android:label="@string/app_name"
      android:theme="@style/Theme.AppCompat.Light.NoActionBar">
    </activity>

 

  A  ReactInstanceManager can be shared by multiple activities and/or
  fragments. You will want to make your own  ReactFragment or
   ReactActivity and have a singleton holder that holds a
   ReactInstanceManager . When you need the  ReactInstanceManager (e.g.,
  to hook up the  ReactInstanceManager to the lifecycle of those
  Activities or Fragments) use the one provided by the singleton.

Next, we need to pass some activity lifecycle callbacks to the
 ReactInstanceManager and  ReactRootView :

    @Override
    protected void onPause() {
        super.onPause();

        if (mReactInstanceManager != null) {
            mReactInstanceManager.onHostPause(this);
        }
    }

    @Override
    protected void onResume() {
        super.onResume();

        if (mReactInstanceManager != null) {
            mReactInstanceManager.onHostResume(this, this);
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        if (mReactInstanceManager != null) {
            mReactInstanceManager.onHostDestroy(this);
        }
        if (mReactRootView != null) {
            mReactRootView.unmountReactApplication();
        }
    }

 

We also need to pass back button events to React Native:

    @Override
     public void onBackPressed() {
        if (mReactInstanceManager != null) {
            mReactInstanceManager.onBackPressed();
        } else {
            super.onBackPressed();
        }
    }

 

This allows JavaScript to control what happens when the user presses the
hardware back button (e.g. to implement navigation). When JavaScript
doesn't handle the back button press, your  invokeDefaultOnBackPressed
method will be called. By default this finishes your  Activity .

Finally, we need to hook up the dev menu. By default, this is activated
by (rage) shaking the device, but this is not very useful in emulators.
So we make it show when you press the hardware menu button (use Ctrl  +
M if you're using Android Studio emulator):

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_MENU && mReactInstanceManager != null) {
            mReactInstanceManager.showDevOptionsDialog();
            return true;
        }
        return super.onKeyUp(keyCode, event);
    }

 

Now your activity is ready to run some JavaScript code.

Test your integration 

You have now done all the basic steps to integrate React Native with
your current application. Now we will start the Metro bundler to build
the  index.bundle package and the server running on localhost to serve
it.

1. Run the packager 

To run your app, you need to first start the development server. To do
this, run the following command in the root directory of your React
Native project:

-   npm
-   Yarn

    npm start

 

    yarn start

 

2. Run the app 

Now build and run your Android app as normal.

Once you reach your React-powered activity inside the app, it should
load the JavaScript code from the development server and display:

[Screenshot]

Creating a release build in Android Studio 

You can use Android Studio to create your release builds too! It’s as
quick as creating release builds of your previously-existing native
Android app.

If you use the React Native Gradle Plugin as described above, everything
should work when running app from Android Studio.

If you're not using the React Native Gradle Plugin, there’s one
additional step which you’ll have to do before every release build. You
need to execute the following to create a React Native bundle, which
will be included with your native Android app:

    $ npx react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/com/your-company-name/app-package-name/src/main/assets/index.android.bundle --assets-dest android/com/your-company-name/app-package-name/src/main/res/

 

  Don’t forget to replace the paths with correct ones and create the
  assets folder if it doesn’t exist.

Now, create a release build of your native app from within Android
Studio as usual and you should be good to go!

Now what? 

At this point you can continue developing your app as usual. Refer to
our debugging and deployment docs to learn more about working with React
Native.

Key Concepts 

The keys to integrating React Native components into your iOS
application are to:

1.  Set up React Native dependencies and directory structure.
2.  Understand what React Native components you will use in your app.
3.  Add these components as dependencies using CocoaPods.
4.  Develop your React Native components in JavaScript.
5.  Add a  RCTRootView to your iOS app. This view will serve as the
    container for your React Native component.
6.  Start the React Native server and run your native application.
7.  Verify that the React Native aspect of your application works as
    expected.

Prerequisites 

Follow the React Native CLI Quickstart in the environment setup guide to
configure your development environment for building React Native apps
for iOS.

1. Set up directory structure 

To ensure a smooth experience, create a new folder for your integrated
React Native project, then copy your existing iOS project to a  /ios
subfolder.

2. Install JavaScript dependencies 

Go to the root directory for your project and create a new  package.json
file with the following contents:

    {
      "name": "MyReactNativeApp",
      "version": "0.0.1",
      "private": true,
      "scripts": {
        "start": "yarn react-native start"
      }
    }

 

Next, make sure you have installed the yarn package manager .

Install the  react and  react-native packages. Open a terminal or
command prompt, then navigate to the directory with your  package.json
file and run:

-   npm
-   Yarn

    npm install react-native

 

    yarn add react-native

 

This will print a message similar to the following (scroll up in the
installation command output to see it):

  warning "  react-native@0.52.2 " has unmet peer dependency "
   react@16.2.0 ".

This is OK, it means we also need to install React:

-   npm
-   Yarn

    npm install react@version_printed_above

 

    yarn add react@version_printed_above

 

Installation process has created a new  /node_modules folder. This
folder stores all the JavaScript dependencies required to build your
project.

Add  node_modules/ to your  .gitignore file.

3. Install CocoaPods 

CocoaPods is a package management tool for iOS and macOS development. We
use it to add the actual React Native framework code locally into your
current project.

We recommend installing CocoaPods using Homebrew .

    brew install cocoapods

 

  It is technically possible not to use CocoaPods, but that would
  require manual library and linker additions that would overly
  complicate this process.

Adding React Native to your app 

Assume the app for integration is a 2048 game. Here is what the main
menu of the native application looks like without React Native.

[Before RN Integration]

Command Line Tools for Xcode 

Install the Command Line Tools. Choose Settings... (or Preferences...)
in the Xcode menu. Go to the Locations panel and install the tools by
selecting the most recent version in the Command Line Tools dropdown.

[Xcode Command Line Tools]

Configuring CocoaPods dependencies 

Before you integrate React Native into your application, you will want
to decide what parts of the React Native framework you would like to
integrate. We will use CocoaPods to specify which of these "subspecs"
your app will depend on.

The list of supported  subspec s is available in
 /node_modules/react-native/React.podspec . They are generally named by
functionality. For example, you will generally always want the  Core
 subspec . That will get you the  AppRegistry ,  StyleSheet ,  View and
other core React Native libraries. If you want to add the React Native
 Text library (e.g., for  <Text> elements), then you will need the
 RCTText  subspec . If you want the  Image library (e.g., for  <Image>
elements), then you will need the  RCTImage  subspec .

You can specify which  subspec s your app will depend on in a  Podfile
file. The easiest way to create a  Podfile is by running the CocoaPods
 init command in the  /ios subfolder of your project:

    pod init

 

The  Podfile will contain a boilerplate setup that you will tweak for
your integration purposes.

  The  Podfile version changes depending on your version of
   react-native . Refer to
  https://react-native-community.github.io/upgrade-helper/ for the
  specific version of  Podfile you should be using.

Ultimately, your  Podfile should look something similar to this:

    # The target name is most likely the name of your project.
    target 'NumberTileGame' do

      # Your 'node_modules' directory is probably in the root of your project,
      # but if not, adjust the `:path` accordingly
      pod 'FBLazyVector', :path => "../node_modules/react-native/Libraries/FBLazyVector"
      pod 'FBReactNativeSpec', :path => "../node_modules/react-native/Libraries/FBReactNativeSpec"
      pod 'RCTRequired', :path => "../node_modules/react-native/Libraries/RCTRequired"
      pod 'RCTTypeSafety', :path => "../node_modules/react-native/Libraries/TypeSafety"
      pod 'React', :path => '../node_modules/react-native/'
      pod 'React-Core', :path => '../node_modules/react-native/'
      pod 'React-CoreModules', :path => '../node_modules/react-native/React/CoreModules'
      pod 'React-Core/DevSupport', :path => '../node_modules/react-native/'
      pod 'React-RCTActionSheet', :path => '../node_modules/react-native/Libraries/ActionSheetIOS'
      pod 'React-RCTAnimation', :path => '../node_modules/react-native/Libraries/NativeAnimation'
      pod 'React-RCTBlob', :path => '../node_modules/react-native/Libraries/Blob'
      pod 'React-RCTImage', :path => '../node_modules/react-native/Libraries/Image'
      pod 'React-RCTLinking', :path => '../node_modules/react-native/Libraries/LinkingIOS'
      pod 'React-RCTNetwork', :path => '../node_modules/react-native/Libraries/Network'
      pod 'React-RCTSettings', :path => '../node_modules/react-native/Libraries/Settings'
      pod 'React-RCTText', :path => '../node_modules/react-native/Libraries/Text'
      pod 'React-RCTVibration', :path => '../node_modules/react-native/Libraries/Vibration'
      pod 'React-Core/RCTWebSocket', :path => '../node_modules/react-native/'

      pod 'React-cxxreact', :path => '../node_modules/react-native/ReactCommon/cxxreact'
      pod 'React-jsi', :path => '../node_modules/react-native/ReactCommon/jsi'
      pod 'React-jsiexecutor', :path => '../node_modules/react-native/ReactCommon/jsiexecutor'
      pod 'React-jsinspector', :path => '../node_modules/react-native/ReactCommon/jsinspector'
      pod 'ReactCommon/callinvoker', :path => "../node_modules/react-native/ReactCommon"
      pod 'ReactCommon/turbomodule/core', :path => "../node_modules/react-native/ReactCommon"
      pod 'Yoga', :path => '../node_modules/react-native/ReactCommon/yoga'

      pod 'DoubleConversion', :podspec => '../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec'
      pod 'glog', :podspec => '../node_modules/react-native/third-party-podspecs/glog.podspec'
      pod 'Folly', :podspec => '../node_modules/react-native/third-party-podspecs/Folly.podspec'

    end

 

After you have created your  Podfile , you are ready to install the
React Native pod.

    $ pod install

 

You should see output such as:

    Analyzing dependencies
    Fetching podspec for `React` from `../node_modules/react-native`
    Downloading dependencies
    Installing React (0.62.0)
    Generating Pods project
    Integrating client project
    Sending stats
    Pod installation complete! There are 3 dependencies from the Podfile and 1 total pod installed.

 

  If this fails with errors mentioning  xcrun , make sure that in Xcode
  in Settings... (or Preferences...) > Locations the Command Line Tools
  are assigned.

Code integration 

Now we will actually modify the native iOS application to integrate
React Native. For our 2048 sample app, we will add a "High Score" screen
in React Native.

The React Native component 

The first bit of code we will write is the actual React Native code for
the new "High Score" screen that will be integrated into our
application.

1. Create a  index.js file 

First, create an empty  index.js file in the root of your React Native
project.

 index.js is the starting point for React Native applications, and it is
always required. It can be a small file that  require s other file that
are part of your React Native component or application, or it can
contain all the code that is needed for it. In our case, we will put
everything in  index.js .

2. Add your React Native code 

In your  index.js , create your component. In our sample here, we will
add a  <Text> component within a styled  <View>

    import React from 'react';
    import {AppRegistry, StyleSheet, Text, View} from 'react-native';

    const RNHighScores = ({scores}) => {
      const contents = scores.map(score => (
        <Text key={score.name}>
          {score.name}:{score.value}
          {'\n'}
        </Text>
      ));
      return (
        <View style={styles.container}>
          <Text style={styles.highScoresTitle}>
            2048 High Scores!
          </Text>
          <Text style={styles.scores}>{contents}</Text>
        </View>
      );
    };

    const styles = StyleSheet.create({
      container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#FFFFFF',
      },
      highScoresTitle: {
        fontSize: 20,
        textAlign: 'center',
        margin: 10,
      },
      scores: {
        textAlign: 'center',
        color: '#333333',
        marginBottom: 5,
      },
    });

    // Module name
    AppRegistry.registerComponent('RNHighScores', () => RNHighScores);

 

   RNHighScores is the name of your module that will be used when you
  add a view to React Native from within your iOS application.

The Magic:  RCTRootView 

Now that your React Native component is created via  index.js , you need
to add that component to a new or existing  ViewController . The easiest
path to take is to optionally create an event path to your component and
then add that component to an existing  ViewController .

We will tie our React Native component with a new native view in the
 ViewController that will actually contain it called  RCTRootView .

1. Create an Event Path 

You can add a new link on the main game menu to go to the "High Score"
React Native page.

[Event Path]

2. Event Handler 

We will now add an event handler from the menu link. A method will be
added to the main  ViewController of your application. This is where
 RCTRootView comes into play.

When you build a React Native application, you use the Metro bundler to
create an  index.bundle that will be served by the React Native server.
Inside  index.bundle will be our  RNHighScore module. So, we need to
point our  RCTRootView to the location of the  index.bundle resource
(via  NSURL ) and tie it to the module.

We will, for debugging purposes, log that the event handler was invoked.
Then, we will create a string with the location of our React Native code
that exists inside the  index.bundle . Finally, we will create the main
 RCTRootView . Notice how we provide  RNHighScores as the  moduleName
that we created above when writing the code for our React Native
component.

First  import the  RCTRootView header.

    #import <React/RCTRootView.h>

 

  The  initialProperties are here for illustration purposes so we have
  some data for our high score screen. In our React Native component, we
  will use  this.props to get access to that data.

    - (IBAction)highScoreButtonPressed:(id)sender {
        NSLog(@"High Score Button Pressed");
        NSURL *jsCodeLocation = [NSURL URLWithString:@"http://localhost:8081/index.bundle?platform=ios"];

        RCTRootView *rootView =
          [[RCTRootView alloc] initWithBundleURL: jsCodeLocation
                                      moduleName: @"RNHighScores"
                               initialProperties:
                                 @{
                                   @"scores" : @[
                                     @{
                                       @"name" : @"Alex",
                                       @"value": @"42"
                                      },
                                     @{
                                       @"name" : @"Joel",
                                       @"value": @"10"
                                     }
                                   ]
                                 }
                                   launchOptions: nil];
        UIViewController *vc = [[UIViewController alloc] init];
        vc.view = rootView;
        [self presentViewController:vc animated:YES completion:nil];
    }

 

  Note that  RCTRootView initWithURL starts up a new JSC VM. To save
  resources and simplify the communication between RN views in different
  parts of your native app, you can have multiple views powered by React
  Native that are associated with a single JS runtime. To do that,
  instead of using  [RCTRootView alloc] initWithURL , use
   RCTBridge initWithBundleURL to create a bridge and then use
   RCTRootView initWithBridge .

  When moving your app to production, the  NSURL can point to a
  pre-bundled file on disk via something like
   [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"];
  . You can use the  react-native-xcode.sh script in
   node_modules/react-native/scripts/ to generate that pre-bundled file.

3. Wire Up 

Wire up the new link in the main menu to the newly added event handler
method.

[Event Path]

  One of the easier ways to do this is to open the view in the
  storyboard and right click on the new link. Select something such as
  the  Touch Up Inside event, drag that to the storyboard and then
  select the created method from the list provided.

Test your integration 

You have now done all the basic steps to integrate React Native with
your current application. Now we will start the Metro bundler to build
the  index.bundle package and the server running on  localhost to serve
it.

1. Add App Transport Security exception 

Apple has blocked implicit cleartext HTTP resource loading. So we need
to add the following our project's  Info.plist (or equivalent) file.

    <key>NSAppTransportSecurity</key>
    <dict>
        <key>NSExceptionDomains</key>
        <dict>
            <key>localhost</key>
            <dict>
                <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
                <true/>
            </dict>
        </dict>
    </dict>

 

  App Transport Security is good for your users. Make sure to re-enable
  it prior to releasing your app for production.

2. Run the packager 

To run your app, you need to first start the development server. To do
this, run the following command in the root directory of your React
Native project:

-   npm
-   Yarn

    npm start

 

    yarn start

 

3. Run the app 

If you are using Xcode or your favorite editor, build and run your
native iOS application as normal. Alternatively, you can run the app
from the command line using:

-   npm
-   Yarn

    npm run ios

 

    yarn ios

 

In our sample application, you should see the link to the "High Scores"
and then when you click on that you will see the rendering of your React
Native component.

Here is the native application home screen:

[Home Screen]

Here is the React Native high score screen:

[High Scores]

  If you are getting module resolution issues when running your
  application please see this GitHub issue for information and possible
  resolution. This comment seemed to be the latest possible resolution.

Now what? 

At this point you can continue developing your app as usual. Refer to
our debugging and deployment docs to learn more about working with React
Native.

Key Concepts 

The keys to integrating React Native components into your iOS
application are to:

1.  Set up React Native dependencies and directory structure.
2.  Understand what React Native components you will use in your app.
3.  Add these components as dependencies using CocoaPods.
4.  Develop your React Native components in JavaScript.
5.  Add a  RCTRootView to your iOS app. This view will serve as the
    container for your React Native component.
6.  Start the React Native server and run your native application.
7.  Verify that the React Native aspect of your application works as
    expected.

Prerequisites 

Follow the React Native CLI Quickstart in the environment setup guide to
configure your development environment for building React Native apps
for iOS.

1. Set up directory structure 

To ensure a smooth experience, create a new folder for your integrated
React Native project, then copy your existing iOS project to a  /ios
subfolder.

2. Install JavaScript dependencies 

Go to the root directory for your project and create a new  package.json
file with the following contents:

    {
      "name": "MyReactNativeApp",
      "version": "0.0.1",
      "private": true,
      "scripts": {
        "start": "yarn react-native start"
      }
    }

 

Next, install the  react and  react-native packages. Open a terminal or
command prompt, then navigate to the directory with your  package.json
file and run:

-   npm
-   Yarn

    npm install react-native

 

    yarn add react-native

 

This will print a message similar to the following (scroll up in the
installation command output to see it):

  warning "  react-native@0.52.2 " has unmet peer dependency "
   react@16.2.0 ".

This is OK, it means we also need to install React:

-   npm
-   Yarn

    npm install react@version_printed_above

 

    yarn add react@version_printed_above

 

Installation process has created a new  /node_modules folder. This
folder stores all the JavaScript dependencies required to build your
project.

Add  node_modules/ to your  .gitignore file.

3. Install CocoaPods 

CocoaPods is a package management tool for iOS and macOS development. We
use it to add the actual React Native framework code locally into your
current project.

We recommend installing CocoaPods using Homebrew .

    $ brew install cocoapods

 

  It is technically possible not to use CocoaPods, but that would
  require manual library and linker additions that would overly
  complicate this process.

Adding React Native to your app 

Assume the app for integration is a 2048 game. Here is what the main
menu of the native application looks like without React Native.

[Before RN Integration]

Command Line Tools for Xcode 

Install the Command Line Tools. Choose Settings... (or Preferences...)
in the Xcode menu. Go to the Locations panel and install the tools by
selecting the most recent version in the Command Line Tools dropdown.

[Xcode Command Line Tools]

Configuring CocoaPods dependencies 

Before you integrate React Native into your application, you will want
to decide what parts of the React Native framework you would like to
integrate. We will use CocoaPods to specify which of these "subspecs"
your app will depend on.

The list of supported  subspec s is available in
 /node_modules/react-native/React.podspec . They are generally named by
functionality. For example, you will generally always want the  Core
 subspec . That will get you the  AppRegistry ,  StyleSheet ,  View and
other core React Native libraries. If you want to add the React Native
 Text library (e.g., for  <Text> elements), then you will need the
 RCTText  subspec . If you want the  Image library (e.g., for  <Image>
elements), then you will need the  RCTImage  subspec .

You can specify which  subspec s your app will depend on in a  Podfile
file. The easiest way to create a  Podfile is by running the CocoaPods
 init command in the  /ios subfolder of your project:

    $ pod init

 

The  Podfile will contain a boilerplate setup that you will tweak for
your integration purposes.

  The  Podfile version changes depending on your version of
   react-native . Refer to
  https://react-native-community.github.io/upgrade-helper/ for the
  specific version of  Podfile you should be using.

Ultimately, your  Podfile should look something similar to this: Podfile
Template

After you have created your  Podfile , you are ready to install the
React Native pod.

    $ pod install

 

You should see output such as:

    Analyzing dependencies
    Fetching podspec for `React` from `../node_modules/react-native`
    Downloading dependencies
    Installing React (0.62.0)
    Generating Pods project
    Integrating client project
    Sending stats
    Pod installation complete! There are 3 dependencies from the Podfile and 1 total pod installed.

 

  If this fails with errors mentioning  xcrun , make sure that in Xcode
  in Settings... (or Preferences...) > Locations the Command Line Tools
  are assigned.

  If you get a warning such as " The  swift-2048 [Debug] target
  overrides the  FRAMEWORK_SEARCH_PATHS build setting defined in
   Pods/Target Support Files/Pods-swift-2048/Pods-swift-2048.debug.xcconfig
  . This can lead to problems with the CocoaPods installation ", then
  make sure the  Framework Search Paths in  Build Settings for both
   Debug and  Release only contain  $(inherited) .

Code integration 

Now we will actually modify the native iOS application to integrate
React Native. For our 2048 sample app, we will add a "High Score" screen
in React Native.

The React Native component 

The first bit of code we will write is the actual React Native code for
the new "High Score" screen that will be integrated into our
application.

1. Create a  index.js file 

First, create an empty  index.js file in the root of your React Native
project.

 index.js is the starting point for React Native applications, and it is
always required. It can be a small file that  require s other file that
are part of your React Native component or application, or it can
contain all the code that is needed for it. In our case, we will put
everything in  index.js .

2. Add your React Native code 

In your  index.js , create your component. In our sample here, we will
add a  <Text> component within a styled  <View>

    import React from 'react';
    import {AppRegistry, StyleSheet, Text, View} from 'react-native';

    const RNHighScores = ({scores}) => {
      const contents = scores.map(score => (
        <Text key={score.name}>
          {score.name}:{score.value}
          {'\n'}
        </Text>
      ));
      return (
        <View style={styles.container}>
          <Text style={styles.highScoresTitle}>
            2048 High Scores!
          </Text>
          <Text style={styles.scores}>{contents}</Text>
        </View>
      );
    };

    const styles = StyleSheet.create({
      container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#FFFFFF',
      },
      highScoresTitle: {
        fontSize: 20,
        textAlign: 'center',
        margin: 10,
      },
      scores: {
        textAlign: 'center',
        color: '#333333',
        marginBottom: 5,
      },
    });

    // Module name
    AppRegistry.registerComponent('RNHighScores', () => RNHighScores);

 

   RNHighScores is the name of your module that will be used when you
  add a view to React Native from within your iOS application.

The Magic:  RCTRootView 

Now that your React Native component is created via  index.js , you need
to add that component to a new or existing  ViewController . The easiest
path to take is to optionally create an event path to your component and
then add that component to an existing  ViewController .

We will tie our React Native component with a new native view in the
 ViewController that will actually contain it called  RCTRootView .

1. Create an Event Path 

You can add a new link on the main game menu to go to the "High Score"
React Native page.

[Event Path]

2. Event Handler 

We will now add an event handler from the menu link. A method will be
added to the main  ViewController of your application. This is where
 RCTRootView comes into play.

When you build a React Native application, you use the Metro bundler to
create an  index.bundle that will be served by the React Native server.
Inside  index.bundle will be our  RNHighScore module. So, we need to
point our  RCTRootView to the location of the  index.bundle resource
(via  NSURL ) and tie it to the module.

We will, for debugging purposes, log that the event handler was invoked.
Then, we will create a string with the location of our React Native code
that exists inside the  index.bundle . Finally, we will create the main
 RCTRootView . Notice how we provide  RNHighScores as the  moduleName
that we created above when writing the code for our React Native
component.

First  import the  React library.

    import React

 

  The  initialProperties are here for illustration purposes so we have
  some data for our high score screen. In our React Native component, we
  will use  this.props to get access to that data.

    @IBAction func highScoreButtonTapped(sender : UIButton) {
      NSLog("Hello")
      let jsCodeLocation = URL(string: "http://localhost:8081/index.bundle?platform=ios")
      let mockData:NSDictionary = ["scores":
          [
              ["name":"Alex", "value":"42"],
              ["name":"Joel", "value":"10"]
          ]
      ]

      let rootView = RCTRootView(
          bundleURL: jsCodeLocation,
          moduleName: "RNHighScores",
          initialProperties: mockData as [NSObject : AnyObject],
          launchOptions: nil
      )
      let vc = UIViewController()
      vc.view = rootView
      self.present(vc, animated: true, completion: nil)
    }

 

  Note that  RCTRootView bundleURL starts up a new JSC VM. To save
  resources and simplify the communication between RN views in different
  parts of your native app, you can have multiple views powered by React
  Native that are associated with a single JS runtime. To do that,
  instead of using  RCTRootView bundleURL , use
   RCTBridge initWithBundleURL to create a bridge and then use
   RCTRootView initWithBridge .

  When moving your app to production, the  NSURL can point to a
  pre-bundled file on disk via something like
   let mainBundle = NSBundle(URLForResource: "main" withExtension:"jsbundle")
  . You can use the  react-native-xcode.sh script in
   node_modules/react-native/scripts/ to generate that pre-bundled file.

3. Wire Up 

Wire up the new link in the main menu to the newly added event handler
method.

[Event Path]

  One of the easier ways to do this is to open the view in the
  storyboard and right click on the new link. Select something such as
  the  Touch Up Inside event, drag that to the storyboard and then
  select the created method from the list provided.

3. Window Reference 

Add an window reference to your AppDelegate.swift file. Ultimately, your
AppDelegate should look something similar to this:

    import UIKit

    @main
    class AppDelegate: UIResponder, UIApplicationDelegate {

        // Add window reference
        var window: UIWindow?

        func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
            // Override point for customization after application launch.
            return true
        }

        ....
    }

 

Test your integration 

You have now done all the basic steps to integrate React Native with
your current application. Now we will start the Metro bundler to build
the  index.bundle package and the server running on  localhost to serve
it.

1. Add App Transport Security exception 

Apple has blocked implicit cleartext HTTP resource loading. So we need
to add the following our project's  Info.plist (or equivalent) file.

    <key>NSAppTransportSecurity</key>
    <dict>
        <key>NSExceptionDomains</key>
        <dict>
            <key>localhost</key>
            <dict>
                <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
                <true/>
            </dict>
        </dict>
    </dict>

 

  App Transport Security is good for your users. Make sure to re-enable
  it prior to releasing your app for production.

2. Run the packager 

To run your app, you need to first start the development server. To do
this, run the following command in the root directory of your React
Native project:

-   npm
-   Yarn

    npm start

 

    yarn start

 

3. Run the app 

If you are using Xcode or your favorite editor, build and run your
native iOS application as normal. Alternatively, you can run the app
from the command line using following command from the root directory of
your React Native project:

-   npm
-   Yarn

    npm run ios

 

    yarn ios

 

In our sample application, you should see the link to the "High Scores"
and then when you click on that you will see the rendering of your React
Native component.

Here is the native application home screen:

[Home Screen]

Here is the React Native high score screen:

[High Scores]

  If you are getting module resolution issues when running your
  application please see this GitHub issue for information and possible
  resolution. This comment seemed to be the latest possible resolution.

Now what? 

At this point you can continue developing your app as usual. Refer to
our debugging and deployment docs to learn more about working with React
Native.

# InteractionManager #
 ___       _                      _   _             __  __                   
|_ _|_ __ | |_ ___ _ __ __ _  ___| |_(_) ___  _ __ |  \/  | __ _ _ __   __ _ 
 | || '_ \| __/ _ \ '__/ _` |/ __| __| |/ _ \| '_ \| |\/| |/ _` | '_ \ / _` |
 | || | | | ||  __/ | | (_| | (__| |_| | (_) | | | | |  | | (_| | | | | (_| |
|___|_| |_|\__\___|_|  \__,_|\___|\__|_|\___/|_| |_|_|  |_|\__,_|_| |_|\__,_|
                                                                             
                 
  __ _  ___ _ __ 
 / _` |/ _ \ '__|
| (_| |  __/ |   
 \__, |\___|_|   
 |___/           
-   Example
    -   Basic
    -   Advanced
-   Methods
    -    runAfterInteractions()
    -    createInteractionHandle()
    -    clearInteractionHandle()
    -    setDeadline()
InteractionManager

InteractionManager allows long-running work to be scheduled after any
interactions/animations have completed. In particular, this allows
JavaScript animations to run smoothly.

Applications can schedule tasks to run after interactions with the
following:

    InteractionManager.runAfterInteractions(() => {
      // ...long-running synchronous task...
    });

 

Compare this to other scheduling alternatives:

-    requestAnimationFrame() for code that animates a view over time.
-    setImmediate/setTimeout() run code later, note this may delay
    animations.
-    runAfterInteractions() run code later, without delaying active
    animations.

The touch handling system considers one or more active touches to be an
'interaction' and will delay  runAfterInteractions() callbacks until all
touches have ended or been cancelled.

InteractionManager also allows applications to register animations by
creating an interaction 'handle' on animation start, and clearing it
upon completion:

    const handle = InteractionManager.createInteractionHandle();
    // run animation... (`runAfterInteractions` tasks are queued)
    // later, on animation completion:
    InteractionManager.clearInteractionHandle(handle);
    // queued tasks run if all handles were cleared

 

 runAfterInteractions takes either a plain callback function, or a
 PromiseTask object with a  gen method that returns a  Promise . If a
 PromiseTask is supplied, then it is fully resolved (including
asynchronous dependencies that also schedule more tasks via
 runAfterInteractions ) before starting on the next task that might have
been queued up synchronously earlier.

By default, queued tasks are executed together in a loop in one
 setImmediate batch. If  setDeadline is called with a positive number,
then tasks will only be executed until the deadline (in terms of js
event loop run time) approaches, at which point execution will yield via
setTimeout, allowing events such as touches to start interactions and
block queued tasks from executing, making apps more responsive.

------------------------------------------------------------------------

Example 

Basic 

-   TypeScript
-   JavaScript

Advanced 

-   TypeScript
-   JavaScript

Reference

Methods 

 runAfterInteractions() 

    static runAfterInteractions(task?: (() => any) | SimpleTask | PromiseTask);

 

Schedule a function to run after all interactions have completed.
Returns a cancellable "promise".

------------------------------------------------------------------------

 createInteractionHandle() 

    static createInteractionHandle(): Handle;

 

Notify manager that an interaction has started.

------------------------------------------------------------------------

 clearInteractionHandle() 

    static clearInteractionHandle(handle: Handle);

 

Notify manager that an interaction has completed.

------------------------------------------------------------------------

 setDeadline() 

    static setDeadline(deadline: number);

 

A positive number will use setTimeout to schedule any tasks after the
eventLoopRunningTime hits the deadline value, otherwise all tasks will
be executed in one setImmediate batch (default).

# Introduction #
 ___       _                 _            _   _             
|_ _|_ __ | |_ _ __ ___   __| |_   _  ___| |_(_) ___  _ __  
 | || '_ \| __| '__/ _ \ / _` | | | |/ __| __| |/ _ \| '_ \ 
 | || | | | |_| | | (_) | (_| | |_| | (__| |_| | (_) | | | |
|___|_| |_|\__|_|  \___/ \__,_|\__,_|\___|\__|_|\___/|_| |_|
                                                            
-   How to use these docs
-   Prerequisites
-   Interactive examples
-   Developer Notes
-   Formatting
Introduction

Welcome to the very start of your React Native journey! If you're
looking for environment setup instructions, they've moved to their own
section . Continue reading for an introduction to the documentation,
Native Components, React, and more!

[ ]

Many different kinds of people use React Native: from advanced iOS
developers to React beginners, to people getting started programming for
the first time in their career. These docs were written for all
learners, no matter their experience level or background.

How to use these docs 

You can start here and read through these docs linearly like a book; or
you can read the specific sections you need. Already familiar with
React? You can skip that section —or read it for a light refresher.

Prerequisites 

To work with React Native, you will need to have an understanding of
JavaScript fundamentals. If you’re new to JavaScript or need a
refresher, you can dive in or brush up at Mozilla Developer Network.

  While we do our best to assume no prior knowledge of React, Android,
  or iOS development, these are valuable topics of study for the
  aspiring React Native developer. Where sensible, we have linked to
  resources and articles that go more in depth.

Interactive examples 

This introduction lets you get started immediately in your browser with
interactive examples like this one:

The above is a Snack Player. It’s a handy tool created by Expo to embed
and run React Native projects and share how they render in platforms
like Android and iOS. The code is live and editable, so you can play
directly with it in your browser. Go ahead and try changing the "Try
editing me!" text above to "Hello, world!"

  Optionally, if you want to setup a local development environment, you
  can follow our guide to setting up your environment on your local
  machine and paste the code examples into your  App.js file there. (If
  you are a web developer, you may already have a local environment set
  up for mobile browser testing!)

Developer Notes 

People from many different development backgrounds are learning React
Native. You may have experience with a range of technologies, from web
to Android to iOS and more. We try to write for developers from all
backgrounds. Sometimes we provide explanations specific to one platform
or another like so:

-   Android
-   iOS
-   Web

  Android developers may be familiar with this concept.

  iOS developers may be familiar with this concept.

  Web developers may be familiar with this concept.

Formatting 

Menu paths are written in bold and use carets to navigate submenus.
Example: Android Studio > Preferences

------------------------------------------------------------------------

Now that you know how this guide works, it's time to get to know the
foundation of React Native: Native Components .

# iOS Native Modules #
 _  ___  ____    _   _       _   _           
(_)/ _ \/ ___|  | \ | | __ _| |_(_)_   _____ 
| | | | \___ \  |  \| |/ _` | __| \ \ / / _ \
| | |_| |___) | | |\  | (_| | |_| |\ V /  __/
|_|\___/|____/  |_| \_|\__,_|\__|_| \_/ \___|
                                             
 __  __           _       _           
|  \/  | ___   __| |_   _| | ___  ___ 
| |\/| |/ _ \ / _` | | | | |/ _ \/ __|
| |  | | (_) | (_| | |_| | |  __/\__ \
|_|  |_|\___/ \__,_|\__,_|_|\___||___/
                                      
-   Create a Calendar Native Module
    -   Setup
    -   Create Custom Native Module Files
    -   Module Name
    -   Export a Native Method to JavaScript
    -   Synchronous Methods
    -   Test What You Have Built
    -   Building as You Iterate
    -   Recap✨
-   Beyond a Calendar Native Module
    -   Better Native Module Export
    -   Argument Types
    -   Exporting Constants
    -   Callbacks
    -   Promises
    -   Sending Events to JavaScript
    -   Threading
    -   Dependency Injection
    -   Exporting Swift
    -   Reserved Method Names
iOS Native Modules

 info

Native Module and Native Components are our stable technologies used by
the legacy architecture. They will be deprecated in the future when the
New Architecture will be stable. The New Architecture uses Turbo Native
Module and Fabric Native Components to achieve similar results.

Welcome to Native Modules for iOS. Please start by reading the Native
Modules Intro for an intro to what native modules are.

Create a Calendar Native Module 

In the following guide you will create a native module,  CalendarModule
, that will allow you to access Apple's calendar APIs from JavaScript.
By the end you will be able to call
 CalendarModule.createCalendarEvent('Dinner Party', 'My House'); from
JavaScript, invoking a native method that creates a calendar event.

Setup 

To get started, open up the iOS project within your React Native
application in Xcode. You can find your iOS project here within a React
Native app:

[Image of where you can find your iOS project]

We recommend using Xcode to write your native code. Xcode is built for
iOS development, and using it will help you to quickly resolve smaller
errors like code syntax.

Create Custom Native Module Files 

The first step is to create our main custom native module header and
implementation files. Create a new file called  RCTCalendarModule.h

[Image of creating a custom native module file within the same folder as
AppDelegate]

and add the following to it:

    //  RCTCalendarModule.h
    #import <React/RCTBridgeModule.h>
    @interface RCTCalendarModule : NSObject <RCTBridgeModule>
    @end

 

You can use any name that fits the native module you are building. Name
the class  RCTCalendarModule since you are creating a calendar native
module. Since ObjC does not have language-level support for namespaces
like Java or C++, convention is to prepend the class name with a
substring. This could be an abbreviation of your application name or
your infra name. RCT, in this example, refers to React.

As you can see below, the CalendarModule class implements the
 RCTBridgeModule protocol. A native module is an Objective-C class that
implements the  RCTBridgeModule protocol.

Next up, let’s start implementing the native module. Create the
corresponding implementation file,  RCTCalendarModule.m , in the same
folder and include the following content:

    // RCTCalendarModule.m
    #import "RCTCalendarModule.h"

    @implementation RCTCalendarModule

    // To export a module named RCTCalendarModule
    RCT_EXPORT_MODULE();

    @end

 

Module Name 

For now, your  RCTCalendarModule.m native module only includes a
 RCT_EXPORT_MODULE macro, which exports and registers the native module
class with React Native. The  RCT_EXPORT_MODULE macro also takes an
optional argument that specifies the name that the module will be
accessible as in your JavaScript code.

This argument is not a string literal. In the example below
 RCT_EXPORT_MODULE(CalendarModuleFoo) is passed, not
 RCT_EXPORT_MODULE("CalendarModuleFoo") .

    // To export a module named CalendarModuleFoo
    RCT_EXPORT_MODULE(CalendarModuleFoo);

 

The native module can then be accessed in JS like this:

    const {CalendarModuleFoo} = ReactNative.NativeModules;

 

If you do not specify a name, the JavaScript module name will match the
Objective-C class name, with any "RCT" or "RK" prefixes removed.

Let's follow the example below and call  RCT_EXPORT_MODULE without any
arguments. As a result, the module will be exposed to React Native using
the name  CalendarModule , since that is the Objective-C class name,
with RCT removed.

    // Without passing in a name this will export the native module name as the Objective-C class name with “RCT” removed
    RCT_EXPORT_MODULE();

 

The native module can then be accessed in JS like this:

    const {CalendarModule} = ReactNative.NativeModules;

 

Export a Native Method to JavaScript 

React Native will not expose any methods in a native module to
JavaScript unless explicitly told to. This can be done using the
 RCT_EXPORT_METHOD macro. Methods written in the  RCT_EXPORT_METHOD
macro are asynchronous and the return type is therefore always void. In
order to pass a result from a  RCT_EXPORT_METHOD method to JavaScript
you can use callbacks or emit events (covered below). Let’s go ahead and
set up a native method for our  CalendarModule native module using the
 RCT_EXPORT_METHOD macro. Call it  createCalendarEvent() and for now
have it take in name and location arguments as strings. Argument type
options will be covered shortly.

    RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)name location:(NSString *)location)
    {
    }

 

  Please note that the  RCT_EXPORT_METHOD macro will not be necessary
  with TurboModules unless your method relies on RCT argument conversion
  (see argument types below). Ultimately, React Native will remove
   RCT_EXPORT_MACRO, so we discourage people from using  RCTConvert .
  Instead, you can do the argument conversion within the method body.

Before you build out the  createCalendarEvent() method’s functionality,
add a console log in the method so you can confirm it has been invoked
from JavaScript in your React Native application. Use the  RCTLog APIs
from React. Let’s import that header at the top of your file and then
add the log call.

    #import <React/RCTLog.h>
    RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)name location:(NSString *)location)
    {
     RCTLogInfo(@"Pretending to create an event %@ at %@", name, location);
    }

 

Synchronous Methods 

You can use the  RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD to create a
synchronous native method.

    RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD(getName)
    {
    return [[UIDevice currentDevice] name];
    }

 

The return type of this method must be of object type (id) and should be
serializable to JSON. This means that the hook can only return nil or
JSON values (e.g. NSNumber, NSString, NSArray, NSDictionary).

At the moment, we do not recommend using synchronous methods, since
calling methods synchronously can have strong performance penalties and
introduce threading-related bugs to your native modules. Additionally,
please note that if you choose to use
 RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD , your app can no longer use the
Google Chrome debugger. This is because synchronous methods require the
JS VM to share memory with the app. For the Google Chrome debugger,
React Native runs inside the JS VM in Google Chrome, and communicates
asynchronously with the mobile devices via WebSockets.

Test What You Have Built 

At this point you have set up the basic scaffolding for your native
module in iOS. Test that out by accessing the native module and invoking
it’s exported method in JavaScript.

Find a place in your application where you would like to add a call to
the native module’s  createCalendarEvent() method. Below is an example
of a component,  NewModuleButton you can add in your app. You can invoke
the native module inside  NewModuleButton 's  onPress() function.

    import React from 'react';
    import {NativeModules, Button} from 'react-native';

    const NewModuleButton = () => {
      const onPress = () => {
        console.log('We will invoke the native module here!');
      };

      return (
        <Button
          title="Click to invoke your native module!"
          color="#841584"
          onPress={onPress}
        />
      );
    };

    export default NewModuleButton;

 

In order to access your native module from JavaScript you need to first
import  NativeModules from React Native:

    import {NativeModules} from 'react-native';

 

You can then access the  CalendarModule native module off of
 NativeModules .

    const {CalendarModule} = NativeModules;

 

Now that you have the CalendarModule native module available, you can
invoke your native method  createCalendarEvent() . Below it is added to
the  onPress() method in  NewModuleButton :

    const onPress = () => {
      CalendarModule.createCalendarEvent('testName', 'testLocation');
    };

 

The final step is to rebuild the React Native app so that you can have
the latest native code (with your new native module!) available. In your
command line, where the react native application is located, run the
following :

-   npm
-   Yarn

    npm run ios

 

    yarn ios

 

Building as You Iterate 

As you work through these guides and iterate on your native module, you
will need to do a native rebuild of your application to access your most
recent changes from JavaScript. This is because the code that you are
writing sits within the native part of your application. While React
Native’s metro bundler can watch for changes in JavaScript and rebuild
JS bundle on the fly for you, it will not do so for native code. So if
you want to test your latest native changes you need to rebuild by using
the above command.

Recap✨ 

You should now be able to invoke your  createCalendarEvent() method on
your native module in JavaScript. Since you are using  RCTLog in the
function, you can confirm your native method is being invoked by
enabling debug mode in your app and looking at the JS console in Chrome
or the mobile app debugger Flipper. You should see your
 RCTLogInfo(@"Pretending to create an event %@ at %@", name, location);
message each time you invoke the native module method.

[Image of iOS logs in Flipper]

At this point you have created an iOS native module and invoked a method
on it from JavaScript in your React Native application. You can read on
to learn more about things like what argument types your native module
method takes and how to setup callbacks and promises within your native
module.

Beyond a Calendar Native Module 

Better Native Module Export 

Importing your native module by pulling it off of  NativeModules like
above is a bit clunky.

To save consumers of your native module from needing to do that each
time they want to access your native module, you can create a JavaScript
wrapper for the module. Create a new JavaScript file named
NativeCalendarModule.js with the following content:

    /**
    * This exposes the native CalendarModule module as a JS module. This has a
    * function 'createCalendarEvent' which takes the following parameters:

    * 1. String name: A string representing the name of the event
    * 2. String location: A string representing the location of the event
    */
    import {NativeModules} from 'react-native';
    const {CalendarModule} = NativeModules;
    export default CalendarModule;

 

This JavaScript file also becomes a good location for you to add any
JavaScript side functionality. For example, if you use a type system
like TypeScript you can add type annotations for your native module
here. While React Native does not yet support Native to JS type safety,
with these type annotations, all your JS code will be type safe. These
annotations will also make it easier for you to switch to type-safe
native modules down the line. Below is an example of adding type safety
to the Calendar Module:

    /**
     * This exposes the native CalendarModule module as a JS module. This has a
     * function 'createCalendarEvent' which takes the following parameters:
     *
     * 1. String name: A string representing the name of the event
     * 2. String location: A string representing the location of the event
     */
    import {NativeModules} from 'react-native';
    const {CalendarModule} = NativeModules;
    interface CalendarInterface {
      createCalendarEvent(name: string, location: string): void;
    }
    export default CalendarModule as CalendarInterface;

 

In your other JavaScript files you can access the native module and
invoke its method like this:

    import NativeCalendarModule from './NativeCalendarModule';
    NativeCalendarModule.createCalendarEvent('foo', 'bar');

 

  Note this assumes that the place you are importing  CalendarModule is
  in the same hierarchy as  NativeCalendarModule.js . Please update the
  relative import as necessary.

Argument Types 

When a native module method is invoked in JavaScript, React Native
converts the arguments from JS objects to their Objective-C/Swift object
analogues. So for example, if your Objective-C Native Module method
accepts a NSNumber, in JS you need to call the method with a number.
React Native will handle the conversion for you. Below is a list of the
argument types supported for native module methods and the JavaScript
equivalents they map to.

  Objective-C                                     JavaScript
  ----------------------------------------------- --------------------
  NSString                                        string, ?string
  BOOL                                            boolean
  double                                          number
  NSNumber                                        ?number
  NSArray                                         Array, ?Array
  NSDictionary                                    Object, ?Object
  RCTResponseSenderBlock                          Function (success)
  RCTResponseSenderBlock, RCTResponseErrorBlock   Function (failure)
  RCTPromiseResolveBlock, RCTPromiseRejectBlock   Promise

  The following types are currently supported but will not be supported
  in TurboModules. Please avoid using them.

  -   Function (failure) -> RCTResponseErrorBlock
  -   Number -> NSInteger
  -   Number -> CGFloat
  -   Number -> float

For iOS, you can also write native module methods with any argument type
that is supported by the  RCTConvert class (see RCTConvert for details
about what is supported). The RCTConvert helper functions all accept a
JSON value as input and map it to a native Objective-C type or class.

Exporting Constants 

A native module can export constants by overriding the native method
 constantsToExport() . Below  constantsToExport() is overriden, and
returns a Dictionary that contains a default event name property you can
access in JavaScript like so:

    - (NSDictionary *)constantsToExport
    {
     return @{ @"DEFAULT_EVENT_NAME": @"New Event" };
    }

 

The constant can then be accessed by invoking  getConstants() on the
native module in JS like so:

    const {DEFAULT_EVENT_NAME} = CalendarModule.getConstants();
    console.log(DEFAULT_EVENT_NAME);

 

Technically, it is possible to access constants exported in
 constantsToExport() directly off the  NativeModule object. This will no
longer be supported with TurboModules, so we encourage the community to
switch to the above approach to avoid necessary migration down the line.

  Note that the constants are exported only at initialization time, so
  if you change  constantsToExport() values at runtime it won't affect
  the JavaScript environment.

For iOS, if you override  constantsToExport() then you should also
implement  + requiresMainQueueSetup to let React Native know if your
module needs to be initialized on the main thread, before any JavaScript
code executes. Otherwise you will see a warning that in the future your
module may be initialized on a background thread unless you explicitly
opt out with  + requiresMainQueueSetup: . If your module does not
require access to UIKit, then you should respond to
 + requiresMainQueueSetup with NO.

Callbacks 

Native modules also support a unique kind of argument - a callback.
Callbacks are used to pass data from Objective-C to JavaScript for
asynchronous methods. They can also be used to asynchronously execute JS
from the native side.

For iOS, callbacks are implemented using the type
 RCTResponseSenderBlock . Below the callback parameter  myCallBack is
added to the  createCalendarEventMethod() :

    RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)title
                    location:(NSString *)location
                    myCallback:(RCTResponseSenderBlock)callback)

 

You can then invoke the callback in your native function, providing
whatever result you want to pass to JavaScript in an array. Note that
 RCTResponseSenderBlock accepts only one argument - an array of
parameters to pass to the JavaScript callback. Below you will pass back
the ID of an event created in an earlier call.

  It is important to highlight that the callback is not invoked
  immediately after the native function completes—remember the
  communication is asynchronous.

    RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)title location:(NSString *)location callback: (RCTResponseSenderBlock)callback)
    {
     NSInteger eventId = ...
     callback(@[@(eventId)]);

     RCTLogInfo(@"Pretending to create an event %@ at %@", title, location);
    }

 

This method could then be accessed in JavaScript using the following:

    const onSubmit = () => {
      CalendarModule.createCalendarEvent(
        'Party',
        '04-12-2020',
        eventId => {
          console.log(`Created a new event with id ${eventId}`);
        },
      );
    };

 

A native module is supposed to invoke its callback only once. It can,
however, store the callback and invoke it later. This pattern is often
used to wrap iOS APIs that require delegates— see  RCTAlertManager for
an example. If the callback is never invoked, some memory is leaked.

There are two approaches to error handling with callbacks. The first is
to follow Node’s convention and treat the first argument passed to the
callback array as an error object.

    RCT_EXPORT_METHOD(createCalendarEventCallback:(NSString *)title location:(NSString *)location callback: (RCTResponseSenderBlock)callback)
    {
      NSNumber *eventId = [NSNumber numberWithInt:123];
      callback(@[[NSNull null], eventId]);
    }

 

In JavaScript, you can then check the first argument to see if an error
was passed through:

    const onPress = () => {
      CalendarModule.createCalendarEventCallback(
        'testName',
        'testLocation',
        (error, eventId) => {
          if (error) {
            console.error(`Error found! ${error}`);
          }
          console.log(`event id ${eventId} returned`);
        },
      );
    };

 

Another option is to use two separate callbacks: onFailure and
onSuccess.

    RCT_EXPORT_METHOD(createCalendarEventCallback:(NSString *)title
                      location:(NSString *)location
                      errorCallback: (RCTResponseSenderBlock)errorCallback
                      successCallback: (RCTResponseSenderBlock)successCallback)
    {
      @try {
        NSNumber *eventId = [NSNumber numberWithInt:123];
        successCallback(@[eventId]);
      }

      @catch ( NSException *e ) {
        errorCallback(@[e]);
      }
    }

 

Then in JavaScript you can add a separate callback for error and success
responses:

    const onPress = () => {
      CalendarModule.createCalendarEventCallback(
        'testName',
        'testLocation',
        error => {
          console.error(`Error found! ${error}`);
        },
        eventId => {
          console.log(`event id ${eventId} returned`);
        },
      );
    };

 

If you want to pass error-like objects to JavaScript, use  RCTMakeError
from  RCTUtils.h. Right now this only passes an Error-shaped dictionary
to JavaScript, but React Native aims to automatically generate real
JavaScript Error objects in the future. You can also provide a
 RCTResponseErrorBlock argument, which is used for error callbacks and
accepts an  NSError \* object . Please note that this argument type will
not be supported with TurboModules.

Promises 

Native modules can also fulfill a promise, which can simplify your
JavaScript, especially when using ES2016's  async/await syntax. When the
last parameter of a native module method is a  RCTPromiseResolveBlock
and  RCTPromiseRejectBlock , its corresponding JS method will return a
JS Promise object.

Refactoring the above code to use a promise instead of callbacks looks
like this:

    RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)title
                     location:(NSString *)location
                     resolver:(RCTPromiseResolveBlock)resolve
                     rejecter:(RCTPromiseRejectBlock)reject)
    {
     NSInteger eventId = createCalendarEvent();
     if (eventId) {
        resolve(@(eventId));
      } else {
        reject(@"event_failure", @"no event id returned", nil);
      }
    }

 

The JavaScript counterpart of this method returns a Promise. This means
you can use the  await keyword within an async function to call it and
wait for its result:

    const onSubmit = async () => {
      try {
        const eventId = await CalendarModule.createCalendarEvent(
          'Party',
          'my house',
        );
        console.log(`Created a new event with id ${eventId}`);
      } catch (e) {
        console.error(e);
      }
    };

 

Sending Events to JavaScript 

Native modules can signal events to JavaScript without being invoked
directly. For example, you might want to signal to JavaScript a reminder
that a calendar event from the native iOS calendar app will occur soon.
The preferred way to do this is to subclass  RCTEventEmitter , implement
 supportedEvents and call self  sendEventWithName :

Update your header class to import  RCTEventEmitter and subclass
 RCTEventEmitter :

    //  CalendarModule.h

    #import <React/RCTBridgeModule.h>
    #import <React/RCTEventEmitter.h>

    @interface CalendarModule : RCTEventEmitter <RCTBridgeModule>
    @end

 

JavaScript code can subscribe to these events by creating a new
 NativeEventEmitter instance around your module.

You will receive a warning if you expend resources unnecessarily by
emitting an event while there are no listeners. To avoid this, and to
optimize your module's workload (e.g. by unsubscribing from upstream
notifications or pausing background tasks), you can override
 startObserving and  stopObserving in your  RCTEventEmitter subclass.

    @implementation CalendarManager
    {
      bool hasListeners;
    }

    // Will be called when this module's first listener is added.
    -(void)startObserving {
        hasListeners = YES;
        // Set up any upstream listeners or background tasks as necessary
    }

    // Will be called when this module's last listener is removed, or on dealloc.
    -(void)stopObserving {
        hasListeners = NO;
        // Remove upstream listeners, stop unnecessary background tasks
    }

    - (void)calendarEventReminderReceived:(NSNotification *)notification
    {
      NSString *eventName = notification.userInfo[@"name"];
      if (hasListeners) {// Only send events if anyone is listening
        [self sendEventWithName:@"EventReminder" body:@{@"name": eventName}];
      }
    }

 

Threading 

Unless the native module provides its own method queue, it shouldn't
make any assumptions about what thread it's being called on. Currently,
if a native module doesn't provide a method queue, React Native will
create a separate GCD queue for it and invoke its methods there. Please
note that this is an implementation detail and might change. If you want
to explicitly provide a method queue for a native module, override the
 (dispatch_queue_t) methodQueue method in the native module. For
example, if it needs to use a main-thread-only iOS API, it should
specify this via:

    - (dispatch_queue_t)methodQueue
    {
      return dispatch_get_main_queue();
    }

 

Similarly, if an operation may take a long time to complete, the native
module can specify its own queue to run operations on. Again, currently
React Native will provide a separate method queue for your native
module, but this is an implementation detail you should not rely on. If
you don't provide your own method queue, in the future, your native
module's long running operations may end up blocking async calls being
executed on other unrelated native modules. The  RCTAsyncLocalStorage
module here, for example, creates its own queue so the React queue isn't
blocked waiting on potentially slow disk access.

    - (dispatch_queue_t)methodQueue
    {
     return dispatch_queue_create("com.facebook.React.AsyncLocalStorageQueue", DISPATCH_QUEUE_SERIAL);
    }

 

The specified  methodQueue will be shared by all of the methods in your
module. If only one of your methods is long-running (or needs to be run
on a different queue than the others for some reason), you can use
 dispatch_async inside the method to perform that particular method's
code on another queue, without affecting the others:

    RCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback)
    {
     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
       // Call long-running code on background thread
       ...
       // You can invoke callback from any thread/queue
       callback(@[...]);
     });
    }

 

  Sharing dispatch queues between modules

  The  methodQueue method will be called once when the module is
  initialized, and then retained by React Native, so there is no need to
  keep a reference to the queue yourself, unless you wish to make use of
  it within your module. However, if you wish to share the same queue
  between multiple modules then you will need to ensure that you retain
  and return the same queue instance for each of them.

Dependency Injection 

React Native will create and initialize any registered native modules
automatically. However, you may wish to create and initialize your own
module instances to, for example, inject dependencies.

You can do this by creating a class that implements the
 RCTBridgeDelegate Protocol, initializing an  RCTBridge with the
delegate as an argument and initialising a  RCTRootView with the
initialized bridge.

    id<RCTBridgeDelegate> moduleInitialiser = [[classThatImplementsRCTBridgeDelegate alloc] init];

    RCTBridge *bridge = [[RCTBridge alloc] initWithDelegate:moduleInitialiser launchOptions:nil];

    RCTRootView *rootView = [[RCTRootView alloc]
                            initWithBridge:bridge
                                moduleName:kModuleName
                         initialProperties:nil];

 

Exporting Swift 

Swift doesn't have support for macros, so exposing native modules and
their methods to JavaScript inside React Native requires a bit more
setup. However, it works relatively the same. Let's say you have the
same  CalendarModule but as a Swift class:

    // CalendarManager.swift

    @objc(CalendarManager)
    class CalendarManager: NSObject {

     @objc(addEvent:location:date:)
     func addEvent(_ name: String, location: String, date: NSNumber) -> Void {
       // Date is ready to use!
     }

     @objc
     func constantsToExport() -> [String: Any]! {
       return ["someKey": "someValue"]
     }

    }

 

  It is important to use the  @objc modifiers to ensure the class and
  functions are exported properly to the Objective-C runtime.

Then create a private implementation file that will register the
required information with React Native:

    // CalendarManagerBridge.m
    #import <React/RCTBridgeModule.h>

    @interface RCT_EXTERN_MODULE(CalendarManager, NSObject)

    RCT_EXTERN_METHOD(addEvent:(NSString *)name location:(NSString *)location date:(nonnull NSNumber *)date)

    @end

 

For those of you new to Swift and Objective-C, whenever you mix the two
languages in an iOS project , you will also need an additional bridging
file, known as a bridging header, to expose the Objective-C files to
Swift. Xcode will offer to create this header file for you if you add
your Swift file to your app through the Xcode  File>New File menu
option. You will need to import  RCTBridgeModule.h in this header file.

    // CalendarManager-Bridging-Header.h
    #import <React/RCTBridgeModule.h>

 

You can also use  RCT_EXTERN_REMAP_MODULE and  _RCT_EXTERN_REMAP_METHOD
to alter the JavaScript name of the module or methods you are exporting.
For more information see  RCTBridgeModule .

  Important when making third party modules: Static libraries with Swift
  are only supported in Xcode 9 and later. In order for the Xcode
  project to build when you use Swift in the iOS static library you
  include in the module, your main app project must contain Swift code
  and a bridging header itself. If your app project does not contain any
  Swift code, a workaround can be a single empty .swift file and an
  empty bridging header.

Reserved Method Names 

invalidate() 

Native modules can conform to the RCTInvalidating protocol on iOS by
implementing the  invalidate() method. This method can be invoked when
the native bridge is invalidated (ie: on devmode reload). Please use
this mechanism as necessary to do the required cleanup for your native
module.

# iOS Native UI Components #
 _  ___  ____    _   _       _   _             _   _ ___ 
(_)/ _ \/ ___|  | \ | | __ _| |_(_)_   _____  | | | |_ _|
| | | | \___ \  |  \| |/ _` | __| \ \ / / _ \ | | | || | 
| | |_| |___) | | |\  | (_| | |_| |\ V /  __/ | |_| || | 
|_|\___/|____/  |_| \_|\__,_|\__|_| \_/ \___|  \___/|___|
                                                         
  ____                                             _       
 / ___|___  _ __ ___  _ __   ___  _ __   ___ _ __ | |_ ___ 
| |   / _ \| '_ ` _ \| '_ \ / _ \| '_ \ / _ \ '_ \| __/ __|
| |__| (_) | | | | | | |_) | (_) | | | |  __/ | | | |_\__ \
 \____\___/|_| |_| |_| .__/ \___/|_| |_|\___|_| |_|\__|___/
                     |_|                                   
-   iOS MapView example
-   Properties
-   Events
-   Handling multiple native views
-   Styles
iOS Native UI Components

 info

Native Module and Native Components are our stable technologies used by
the legacy architecture. They will be deprecated in the future when the
New Architecture will be stable. The New Architecture uses Turbo Native
Module and Fabric Native Components to achieve similar results.

There are tons of native UI widgets out there ready to be used in the
latest apps - some of them are part of the platform, others are
available as third-party libraries, and still more might be in use in
your very own portfolio. React Native has several of the most critical
platform components already wrapped, like  ScrollView and  TextInput ,
but not all of them, and certainly not ones you might have written
yourself for a previous app. Fortunately, we can wrap up these existing
components for seamless integration with your React Native application.

Like the native module guide, this too is a more advanced guide that
assumes you are somewhat familiar with iOS programming. This guide will
show you how to build a native UI component, walking you through the
implementation of a subset of the existing  MapView component available
in the core React Native library.

iOS MapView example 

Let's say we want to add an interactive Map to our app - might as well
use  MKMapView , we only need to make it usable from JavaScript.

Native views are created and manipulated by subclasses of
 RCTViewManager . These subclasses are similar in function to view
controllers, but are essentially singletons - only one instance of each
is created by the bridge. They expose native views to the  RCTUIManager
, which delegates back to them to set and update the properties of the
views as necessary. The  RCTViewManager s are also typically the
delegates for the views, sending events back to JavaScript via the
bridge.

To expose a view you can:

-   Subclass  RCTViewManager to create a manager for your component.
-   Add the  RCT_EXPORT_MODULE() marker macro.
-   Implement the  -(UIView *)view method.

RNTMapManager.m

    #import <MapKit/MapKit.h>

    #import <React/RCTViewManager.h>

    @interface RNTMapManager : RCTViewManager
    @end

    @implementation RNTMapManager

    RCT_EXPORT_MODULE(RNTMap)

    - (UIView *)view
    {
      return [[MKMapView alloc] init];
    }

    @end

 

 note

Do not attempt to set the  frame or  backgroundColor properties on the
 UIView instance that you expose through the  -view method. React Native
will overwrite the values set by your custom class in order to match
your JavaScript component's layout props. If you need this granularity
of control it might be better to wrap the  UIView instance you want to
style in another  UIView and return the wrapper  UIView instead. See
Issue 2948 for more context.

 info

In the example above, we prefixed our class name with  RNT . Prefixes
are used to avoid name collisions with other frameworks. Apple
frameworks use two-letter prefixes, and React Native uses  RCT as a
prefix. In order to avoid name collisions, we recommend using a
three-letter prefix other than  RCT in your own classes.

Then you need a little bit of JavaScript to make this a usable React
component:

MapView.tsx

    import {requireNativeComponent} from 'react-native';

    // requireNativeComponent automatically resolves 'RNTMap' to 'RNTMapManager'
    module.exports = requireNativeComponent('RNTMap');

 

MyApp.tsx

    import MapView from './MapView.tsx';

    ...

    render() {
      return <MapView style={{flex: 1}} />;
    }

 

Make sure to use  RNTMap here. We want to require the manager here,
which will expose the view of our manager for use in JavaScript.

 note

When rendering, don't forget to stretch the view, otherwise you'll be
staring at a blank screen.

      render() {
        return <MapView style={{flex: 1}} />;
      }

 

This is now a fully-functioning native map view component in JavaScript,
complete with pinch-zoom and other native gesture support. We can't
really control it from JavaScript yet, though :(

Properties 

The first thing we can do to make this component more usable is to
bridge over some native properties. Let's say we want to be able to
disable zooming and specify the visible region. Disabling zoom is a
boolean, so we add this one line:

RNTMapManager.m

    RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)

 

Note that we explicitly specify the type as  BOOL - React Native uses
 RCTConvert under the hood to convert all sorts of different data types
when talking over the bridge, and bad values will show convenient
"RedBox" errors to let you know there is an issue ASAP. When things are
straightforward like this, the whole implementation is taken care of for
you by this macro.

Now to actually disable zooming, we set the property in JS:

MyApp.tsx

    <MapView zoomEnabled={false} style={{flex: 1}} />

 

To document the properties (and which values they accept) of our MapView
component we'll add a wrapper component and document the interface with
React  PropTypes :

MapView.tsx

    import PropTypes from 'prop-types';
    import React from 'react';
    import {requireNativeComponent} from 'react-native';

    class MapView extends React.Component {
      render() {
        return <RNTMap {...this.props} />;
      }
    }

    MapView.propTypes = {
      /**
       * A Boolean value that determines whether the user may use pinch
       * gestures to zoom in and out of the map.
       */
      zoomEnabled: PropTypes.bool,
    };

    const RNTMap = requireNativeComponent('RNTMap');

    module.exports = MapView;

 

Now we have a nicely documented wrapper component to work with.

Next, let's add the more complex  region prop. We start by adding the
native code:

RNTMapManager.m

    RCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, MKMapView)
    {
      [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];
    }

 

Ok, this is more complicated than the  BOOL case we had before. Now we
have a  MKCoordinateRegion type that needs a conversion function, and we
have custom code so that the view will animate when we set the region
from JS. Within the function body that we provide,  json refers to the
raw value that has been passed from JS. There is also a  view variable
which gives us access to the manager's view instance, and a  defaultView
that we use to reset the property back to the default value if JS sends
us a null sentinel.

You could write any conversion function you want for your view - here is
the implementation for  MKCoordinateRegion via a category on  RCTConvert
. It uses an already existing category of ReactNative
 RCTConvert+CoreLocation :

RNTMapManager.m

    #import "RCTConvert+Mapkit.h"

 

RCTConvert+Mapkit.h

    #import <MapKit/MapKit.h>
    #import <React/RCTConvert.h>
    #import <CoreLocation/CoreLocation.h>
    #import <React/RCTConvert+CoreLocation.h>

    @interface RCTConvert (Mapkit)

    + (MKCoordinateSpan)MKCoordinateSpan:(id)json;
    + (MKCoordinateRegion)MKCoordinateRegion:(id)json;

    @end

    @implementation RCTConvert(MapKit)

    + (MKCoordinateSpan)MKCoordinateSpan:(id)json
    {
      json = [self NSDictionary:json];
      return (MKCoordinateSpan){
        [self CLLocationDegrees:json[@"latitudeDelta"]],
        [self CLLocationDegrees:json[@"longitudeDelta"]]
      };
    }

    + (MKCoordinateRegion)MKCoordinateRegion:(id)json
    {
      return (MKCoordinateRegion){
        [self CLLocationCoordinate2D:json],
        [self MKCoordinateSpan:json]
      };
    }

    @end

 

These conversion functions are designed to safely process any JSON that
the JS might throw at them by displaying "RedBox" errors and returning
standard initialization values when missing keys or other developer
errors are encountered.

To finish up support for the  region prop, we need to document it in
 propTypes :

MapView.tsx

    MapView.propTypes = {
      /**
       * A Boolean value that determines whether the user may use pinch
       * gestures to zoom in and out of the map.
       */
      zoomEnabled: PropTypes.bool,

      /**
       * The region to be displayed by the map.
       *
       * The region is defined by the center coordinates and the span of
       * coordinates to display.
       */
      region: PropTypes.shape({
        /**
         * Coordinates for the center of the map.
         */
        latitude: PropTypes.number.isRequired,
        longitude: PropTypes.number.isRequired,

        /**
         * Distance between the minimum and the maximum latitude/longitude
         * to be displayed.
         */
        latitudeDelta: PropTypes.number.isRequired,
        longitudeDelta: PropTypes.number.isRequired,
      }),
    };

 

MyApp.tsx

    render() {
      const region = {
        latitude: 37.48,
        longitude: -122.16,
        latitudeDelta: 0.1,
        longitudeDelta: 0.1,
      };
      return (
        <MapView
          region={region}
          zoomEnabled={false}
          style={{flex: 1}}
        />
      );
    }

 

Here you can see that the shape of the region is explicit in the JS
documentation.

Events 

So now we have a native map component that we can control freely from
JS, but how do we deal with events from the user, like pinch-zooms or
panning to change the visible region?

Until now we've only returned a  MKMapView instance from our manager's
 -(UIView *)view method. We can't add new properties to  MKMapView so we
have to create a new subclass from  MKMapView which we use for our View.
We can then add a  onRegionChange callback on this subclass:

RNTMapView.h

    #import <MapKit/MapKit.h>

    #import <React/RCTComponent.h>

    @interface RNTMapView: MKMapView

    @property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;

    @end

 

RNTMapView.m

    #import "RNTMapView.h"

    @implementation RNTMapView

    @end

 

Note that all  RCTBubblingEventBlock must be prefixed with  on . Next,
declare an event handler property on  RNTMapManager , make it a delegate
for all the views it exposes, and forward events to JS by calling the
event handler block from the native view.

RNTMapManager.m

    #import <MapKit/MapKit.h>
    #import <React/RCTViewManager.h>

    #import "RNTMapView.h"
    #import "RCTConvert+Mapkit.h"

    @interface RNTMapManager : RCTViewManager <MKMapViewDelegate>
    @end

    @implementation RNTMapManager

    RCT_EXPORT_MODULE()

    RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)
    RCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)

    RCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, MKMapView)
    {
      [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];
    }

    - (UIView *)view
    {
      RNTMapView *map = [RNTMapView new];
      map.delegate = self;
      return map;
    }

    #pragma mark MKMapViewDelegate

    - (void)mapView:(RNTMapView *)mapView regionDidChangeAnimated:(BOOL)animated
    {
      if (!mapView.onRegionChange) {
        return;
      }

      MKCoordinateRegion region = mapView.region;
      mapView.onRegionChange(@{
        @"region": @{
          @"latitude": @(region.center.latitude),
          @"longitude": @(region.center.longitude),
          @"latitudeDelta": @(region.span.latitudeDelta),
          @"longitudeDelta": @(region.span.longitudeDelta),
        }
      });
    }
    @end

 

In the delegate method  -mapView:regionDidChangeAnimated: the event
handler block is called on the corresponding view with the region data.
Calling the  onRegionChange event handler block results in calling the
same callback prop in JavaScript. This callback is invoked with the raw
event, which we typically process in the wrapper component to simplify
the API:

MapView.tsx

    class MapView extends React.Component {
      _onRegionChange = event => {
        if (!this.props.onRegionChange) {
          return;
        }

        // process raw event...
        this.props.onRegionChange(event.nativeEvent);
      };
      render() {
        return (
          <RNTMap
            {...this.props}
            onRegionChange={this._onRegionChange}
          />
        );
      }
    }
    MapView.propTypes = {
      /**
       * Callback that is called continuously when the user is dragging the map.
       */
      onRegionChange: PropTypes.func,
      ...
    };

 

MyApp.tsx

    class MyApp extends React.Component {
      onRegionChange(event) {
        // Do stuff with event.region.latitude, etc.
      }

      render() {
        const region = {
          latitude: 37.48,
          longitude: -122.16,
          latitudeDelta: 0.1,
          longitudeDelta: 0.1,
        };
        return (
          <MapView
            region={region}
            zoomEnabled={false}
            onRegionChange={this.onRegionChange}
          />
        );
      }
    }

 

Handling multiple native views 

A React Native view can have more than one child view in the view tree
eg.

    <View>
      <MyNativeView />
      <MyNativeView />
      <Button />
    </View>

 

In this example, the class  MyNativeView is a wrapper for a
 NativeComponent and exposes methods, which will be called on the iOS
platform.  MyNativeView is defined in  MyNativeView.ios.js and contains
proxy methods of  NativeComponent .

When the user interacts with the component, like clicking the button,
the  backgroundColor of  MyNativeView changes. In this case  UIManager
would not know which  MyNativeView should be handled and which one
should change  backgroundColor . Below you will find a solution to this
problem:

    <View>
      <MyNativeView ref={this.myNativeReference} />
      <MyNativeView ref={this.myNativeReference2} />
      <Button
        onPress={() => {
          this.myNativeReference.callNativeMethod();
        }}
      />
    </View>

 

Now the above component has a reference to a particular  MyNativeView
which allows us to use a specific instance of  MyNativeView . Now the
button can control which  MyNativeView should change its
 backgroundColor . In this example let's assume that  callNativeMethod
changes  backgroundColor .

MyNativeView.ios.tsx

    class MyNativeView extends React.Component {
      callNativeMethod = () => {
        UIManager.dispatchViewManagerCommand(
          ReactNative.findNodeHandle(this),
          UIManager.getViewManagerConfig('RNCMyNativeView').Commands
            .callNativeMethod,
          ,
        );
      };

      render() {
        return <NativeComponent ref={NATIVE_COMPONENT_REF} />;
      }
    }

 

 callNativeMethod is our custom iOS method which for example changes the
 backgroundColor which is exposed through  MyNativeView . This method
uses  UIManager.dispatchViewManagerCommand which needs 3 parameters:

-    (nonnull NSNumber \*)reactTag -  id of react view.
-    commandID:(NSInteger)commandID -  Id of the native method that
    should be called
-    commandArgs:(NSArray<id> \*)commandArgs -  Args of the native
    method that we can pass from JS to native.

RNCMyNativeViewManager.m

    #import <React/RCTViewManager.h>
    #import <React/RCTUIManager.h>
    #import <React/RCTLog.h>

    RCT_EXPORT_METHOD(callNativeMethod:(nonnull NSNumber*) reactTag) {
        [self.bridge.uiManager addUIBlock:^(RCTUIManager *uiManager, NSDictionary<NSNumber *,UIView *> *viewRegistry) {
            NativeView *view = viewRegistry[reactTag];
            if (!view || ![view isKindOfClass:[NativeView class]]) {
                RCTLogError(@"Cannot find NativeView with tag #%@", reactTag);
                return;
            }
            [view callNativeMethod];
        }];

    }

 

Here the  callNativeMethod is defined in the  RNCMyNativeViewManager.m
file and contains only one parameter which is
 (nonnull NSNumber*) reactTag . This exported function will find a
particular view using  addUIBlock which contains the  viewRegistry
parameter and returns the component based on  reactTag allowing it to
call the method on the correct component.

Styles 

Since all our native react views are subclasses of  UIView , most style
attributes will work like you would expect out of the box. Some
components will want a default style, however, for example  UIDatePicker
which is a fixed size. This default style is important for the layout
algorithm to work as expected, but we also want to be able to override
the default style when using the component.  DatePickerIOS does this by
wrapping the native component in an extra view, which has flexible
styling, and using a fixed style (which is generated with constants
passed in from native) on the inner native component:

DatePickerIOS.ios.tsx

    import {UIManager} from 'react-native';
    const RCTDatePickerIOSConsts = UIManager.RCTDatePicker.Constants;
    ...
      render: function() {
        return (
          <View style={this.props.style}>
            <RCTDatePickerIOS
              ref={DATEPICKER}
              style={styles.rkDatePickerIOS}
              ...
            />
          </View>
        );
      }
    });

    const styles = StyleSheet.create({
      rkDatePickerIOS: {
        height: RCTDatePickerIOSConsts.ComponentHeight,
        width: RCTDatePickerIOSConsts.ComponentWidth,
      },
    });

 

The  RCTDatePickerIOSConsts constants are exported from native by
grabbing the actual frame of the native component like so:

RCTDatePickerManager.m

    - (NSDictionary *)constantsToExport
    {
      UIDatePicker *dp = [[UIDatePicker alloc] init];
      [dp layoutIfNeeded];

      return @{
        @"ComponentHeight": @(CGRectGetHeight(dp.frame)),
        @"ComponentWidth": @(CGRectGetWidth(dp.frame)),
        @"DatePickerModes": @{
          @"time": @(UIDatePickerModeTime),
          @"date": @(UIDatePickerModeDate),
          @"datetime": @(UIDatePickerModeDateAndTime),
        }
      };
    }

 

This guide covered many of the aspects of bridging over custom native
components, but there is even more you might need to consider, such as
custom hooks for inserting and laying out subviews. If you want to go
even deeper, check out the source code of some of the implemented
components.

# JavaScript Environment #
     _                  ____            _       _   
    | | __ ___   ____ _/ ___|  ___ _ __(_)_ __ | |_ 
 _  | |/ _` \ \ / / _` \___ \ / __| '__| | '_ \| __|
| |_| | (_| |\ V / (_| |___) | (__| |  | | |_) | |_ 
 \___/ \__,_| \_/ \__,_|____/ \___|_|  |_| .__/ \__|
                                         |_|        
 _____            _                                      _   
| ____|_ ____   _(_)_ __ ___  _ __  _ __ ___   ___ _ __ | |_ 
|  _| | '_ \ \ / / | '__/ _ \| '_ \| '_ ` _ \ / _ \ '_ \| __|
| |___| | | \ V /| | | | (_) | | | | | | | | |  __/ | | | |_ 
|_____|_| |_|\_/ |_|_|  \___/|_| |_|_| |_| |_|\___|_| |_|\__|
                                                             
-   JavaScript Runtime
-   JavaScript Syntax Transformers
-   Polyfills
JavaScript Environment

JavaScript Runtime 

When using React Native, you're going to be running your JavaScript code
in up to three environments:

-   In most cases, React Native will use Hermes , an open-source
    JavaScript engine optimized for React Native.
-   If Hermes is disabled, React Native will use JavaScriptCore , the
    JavaScript engine that powers Safari. Note that on iOS,
    JavaScriptCore does not use JIT due to the absence of writable
    executable memory in iOS apps.
-   When using Chrome debugging, all JavaScript code runs within Chrome
    itself, communicating with native code via WebSockets. Chrome uses
    V8 as its JavaScript engine.

While these environments are very similar, you may end up hitting some
inconsistencies. It is best to avoid relying on specifics of any
runtime.

JavaScript Syntax Transformers 

Syntax transformers make writing code more enjoyable by allowing you to
use new JavaScript syntax without having to wait for support on all
interpreters.

React Native ships with the Babel JavaScript compiler . Check Babel
documentation on its supported transformations for more details.

A full list of React Native's enabled transformations can be found in
@react-native/babel-preset .

+-----------------------------------+-----------------------------------+
| Transformation                    | Code                              |
+===================================+===================================+
| ECMAScript 5                      |                                   |
+-----------------------------------+-----------------------------------+
| Reserved Words                    |                                   |
|                                   |  promise.catch(function() {...}); |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| ECMAScript 2015 (ES6)             |                                   |
+-----------------------------------+-----------------------------------+
| Arrow functions                   |     <C onPress={() => t           |
|                                   | his.setState({pressed: true})} /> |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Block scoping                     |     let greeting = 'hi';          |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Call spread                       |     Math.max(...array);           |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Classes                           |                                   |
|                                   |    class C extends React.Componen |
|                                   | t {render() { return <View />; }} |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Computed Properties               |     const key                     |
|                                   | = 'abc'; const obj = {[key]: 10}; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Constants                         |     const answer = 42;            |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Destructuring                     |     cons                          |
|                                   | t {isActive, style} = this.props; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| for…of                            |                                   |
|                                   | for (var num of [1, 2, 3]) {...}; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Function Name                     |     let number = x => x;          |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Literals                          |                                   |
|                                   | const b = 0b11; const o = 0o7; co |
|                                   | nst u = 'Hello\u{000A}\u{0009}!'; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Modules                           |     import                        |
|                                   |  React, {Component} from 'react'; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Object Concise Method             |     const                         |
|                                   |  obj = {method() { return 10; }}; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Object Short Notation             |     const na                      |
|                                   | me = 'vjeux'; const obj = {name}; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Parameters                        |     function test                 |
|                                   | (x = 'hello', {a, b}, ...args) {} |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Rest Params                       |     function(type, ...args) {};   |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Shorthand Properties              |     const o = {a, b, c};          |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Sticky Regex                      |     const a = /o+/y;              |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Template Literals                 |     const who = 'wo               |
|                                   | rld'; const str = `Hello ${who}`; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Unicode Regex                     |     co                            |
|                                   | nst string = 'foo💩bar'; const ma |
|                                   | tch = string.match(/foo(.)bar/u); |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| ECMAScript 2016 (ES7)             |                                   |
+-----------------------------------+-----------------------------------+
| Exponentiation Operator           |     let x = 10 ** 2;              |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| ECMAScript 2017 (ES8)             |                                   |
+-----------------------------------+-----------------------------------+
| Async Functions                   |     async                         |
|                                   |  function doStuffAsync() {const f |
|                                   | oo = await doOtherStuffAsync();}; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Function Trailing Comma           |     function f(a, b, c,) {};      |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| ECMAScript 2018 (ES9)             |                                   |
+-----------------------------------+-----------------------------------+
| Object Spread                     |                                   |
|                                   | const extended = {...obj, a: 10}; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| ECMAScript 2019 (ES10)            |                                   |
+-----------------------------------+-----------------------------------+
| Optional Catch Binding            |     try {thr                      |
|                                   | ow 0; } catch { doSomethingWhichD |
|                                   | oesNotCareAboutTheValueThrown();} |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| ECMAScript 2020 (ES11)            |                                   |
+-----------------------------------+-----------------------------------+
| Dynamic Imports                   |     const package = await impo    |
|                                   | rt('package'); package.function() |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Nullish Coalescing Operator       |     con                           |
|                                   | st foo = object.foo ?? 'default'; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Optional Chaining                 |     const name = obj.user?.name;  |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| ECMAScript 2022 (ES13)            |                                   |
+-----------------------------------+-----------------------------------+
| Class Fields                      |     class Bork {static a          |
|                                   | = 'foo'; static b; x = 'bar'; y;} |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Stage 1 Proposal                  |                                   |
+-----------------------------------+-----------------------------------+
| Export Default From               |     export v from 'mod';          |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Miscellaneous                     |                                   |
+-----------------------------------+-----------------------------------+
| Babel Template                    |     template(`const %%impor       |
|                                   | tName%% = require(%%source%%);`); |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Flow                              |     fun                           |
|                                   | ction foo(x: ?number): string {}; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| ESM to CJS                        |     export default 42;            |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| JSX                               |                                   |
|                                   |   <View style={{color: 'red'}} /> |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| Object Assign                     |     Object.assign(a, b);          |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| React Display Name                |                                   |
|                                   | const bar = createReactClass({}); |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+
| TypeScript                        |     f                             |
|                                   | unction foo(x: {hello: true, targ |
|                                   | et: 'react native!'}): string {}; |
|                                   |                                   |
|                                   |                               |
+-----------------------------------+-----------------------------------+

Polyfills 

Many standard functions are also available on all the supported
JavaScript runtimes.

Browser 

-   CommonJS  require
-     console.{log, warn, error, info, debug, trace, table, group, groupCollapsed, groupEnd} 
-    XMLHttpRequest ,  fetch
-    {set, clear}{Timeout, Interval, Immediate}, {request, cancel}AnimationFrame

ECMAScript 2015 (ES6) 

-    Array.from
-    Array.prototype.{  find  ,  findIndex  }
-    Object.assign
-    String.prototype.{  startsWith  ,  endsWith  ,  repeat  ,  includes  }

ECMAScript 2016 (ES7) 

-    Array.prototype.  includes 

ECMAScript 2017 (ES8) 

-    Object.{  entries  ,  values  }

Specific 

-    __DEV__

# Keyboard #
 _  __          _                         _ 
| |/ /___ _   _| |__   ___   __ _ _ __ __| |
| ' // _ \ | | | '_ \ / _ \ / _` | '__/ _` |
| . \  __/ |_| | |_) | (_) | (_| | | | (_| |
|_|\_\___|\__, |_.__/ \___/ \__,_|_|  \__,_|
          |___/                             
-   Usage
-   Methods
    -    addListener()
    -    dismiss()
    -    scheduleLayoutAnimation
    -    isVisible()
    -    metrics()
Keyboard

 Keyboard module to control keyboard events.

Usage 

The Keyboard module allows you to listen for native events and react to
them, as well as make changes to the keyboard, like dismissing it.

------------------------------------------------------------------------

Reference

Methods 

 addListener() 

    static addListener: (
      eventType: KeyboardEventName,
      listener: KeyboardEventListener,
    ) => EmitterSubscription;

 

The  addListener function connects a JavaScript function to an
identified native keyboard notification event.

This function then returns the reference to the listener.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| eventName             | string                | The string that       |
|                       |                       | identifies the event  |
| Required              |                       | you're listening for. |
|                       |                       | See the list below.   |
+-----------------------+-----------------------+-----------------------+
| callback              | function              | The function to be    |
|                       |                       | called when the event |
| Required              |                       | fires                 |
+-----------------------+-----------------------+-----------------------+

 eventName

This can be any of the following:

-    keyboardWillShow
-    keyboardDidShow
-    keyboardWillHide
-    keyboardDidHide
-    keyboardWillChangeFrame
-    keyboardDidChangeFrame

  Note that only  keyboardDidShow and  keyboardDidHide events are
  available on Android. The events will not be fired when using Android
  10 and under if your activity has  android:windowSoftInputMode set to
   adjustNothing .

------------------------------------------------------------------------

 dismiss() 

    static dismiss();

 

Dismisses the active keyboard and removes focus.

------------------------------------------------------------------------

 scheduleLayoutAnimation 

    static scheduleLayoutAnimation(event: KeyboardEvent);

 

Useful for syncing TextInput (or other keyboard accessory view) size of
position changes with keyboard movements.

------------------------------------------------------------------------

 isVisible() 

    static isVisible(): boolean;

 

Whether the keyboard is last known to be visible.

------------------------------------------------------------------------

 metrics() 

    static metrics(): KeyboardMetrics | undefined;

 

Return the metrics of the soft-keyboard if visible.

# KeyboardAvoidingView #
 _  __          _                         _    _             _     _ _       
| |/ /___ _   _| |__   ___   __ _ _ __ __| |  / \__   _____ (_) __| (_)_ __  
| ' // _ \ | | | '_ \ / _ \ / _` | '__/ _` | / _ \ \ / / _ \| |/ _` | | '_ \ 
| . \  __/ |_| | |_) | (_) | (_| | | | (_| |/ ___ \ V / (_) | | (_| | | | | |
|_|\_\___|\__, |_.__/ \___/ \__,_|_|  \__,_/_/   \_\_/ \___/|_|\__,_|_|_| |_|
          |___/                                                              
     __     ___               
  __ \ \   / (_) _____      __
 / _` \ \ / /| |/ _ \ \ /\ / /
| (_| |\ V / | |  __/\ V  V / 
 \__, | \_/  |_|\___| \_/\_/  
 |___/                        
-   Example
-   Props
    -   View Props
    -    behavior
    -    contentContainerStyle
    -    enabled
    -    keyboardVerticalOffset
KeyboardAvoidingView

This component will automatically adjust its height, position, or bottom
padding based on the keyboard height to remain visible while the virtual
keyboard is displayed.

Example 

------------------------------------------------------------------------

Reference

Props 

View Props 

Inherits View Props .

------------------------------------------------------------------------

 behavior 

Specify how to react to the presence of the keyboard.

  Android and iOS both interact with this prop differently. On both iOS
  and Android, setting  behavior is recommended.

  Type
  ----------------------------------------------
  enum(  'height' ,  'position' ,  'padding' )

------------------------------------------------------------------------

 contentContainerStyle 

The style of the content container (View) when behavior is  'position' .

  Type
  ------------
  View Style

------------------------------------------------------------------------

 enabled 

Enabled or disabled KeyboardAvoidingView.

  Type      Default
  --------- ---------
  boolean    true

------------------------------------------------------------------------

 keyboardVerticalOffset 

This is the distance between the top of the user screen and the react
native view, may be non-zero in some use cases.

  Type     Default
  -------- ---------
  number    0

# LayoutAnimation #
 _                            _      _          _                 _   _       
| |    __ _ _   _  ___  _   _| |_   / \   _ __ (_)_ __ ___   __ _| |_(_) ___  
| |   / _` | | | |/ _ \| | | | __| / _ \ | '_ \| | '_ ` _ \ / _` | __| |/ _ \ 
| |__| (_| | |_| | (_) | |_| | |_ / ___ \| | | | | | | | | | (_| | |_| | (_) |
|_____\__,_|\__, |\___/ \__,_|\__/_/   \_\_| |_|_|_| |_| |_|\__,_|\__|_|\___/ 
            |___/                                                             
       
 _ __  
| '_ \ 
| | | |
|_| |_|
       
-   Example
-   Methods
    -    configureNext()
    -    create()
-   Properties
    -   Types
    -   Properties
    -   Presets
    -    easeInEaseOut
    -    linear
    -    spring
LayoutAnimation

Automatically animates views to their new positions when the next layout
happens.

A common way to use this API is to call it before updating the state
hook in functional components and calling  setState in class components.

Note that in order to get this to work on Android you need to set the
following flags via  UIManager :

    if (Platform.OS === 'android') {
      if (UIManager.setLayoutAnimationEnabledExperimental) {
        UIManager.setLayoutAnimationEnabledExperimental(true);
      }
    }

 

Example 

------------------------------------------------------------------------

Reference

Methods 

 configureNext() 

    static configureNext(
      config: LayoutAnimationConfig,
      onAnimationDidEnd?: () => void,
      onAnimationDidFail?: () => void,
    );

 

Schedules an animation to happen on the next layout.

Parameters: 

  Name                 Type       Required   Description
  -------------------- ---------- ---------- -------------------------------------
  config               object     Yes        See config description below.
  onAnimationDidEnd    function   No         Called when the animation finished.
  onAnimationDidFail   function   No         Called when the animation failed.

The  config parameter is an object with the keys below.  create returns
a valid object for  config , and the  Presets objects can also all be
passed as the  config .

-    duration in milliseconds
-    create , optional config for animating in new views
-    update , optional config for animating views that have been updated
-    delete , optional config for animating views as they are removed

The config that's passed to  create ,  update , or  delete has the
following keys:

-    type , the animation type to use
-    property , the layout property to animate (optional, but
    recommended for  create and  delete )
-    springDamping (number, optional and only for use with
     type: Type.spring )
-    initialVelocity (number, optional)
-    delay (number, optional)
-    duration (number, optional)

------------------------------------------------------------------------

 create() 

    static create(duration, type, creationProp)

 

Helper that creates an object (with  create ,  update , and  delete
fields) to pass into  configureNext . The  type parameter is an
animation type , and the  creationProp parameter is a layout property .

Example:

Properties 

Types 

An enumeration of animation types to be used in the  create method, or
in the  create /  update /  delete configs for  configureNext . (example
usage:  LayoutAnimation.Types.easeIn )

  Types
  ---------------
  spring
  linear
  easeInEaseOut
  easeIn
  easeOut
  keyboard

------------------------------------------------------------------------

Properties 

An enumeration of layout properties to be animated to be used in the
 create method, or in the  create /  update /  delete configs for
 configureNext . (example usage:  LayoutAnimation.Properties.opacity )

  Properties
  ------------
  opacity
  scaleX
  scaleY
  scaleXY

------------------------------------------------------------------------

Presets 

A set of predefined animation configs to pass into  configureNext .

  Presets         Value
  --------------- ---------------------------------------------------------------------------------------------------------------------------------------------------------------
  easeInEaseOut    create(300, 'easeInEaseOut', 'opacity')
  linear           create(500, 'linear', 'opacity')
  spring           {duration: 700, create: {type: 'linear', property: 'opacity'}, update: {type: 'spring', springDamping: 0.4}, delete: {type: 'linear', property: 'opacity'} }

------------------------------------------------------------------------

 easeInEaseOut 

Calls  configureNext() with  Presets.easeInEaseOut .

------------------------------------------------------------------------

 linear 

Calls  configureNext() with  Presets.linear .

------------------------------------------------------------------------

 spring 

Calls  configureNext() with  Presets.spring .

Example:

# LayoutEvent Object Type #
 _                            _   _____                 _   
| |    __ _ _   _  ___  _   _| |_| ____|_   _____ _ __ | |_ 
| |   / _` | | | |/ _ \| | | | __|  _| \ \ / / _ \ '_ \| __|
| |__| (_| | |_| | (_) | |_| | |_| |___ \ V /  __/ | | | |_ 
|_____\__,_|\__, |\___/ \__,_|\__|_____| \_/ \___|_| |_|\__|
            |___/                                           
  ___  _     _           _     _____                 
 / _ \| |__ (_) ___  ___| |_  |_   _|   _ _ __   ___ 
| | | | '_ \| |/ _ \/ __| __|   | || | | | '_ \ / _ \
| |_| | |_) | |  __/ (__| |_    | || |_| | |_) |  __/
 \___/|_.__// |\___|\___|\__|   |_| \__, | .__/ \___|
          |__/                      |___/|_|         
-   Example
-   Keys and values
    -    height
    -    width
    -    x
    -    y
    -    target
-   Used by
LayoutEvent Object Type

 LayoutEvent object is returned in the callback as a result of component
layout change, for example  onLayout in View component.

Example 

    {
        layout: {
            width: 520,
            height: 70.5,
            x: 0,
            y: 42.5
        },
        target: 1127
    }

 

Keys and values 

 height 

Height of the component after the layout changes.

  Type     Optional
  -------- ----------
  number   No

 width 

Width of the component after the layout changes.

  Type     Optional
  -------- ----------
  number   No

 x 

Component X coordinate inside the parent component.

  Type     Optional
  -------- ----------
  number   No

 y 

Component Y coordinate inside the parent component.

  Type     Optional
  -------- ----------
  number   No

 target 

The node id of the element receiving the PressEvent.

  Type                         Optional
  ---------------------------- ----------
  number,  null ,  undefined   No

Used by 

-    Image
-    Pressable
-    ScrollView
-    Text
-    TextInput
-    TouchableWithoutFeedback
-    View

# Layout Props #
 _                            _     ____                      
| |    __ _ _   _  ___  _   _| |_  |  _ \ _ __ ___  _ __  ___ 
| |   / _` | | | |/ _ \| | | | __| | |_) | '__/ _ \| '_ \/ __|
| |__| (_| | |_| | (_) | |_| | |_  |  __/| | | (_) | |_) \__ \
|_____\__,_|\__, |\___/ \__,_|\__| |_|   |_|  \___/| .__/|___/
            |___/                                  |_|        
-   Example
-   Props
    -    alignContent
    -    alignItems
    -    alignSelf
    -    aspectRatio
    -    borderBottomWidth
    -    borderEndWidth
    -    borderLeftWidth
    -    borderRightWidth
    -    borderStartWidth
    -    borderTopWidth
    -    borderWidth
    -    bottom
    -    columnGap
    -    direction
    -    display
    -    end
    -    flex
    -    flexBasis
    -    flexDirection
    -    flexGrow
    -    flexShrink
    -    flexWrap
    -    gap
    -    height
    -    justifyContent
    -    left
    -    margin
    -    marginBottom
    -    marginEnd
    -    marginHorizontal
    -    marginLeft
    -    marginRight
    -    marginStart
    -    marginTop
    -    marginVertical
    -    maxHeight
    -    maxWidth
    -    minHeight
    -    minWidth
    -    overflow
    -    padding
    -    paddingBottom
    -    paddingEnd
    -    paddingHorizontal
    -    paddingLeft
    -    paddingRight
    -    paddingStart
    -    paddingTop
    -    paddingVertical
    -    position
    -    right
    -    rowGap
    -    start
    -    top
    -    width
    -    zIndex
Layout Props

  More detailed examples about those properties can be found on the
  Layout with Flexbox page.

Example 

The following example shows how different properties can affect or shape
a React Native layout. You can try for example to add or remove squares
from the UI while changing the values of the property  flexWrap .

-   TypeScript
-   JavaScript

------------------------------------------------------------------------

Reference

Props 

 alignContent 

 alignContent controls how rows align in the cross direction, overriding
the  alignContent of the parent. See
https://developer.mozilla.org/en-US/docs/Web/CSS/align-content for more
details.

  Type                                                                                   Required
  -------------------------------------------------------------------------------------- ----------
  enum('flex-start', 'flex-end', 'center', 'stretch', 'space-between', 'space-around')   No

------------------------------------------------------------------------

 alignItems 

 alignItems aligns children in the cross direction. For example, if
children are flowing vertically,  alignItems controls how they align
horizontally. It works like  align-items in CSS (default: stretch). See
https://developer.mozilla.org/en-US/docs/Web/CSS/align-items for more
details.

  Type                                                              Required
  ----------------------------------------------------------------- ----------
  enum('flex-start', 'flex-end', 'center', 'stretch', 'baseline')   No

------------------------------------------------------------------------

 alignSelf 

 alignSelf controls how a child aligns in the cross direction,
overriding the  alignItems of the parent. It works like  align-self in
CSS (default: auto). See
https://developer.mozilla.org/en-US/docs/Web/CSS/align-self for more
details.

  Type                                                                      Required
  ------------------------------------------------------------------------- ----------
  enum('auto', 'flex-start', 'flex-end', 'center', 'stretch', 'baseline')   No

------------------------------------------------------------------------

 aspectRatio 

Aspect ratio controls the size of the undefined dimension of a node. See
https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio for more
details.

-   On a node with a set width/height, aspect ratio controls the size of
    the unset dimension
-   On a node with a set flex basis, aspect ratio controls the size of
    the node in the cross axis if unset
-   On a node with a measure function, aspect ratio works as though the
    measure function measures the flex basis
-   On a node with flex grow/shrink, aspect ratio controls the size of
    the node in the cross axis if unset
-   Aspect ratio takes min/max dimensions into account

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 borderBottomWidth 

 borderBottomWidth works like  border-bottom-width in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-width for
more details.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 borderEndWidth 

When direction is  ltr ,  borderEndWidth is equivalent to
 borderRightWidth . When direction is  rtl ,  borderEndWidth is
equivalent to  borderLeftWidth .

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 borderLeftWidth 

 borderLeftWidth works like  border-left-width in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/border-left-width for
more details.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 borderRightWidth 

 borderRightWidth works like  border-right-width in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/border-right-width for
more details.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 borderStartWidth 

When direction is  ltr ,  borderStartWidth is equivalent to
 borderLeftWidth . When direction is  rtl ,  borderStartWidth is
equivalent to  borderRightWidth .

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 borderTopWidth 

 borderTopWidth works like  border-top-width in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-width for
more details.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 borderWidth 

 borderWidth works like  border-width in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/border-width for more
details.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 bottom 

 bottom is the number of logical pixels to offset the bottom edge of
this component.

It works similarly to  bottom in CSS, but in React Native you must use
points or percentages. Ems and other units are not supported.

See https://developer.mozilla.org/en-US/docs/Web/CSS/bottom for more
details of how  bottom affects layout.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 columnGap 

 columnGap works like  column-gap in CSS. Only pixel units are supported
in React Native. See
https://developer.mozilla.org/en-US/docs/Web/CSS/column-gap for more
details.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 direction 

 direction specifies the directional flow of the user interface. The
default is  inherit , except for root node which will have value based
on the current locale. See
https://www.yogalayout.dev/docs/styling/layout-direction for more
details.

  Type                            Required   Platform
  ------------------------------- ---------- ----------
  enum('inherit', 'ltr', 'rtl')   No         iOS

------------------------------------------------------------------------

 display 

 display sets the display type of this component.

It works similarly to  display in CSS but only supports 'flex' and
'none'. 'flex' is the default.

  Type                   Required
  ---------------------- ----------
  enum('none', 'flex')   No

------------------------------------------------------------------------

 end 

When the direction is  ltr ,  end is equivalent to  right . When the
direction is  rtl ,  end is equivalent to  left .

This style takes precedence over the  left and  right styles.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 flex 

In React Native  flex does not work the same way that it does in CSS.
 flex is a number rather than a string, and it works according to the
Yoga layout engine.

When  flex is a positive number, it makes the component flexible, and it
will be sized proportional to its flex value. So a component with  flex
set to 2 will take twice the space as a component with  flex set to 1.
 flex: <positive number> equates to
 flexGrow: <positive number>, flexShrink: 1, flexBasis: 0 .

When  flex is 0, the component is sized according to  width and  height
, and it is inflexible.

When  flex is -1, the component is normally sized according to  width
and  height . However, if there's not enough space, the component will
shrink to its  minWidth and  minHeight .

 flexGrow ,  flexShrink , and  flexBasis work the same as in CSS.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 flexBasis 

 flexBasis is an axis-independent way of providing the default size of
an item along the main axis. Setting the  flexBasis of a child is
similar to setting the  width of that child if its parent is a container
with  flexDirection: row or setting the  height of a child if its parent
is a container with  flexDirection: column . The  flexBasis of an item
is the default size of that item, the size of the item before any
 flexGrow and  flexShrink calculations are performed.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 flexDirection 

 flexDirection controls which directions children of a container go.
 row goes left to right,  column goes top to bottom, and you may be able
to guess what the other two do. It works like  flex-direction in CSS,
except the default is  column . See
https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction for more
details.

  Type                                                     Required
  -------------------------------------------------------- ----------
  enum('row', 'row-reverse', 'column', 'column-reverse')   No

------------------------------------------------------------------------

 flexGrow 

 flexGrow describes how any space within a container should be
distributed among its children along the main axis. After laying out its
children, a container will distribute any remaining space according to
the flex grow values specified by its children.

 flexGrow accepts any floating point value >= 0, with 0 being the
default value. A container will distribute any remaining space among its
children weighted by the children’s  flexGrow values.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 flexShrink 

 flexShrink describes how to shrink children along the main axis in the
case in which the total size of the children overflows the size of the
container on the main axis.  flexShrink is very similar to  flexGrow and
can be thought of in the same way if any overflowing size is considered
to be negative remaining space. These two properties also work well
together by allowing children to grow and shrink as needed.

 flexShrink accepts any floating point value >= 0, with 0 being the
default value. A container will shrink its children weighted by the
children’s  flexShrink values.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 flexWrap 

 flexWrap controls whether children can wrap around after they hit the
end of a flex container. It works like  flex-wrap in CSS (default:
nowrap). See https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap
for more details. Note it does not work anymore with
 alignItems: stretch (the default), so you may want to use
 alignItems: flex-start for example (breaking change details:
https://github.com/facebook/react-native/releases/tag/v0.28.0 ).

  Type                                     Required
  ---------------------------------------- ----------
  enum('wrap', 'nowrap', 'wrap-reverse')   No

------------------------------------------------------------------------

 gap 

 gap works like  gap in CSS. Only pixel units are supported in React
Native. See https://developer.mozilla.org/en-US/docs/Web/CSS/gap for
more details.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 height 

 height sets the height of this component.

It works similarly to  height in CSS, but in React Native you must use
points or percentages. Ems and other units are not supported. See
https://developer.mozilla.org/en-US/docs/Web/CSS/height for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 justifyContent 

 justifyContent aligns children in the main direction. For example, if
children are flowing vertically,  justifyContent controls how they align
vertically. It works like  justify-content in CSS (default: flex-start).
See https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content for
more details.

  Type                                                                                        Required
  ------------------------------------------------------------------------------------------- ----------
  enum('flex-start', 'flex-end', 'center', 'space-between', 'space-around', 'space-evenly')   No

------------------------------------------------------------------------

 left 

 left is the number of logical pixels to offset the left edge of this
component.

It works similarly to  left in CSS, but in React Native you must use
points or percentages. Ems and other units are not supported.

See https://developer.mozilla.org/en-US/docs/Web/CSS/left for more
details of how  left affects layout.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 margin 

Setting  margin has the same effect as setting each of  marginTop ,
 marginLeft ,  marginBottom , and  marginRight . See
https://developer.mozilla.org/en-US/docs/Web/CSS/margin for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 marginBottom 

 marginBottom works like  margin-bottom in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/margin-bottom for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 marginEnd 

When direction is  ltr ,  marginEnd is equivalent to  marginRight . When
direction is  rtl ,  marginEnd is equivalent to  marginLeft .

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 marginHorizontal 

Setting  marginHorizontal has the same effect as setting both
 marginLeft and  marginRight .

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 marginLeft 

 marginLeft works like  margin-left in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/margin-left for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 marginRight 

 marginRight works like  margin-right in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/margin-right for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 marginStart 

When direction is  ltr ,  marginStart is equivalent to  marginLeft .
When direction is  rtl ,  marginStart is equivalent to  marginRight .

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 marginTop 

 marginTop works like  margin-top in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/margin-top for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 marginVertical 

Setting  marginVertical has the same effect as setting both  marginTop
and  marginBottom .

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 maxHeight 

 maxHeight is the maximum height for this component, in logical pixels.

It works similarly to  max-height in CSS, but in React Native you must
use points or percentages. Ems and other units are not supported.

See https://developer.mozilla.org/en-US/docs/Web/CSS/max-height for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 maxWidth 

 maxWidth is the maximum width for this component, in logical pixels.

It works similarly to  max-width in CSS, but in React Native you must
use points or percentages. Ems and other units are not supported.

See https://developer.mozilla.org/en-US/docs/Web/CSS/max-width for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 minHeight 

 minHeight is the minimum height for this component, in logical pixels.

It works similarly to  min-height in CSS, but in React Native you must
use points or percentages. Ems and other units are not supported.

See https://developer.mozilla.org/en-US/docs/Web/CSS/min-height for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 minWidth 

 minWidth is the minimum width for this component, in logical pixels.

It works similarly to  min-width in CSS, but in React Native you must
use points or percentages. Ems and other units are not supported.

See https://developer.mozilla.org/en-US/docs/Web/CSS/min-width for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 overflow 

 overflow controls how children are measured and displayed.
 overflow: hidden causes views to be clipped while  overflow: scroll
causes views to be measured independently of their parents' main axis.
It works like  overflow in CSS (default: visible). See
https://developer.mozilla.org/en/docs/Web/CSS/overflow for more details.

  Type                                  Required
  ------------------------------------- ----------
  enum('visible', 'hidden', 'scroll')   No

------------------------------------------------------------------------

 padding 

Setting  padding has the same effect as setting each of  paddingTop ,
 paddingBottom ,  paddingLeft , and  paddingRight . See
https://developer.mozilla.org/en-US/docs/Web/CSS/padding for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 paddingBottom 

 paddingBottom works like  padding-bottom in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/padding-bottom for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 paddingEnd 

When direction is  ltr ,  paddingEnd is equivalent to  paddingRight .
When direction is  rtl ,  paddingEnd is equivalent to  paddingLeft .

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 paddingHorizontal 

Setting  paddingHorizontal is like setting both of  paddingLeft and
 paddingRight .

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 paddingLeft 

 paddingLeft works like  padding-left in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/padding-left for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 paddingRight 

 paddingRight works like  padding-right in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/padding-right for more
details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 paddingStart 

When direction is  ltr ,  paddingStart is equivalent to  paddingLeft .
When direction is  rtl ,  paddingStart is equivalent to  paddingRight .

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 paddingTop 

 paddingTop works like  padding-top in CSS. See
https://developer.mozilla.org/en-US/docs/Web/CSS/padding-top for more
details.

  Type              Required
  ----------------- ----------
  number, ,string   No

------------------------------------------------------------------------

 paddingVertical 

Setting  paddingVertical is like setting both of  paddingTop and
 paddingBottom .

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 position 

 position in React Native is similar to regular CSS, but everything is
set to  relative by default, so  absolute positioning is always relative
to the parent.

If you want to position a child using specific numbers of logical pixels
relative to its parent, set the child to have  absolute position.

If you want to position a child relative to something that is not its
parent, don't use styles for that. Use the component tree.

See https://github.com/facebook/yoga for more details on how  position
differs between React Native and CSS.

  Type                           Required
  ------------------------------ ----------
  enum('absolute', 'relative')   No

------------------------------------------------------------------------

 right 

 right is the number of logical pixels to offset the right edge of this
component.

It works similarly to  right in CSS, but in React Native you must use
points or percentages. Ems and other units are not supported.

See https://developer.mozilla.org/en-US/docs/Web/CSS/right for more
details of how  right affects layout.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 rowGap 

 rowGap works like  row-gap in CSS. Only pixel units are supported in
React Native. See
https://developer.mozilla.org/en-US/docs/Web/CSS/row-gap for more
details.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 start 

When the direction is  ltr ,  start is equivalent to  left . When the
direction is  rtl ,  start is equivalent to  right .

This style takes precedence over the  left ,  right , and  end styles.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 top 

 top is the number of logical pixels to offset the top edge of this
component.

It works similarly to  top in CSS, but in React Native you must use
points or percentages. Ems and other units are not supported.

See https://developer.mozilla.org/en-US/docs/Web/CSS/top for more
details of how  top affects layout.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 width 

 width sets the width of this component.

It works similarly to  width in CSS, but in React Native you must use
points or percentages. Ems and other units are not supported. See
https://developer.mozilla.org/en-US/docs/Web/CSS/width for more details.

  Type             Required
  ---------------- ----------
  number, string   No

------------------------------------------------------------------------

 zIndex 

 zIndex controls which components display on top of others. Normally,
you don't use  zIndex . Components render according to their order in
the document tree, so later components draw over earlier ones.  zIndex
may be useful if you have animations or custom modal interfaces where
you don't want this behavior.

It works like the CSS  z-index property - components with a larger
 zIndex will render on top. Think of the z-direction like it's pointing
from the phone into your eyeball. See
https://developer.mozilla.org/en-US/docs/Web/CSS/z-index for more
details.

On iOS,  zIndex may require  View s to be siblings of each other for it
to work as expected.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

# Layout with Flexbox #
 _                            _              _ _   _     
| |    __ _ _   _  ___  _   _| |_  __      _(_) |_| |__  
| |   / _` | | | |/ _ \| | | | __| \ \ /\ / / | __| '_ \ 
| |__| (_| | |_| | (_) | |_| | |_   \ V  V /| | |_| | | |
|_____\__,_|\__, |\___/ \__,_|\__|   \_/\_/ |_|\__|_| |_|
            |___/                                        
 _____ _           _               
|  ___| | _____  _| |__   _____  __
| |_  | |/ _ \ \/ / '_ \ / _ \ \/ /
|  _| | |  __/>  <| |_) | (_) >  < 
|_|   |_|\___/_/\_\_.__/ \___/_/\_\
                                   
-   Flex
-   Flex Direction
-   Layout Direction
-   Justify Content
-   Align Items
-   Align Self
-   Align Content
-   Flex Wrap
-   Flex Basis, Grow, and Shrink
-   Row Gap, Column Gap and Gap
-   Width and Height
-   Absolute & Relative Layout
-   Going Deeper
Layout with Flexbox

A component can specify the layout of its children using the Flexbox
algorithm. Flexbox is designed to provide a consistent layout on
different screen sizes.

You will normally use a combination of  flexDirection ,  alignItems ,
and  justifyContent to achieve the right layout.

 caution

Flexbox works the same way in React Native as it does in CSS on the web,
with a few exceptions. The defaults are different, with  flexDirection
defaulting to  column instead of  row ,  alignContent defaulting to
 flex-start instead of  stretch ,  flexShrink defaulting to  0 instead
of  1 , the  flex parameter only supporting a single number.

Flex 

 flex will define how your items are going to “fill” over the available
space along your main axis. Space will be divided according to each
element's flex property.

In the following example, the red, orange, and green views are all
children in the container view that has  flex: 1 set. The red view uses
 flex: 1 , the orange view uses  flex: 2 , and the green view uses
 flex: 3 . 1+2+3 = 6 , which means that the red view will get  1/6 of
the space, the orange  2/6 of the space, and the green  3/6 of the
space.

Flex Direction 

 flexDirection controls the direction in which the children of a node
are laid out. This is also referred to as the main axis. The cross axis
is the axis perpendicular to the main axis, or the axis which the
wrapping lines are laid out in.

-    column ( default value ) Align children from top to bottom. If
    wrapping is enabled, then the next line will start to the right of
    the first item on the top of the container.

-    row Align children from left to right. If wrapping is enabled, then
    the next line will start under the first item on the left of the
    container.

-    column-reverse Align children from bottom to top. If wrapping is
    enabled, then the next line will start to the right of the first
    item on the bottom of the container.

-    row-reverse Align children from right to left. If wrapping is
    enabled, then the next line will start under the first item on the
    right of the container.

You can learn more here .

-   TypeScript
-   JavaScript

Layout Direction 

Layout  direction specifies the direction in which children and text in
a hierarchy should be laid out. Layout direction also affects what edge
 start and  end refer to. By default, React Native lays out with LTR
layout direction. In this mode  start refers to left and  end refers to
right.

-    LTR ( default value ) Text and children are laid out from left to
    right. Margin and padding applied to the start of an element are
    applied on the left side.

-    RTL Text and children are laid out from right to left. Margin and
    padding applied to the start of an element are applied on the right
    side.

-   TypeScript
-   JavaScript

Justify Content 

 justifyContent describes how to align children within the main axis of
their container. For example, you can use this property to center a
child horizontally within a container with  flexDirection set to  row or
vertically within a container with  flexDirection set to  column .

-    flex-start ( default value ) Align children of a container to the
    start of the container's main axis.

-    flex-end Align children of a container to the end of the
    container's main axis.

-    center Align children of a container in the center of the
    container's main axis.

-    space-between Evenly space off children across the container's main
    axis, distributing the remaining space between the children.

-    space-around Evenly space off children across the container's main
    axis, distributing the remaining space around the children. Compared
    to  space-between , using  space-around will result in space being
    distributed to the beginning of the first child and end of the last
    child.

-    space-evenly Evenly distribute children within the alignment
    container along the main axis. The spacing between each pair of
    adjacent items, the main-start edge and the first item, and the
    main-end edge and the last item, are all exactly the same.

You can learn more here .

-   TypeScript
-   JavaScript

Align Items 

 alignItems describes how to align children along the cross axis of
their container. It is very similar to  justifyContent but instead of
applying to the main axis,  alignItems applies to the cross axis.

-    stretch ( default value ) Stretch children of a container to match
    the  height of the container's cross axis.

-    flex-start Align children of a container to the start of the
    container's cross axis.

-    flex-end Align children of a container to the end of the
    container's cross axis.

-    center Align children of a container in the center of the
    container's cross axis.

-    baseline Align children of a container along a common baseline.
    Individual children can be set to be the reference baseline for
    their parents.

 info

For  stretch to have an effect, children must not have a fixed dimension
along the secondary axis. In the following example, setting
 alignItems: stretch does nothing until the  width: 50 is removed from
the children.

You can learn more here .

-   TypeScript
-   JavaScript

Align Self 

 alignSelf has the same options and effect as  alignItems but instead of
affecting the children within a container, you can apply this property
to a single child to change its alignment within its parent.  alignSelf
overrides any option set by the parent with  alignItems .

-   TypeScript
-   JavaScript

Align Content 

alignContent defines the distribution of lines along the cross-axis.
This only has effect when items are wrapped to multiple lines using
 flexWrap .

-    flex-start ( default value ) Align wrapped lines to the start of
    the container's cross axis.

-    flex-end Align wrapped lines to the end of the container's cross
    axis.

-    stretch ( default value when using Yoga on the web ) Stretch
    wrapped lines to match the height of the container's cross axis.

-    center Align wrapped lines in the center of the container's cross
    axis.

-    space-between Evenly space wrapped lines across the container's
    cross axis, distributing the remaining space between the lines.

-    space-around Evenly space wrapped lines across the container's
    cross axis, distributing the remaining space around the lines.
    Compared to  space-between , using  space-around will result in
    space being distributed to the beginning of the first line and the
    end of the last line.

You can learn more here .

-   TypeScript
-   JavaScript

Flex Wrap 

The  flexWrap property is set on containers and it controls what happens
when children overflow the size of the container along the main axis. By
default, children are forced into a single line (which can shrink
elements). If wrapping is allowed, items are wrapped into multiple lines
along the main axis if needed.

When wrapping lines,  alignContent can be used to specify how the lines
are placed in the container. Learn more here .

-   TypeScript
-   JavaScript

Flex Basis, Grow, and Shrink 

-    flexBasis is an axis-independent way of providing the default size
    of an item along the main axis. Setting the  flexBasis of a child is
    similar to setting the  width of that child if its parent is a
    container with  flexDirection: row or setting the  height of a child
    if its parent is a container with  flexDirection: column . The
     flexBasis of an item is the default size of that item, the size of
    the item before any  flexGrow and  flexShrink calculations are
    performed.

-    flexGrow describes how much space within a container should be
    distributed among its children along the main axis. After laying out
    its children, a container will distribute any remaining space
    according to the flex grow values specified by its children.

     flexGrow accepts any floating point value >= 0, with 0 being the
    default value. A container will distribute any remaining space among
    its children weighted by the children’s  flexGrow values.

-    flexShrink describes how to shrink children along the main axis in
    the case in which the total size of the children overflows the size
    of the container on the main axis.  flexShrink is very similar to
     flexGrow and can be thought of in the same way if any overflowing
    size is considered to be negative remaining space. These two
    properties also work well together by allowing children to grow and
    shrink as needed.

     flexShrink accepts any floating point value >= 0, with 0 being the
    default value (on the web, the default is 1). A container will
    shrink its children weighted by the children’s  flexShrink values.

You can learn more here .

-   TypeScript
-   JavaScript

Row Gap, Column Gap and Gap 

-    rowGap sets the size of the gap (gutter) between an element's rows.

-    columnGap sets the size of the gap (gutter) between an element's
    columns.

-    gap sets the size of the gap (gutter) between rows and columns. It
    is a shorthand for  rowGap and  columnGap .

You can use  flexWrap and  alignContent alongwith  gap to add consistent
spacing between items.

-   TypeScript
-   JavaScript

Width and Height 

The  width property specifies the width of an element's content area.
Similarly, the  height property specifies the height of an element's
content area.

Both  width and  height can take the following values:

-    auto ( default value ) React Native calculates the width/height for
    the element based on its content, whether that is other children,
    text, or an image.

-    pixels Defines the width/height in absolute pixels. Depending on
    other styles set on the component, this may or may not be the final
    dimension of the node.

-    percentage Defines the width or height in percentage of its
    parent's width or height, respectively.

-   TypeScript
-   JavaScript

Absolute & Relative Layout 

The  position type of an element defines how it is positioned within its
parent.

-    relative ( default value ) By default, an element is positioned
    relatively. This means an element is positioned according to the
    normal flow of the layout, and then offset relative to that position
    based on the values of  top ,  right ,  bottom , and  left . The
    offset does not affect the position of any sibling or parent
    elements.

-    absolute When positioned absolutely, an element doesn't take part
    in the normal layout flow. It is instead laid out independent of its
    siblings. The position is determined based on the  top ,  right ,
     bottom , and  left values.

-   TypeScript
-   JavaScript

Going Deeper 

Check out the interactive yoga playground that you can use to get a
better understanding of flexbox.

We've covered the basics, but there are many other styles you may need
for layouts. The full list of props that control layout is documented
here .

Additionally, you can see some examples from Wix Engineers .

# Learn the Basics #
 _                            _   _            ____            _          
| |    ___  __ _ _ __ _ __   | |_| |__   ___  | __ )  __ _ ___(_) ___ ___ 
| |   / _ \/ _` | '__| '_ \  | __| '_ \ / _ \ |  _ \ / _` / __| |/ __/ __|
| |__|  __/ (_| | |  | | | | | |_| | | |  __/ | |_) | (_| \__ \ | (__\__ \
|_____\___|\__,_|_|  |_| |_|  \__|_| |_|\___| |____/ \__,_|___/_|\___|___/
                                                                          
-   Hello World
-   What's going on here?
-   Components
-   Props
-   State
Learn the Basics

React Native is like React, but it uses native components instead of web
components as building blocks. So to understand the basic structure of a
React Native app, you need to understand some of the basic React
concepts, like JSX, components,  state , and  props . If you already
know React, you still need to learn some React Native specific stuff,
like the native components. This tutorial is aimed at all audiences,
whether you have React experience or not.

Let's do this thing.

Hello World 

In accordance with the ancient traditions of our people, we must first
build an app that does nothing except say "Hello, world!". Here it is:

If you are feeling curious, you can play around with sample code
directly in the web simulators. You can also paste it into your  App.js
file to create a real app on your local machine.

What's going on here? 

1.  First of all, we need to import  React to be able to use  JSX ,
    which will then be transformed to the native components of each
    platform.
2.  On line 2, we import the  Text and  View components from
     react-native

Then we define the  HelloWorldApp function, which is a functional
component and behaves in the same way as in React for the web. This
function returns a  View component with some styles and a  Text as its
child.

The  Text component allows us to render a text, while the  View
component renders a container. This container has several styles
applied, let's analyze what each one is doing.

The first style that we find is  flex: 1 , the  flex prop will define
how your items are going to "fill" over the available space along your
main axis. Since we only have one container, it will take all the
available space of the parent component. In this case, it is the only
component, so it will take all the available screen space.

The following style is  justifyContent : "center". This aligns children
of a container in the center of the container's main axis. Finally, we
have  alignItems : "center", which aligns children of a container in the
center of the container's cross axis.

Some of the things in here might not look like JavaScript to you. Don't
panic. This is the future .

First of all, ES2015 (also known as ES6) is a set of improvements to
JavaScript that is now part of the official standard, but not yet
supported by all browsers, so often it isn't used yet in web
development. React Native ships with ES2015 support, so you can use this
stuff without worrying about compatibility.  import ,  export ,  const
and  from in the example above are all ES2015 features. If you aren't
familiar with ES2015, you can probably pick it up by reading through
sample code like this tutorial has. If you want, this page has a good
overview of ES2015 features.

The other unusual thing in this code example is
 <View><Text>Hello world!</Text></View> . This is JSX - a syntax for
embedding XML within JavaScript. Many frameworks use a specialized
templating language which lets you embed code inside markup language. In
React, this is reversed. JSX lets you write your markup language inside
code. It looks like HTML on the web, except instead of web things like
 <div> or  <span> , you use React components. In this case,  <Text> is a
Core Component that displays some text and  View is like the  <div> or
 <span> .

Components 

So this code is defining  HelloWorldApp , a new  Component . When you're
building a React Native app, you'll be making new components a lot.
Anything you see on the screen is some sort of component.

Props 

Most components can be customized when they are created, with different
parameters. These creation parameters are called props.

Your own components can also use  props . This lets you make a single
component that is used in many different places in your app, with
slightly different properties in each place. Refer to
 props.YOUR_PROP_NAME in your functional components or
 this.props.YOUR_PROP_NAME in your class components. Here's an example:

-   TypeScript
-   JavaScript

Using  name as a prop lets us customize the  Greeting component, so we
can reuse that component for each of our greetings. This example also
uses the  Greeting component in JSX. The power to do this is what makes
React so cool.

The other new thing going on here is the  View component. A  View is
useful as a container for other components, to help control style and
layout.

With  props and the basic  Text ,  Image , and  View components, you can
build a wide variety of static screens. To learn how to make your app
change over time, you need to learn about State .

State 

Unlike props that are read-only and should not be modified, the  state
allows React components to change their output over time in response to
user actions, network responses and anything else.

What's the difference between state and props in React? 

In a React component, the props are the variables that we pass from a
parent component to a child component. Similarly, the state are also
variables, with the difference that they are not passed as parameters,
but rather that the component initializes and manages them internally.

Are there differences between React and React Native to handle the state? 

    // ReactJS Counter Example using Hooks!

    import React, {useState} from 'react';



    const App = () => {
      const [count, setCount] = useState(0);

      return (
        <div className="container">
          <p>You clicked {count} times</p>
          <button
            onClick={() => setCount(count + 1)}>
            Click me!
          </button>
        </div>
      );
    };


    // CSS
    .container {
      display: flex;
      justify-content: center;
      align-items: center;
    }

 

    // React Native Counter Example using Hooks!

    import React, {useState} from 'react';
    import {View, Text, Button, StyleSheet} from 'react-native';

    const App = () => {
      const [count, setCount] = useState(0);

      return (
        <View style={styles.container}>
          <Text>You clicked {count} times</Text>
          <Button
            onPress={() => setCount(count + 1)}
            title="Click me!"
          />
        </View>
      );
    };

    // React Native Styles
    const styles = StyleSheet.create({
      container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
      },
    });

 

As shown above, there is no difference in handling the  state between
React and  React Native . You can use the state of your components both
in classes and in functional components using hooks !

In the following example we will show the same above counter example
using classes.

# Linking #
 _     _       _    _             
| |   (_)_ __ | | _(_)_ __   __ _ 
| |   | | '_ \| |/ / | '_ \ / _` |
| |___| | | | |   <| | | | | (_| |
|_____|_|_| |_|_|\_\_|_| |_|\__, |
                            |___/ 
-   Built-in URL Schemes
-   Enabling Deep Links
-   Handling Deep Links
-   Example
    -   Open Links and Deep Links (Universal Links)
    -   Open Custom Settings
    -   Get the Deep Link
    -   Send Intents (Android)
-   Methods
    -    addEventListener()
    -    canOpenURL()
    -    getInitialURL()
    -    openSettings()
    -    openURL()
    -    sendIntent()
        Android
Linking

 Linking gives you a general interface to interact with both incoming
and outgoing app links.

Every Link (URL) has a URL Scheme, some websites are prefixed with
 https:// or  http:// and the  http is the URL Scheme. Let's call it
scheme for short.

In addition to  https , you're likely also familiar with the  mailto
scheme. When you open a link with the mailto scheme, your operating
system will open an installed mail application. Similarly, there are
schemes for making phone calls and sending SMS. Read more about built-in
URL schemes below.

Like using the mailto scheme, it's possible to link to other
applications by using custom url schemes. For example, when you get a
Magic Link email from Slack, the Launch Slack button is an anchor tag
with an href that looks something like:
 slack://secret/magic-login/other-secret . Like with Slack, you can tell
the operating system that you want to handle a custom scheme. When the
Slack app opens, it receives the URL that was used to open it. This is
often referred to as deep linking. Read more about how to get the deep
link into your app.

Custom URL scheme isn't the only way to open your application on mobile.
You don't want to use a custom URL scheme in links in the email because
then the links would be broken on desktop. Instead, you want to use a
regular  https links such as  https://www.myapp.io/records/1234546 . and
on mobile you want that link open your app. Android calls it Deep Links
(Universal Links - iOS).

Built-in URL Schemes 

As mentioned in the introduction, there are some URL schemes for core
functionality that exist on every platform. The following is a
non-exhaustive list, but covers the most commonly used schemes.

  Scheme           Description                                  iOS   Android
  ---------------- -------------------------------------------- ----- ---------
   mailto          Open mail app, eg: mailto: support@expo.io   ✅    ✅
   tel             Open phone app, eg: tel:+123456789           ✅    ✅
   sms             Open SMS app, eg: sms:+123456789             ✅    ✅
   https /  http   Open web browser app, eg: https://expo.io    ✅    ✅

Enabling Deep Links 

Projects with Native Code Only

The following section only applies to projects with native code exposed.
If you are using the managed Expo workflow, see the guide on Linking in
the Expo documentation for the appropriate alternative.

If you want to enable deep links in your app, please read the below
guide:

-   Android
-   iOS

  For instructions on how to add support for deep linking on Android,
  refer to Enabling Deep Links for App Content - Add Intent Filters for
  Your Deep Links .

If you wish to receive the intent in an existing instance of
MainActivity, you may set the  launchMode of MainActivity to  singleTask
in  AndroidManifest.xml . See  <activity> documentation for more
information.

    <activity
      android:name=".MainActivity"
      android:launchMode="singleTask">

 

  NOTE: On iOS, you'll need to add the  LinkingIOS folder into your
  header search paths as described in step 3 here . If you also want to
  listen to incoming app links during your app's execution, you'll need
  to add the following lines to your  *AppDelegate.m :

    // iOS 9.x or newer
    #import <React/RCTLinkingManager.h>

    - (BOOL)application:(UIApplication *)application
       openURL:(NSURL *)url
       options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options
    {
      return [RCTLinkingManager application:application openURL:url options:options];
    }

 

If you're targeting iOS 8.x or older, you can use the following code
instead:

    // iOS 8.x or older
    #import <React/RCTLinkingManager.h>

    - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url
      sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
    {
      return [RCTLinkingManager application:application openURL:url
                          sourceApplication:sourceApplication annotation:annotation];
    }

 

If your app is using Universal Links , you'll need to add the following
code as well:

    - (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity
     restorationHandler:(nonnull void (^)(NSArray<id<UIUserActivityRestoring>> * _Nullable))restorationHandler
    {
     return [RCTLinkingManager application:application
                      continueUserActivity:userActivity
                        restorationHandler:restorationHandler];
    }

 

Handling Deep Links 

There are two ways to handle URLs that open your app.

1. If the app is already open, the app is foregrounded and a Linking 'url' event is fired 

You can handle these events with
 Linking.addEventListener('url', callback) - it calls  callback({url})
with the linked URL

2. If the app is not already open, it is opened and the url is passed in as the initialURL 

You can handle these events with  Linking.getInitialURL() - it returns a
Promise that resolves to the URL, if there is one.

------------------------------------------------------------------------

Example 

Open Links and Deep Links (Universal Links) 

-   TypeScript
-   JavaScript

Open Custom Settings 

-   TypeScript
-   JavaScript

Get the Deep Link 

-   TypeScript
-   JavaScript

Send Intents (Android) 

-   TypeScript
-   JavaScript

Reference

Methods 

 addEventListener() 

    static addEventListener(
      type: 'url',
      handler: (event: {url: string}) => void,
    ): EmitterSubscription;

 

Add a handler to Linking changes by listening to the  url event type and
providing the handler.

------------------------------------------------------------------------

 canOpenURL() 

    static canOpenURL(url: string): Promise<boolean>;

 

Determine whether or not an installed app can handle a given URL.

The method returns a  Promise object. When it is determined whether or
not the given URL can be handled, the promise is resolved and the first
parameter is whether or not it can be opened.

The  Promise will reject on Android if it was impossible to check if the
URL can be opened or when targetting Android 11 (SDK 30) if you didn't
specify the relevant intent queries in  AndroidManifest.xml . Similarly
on iOS, the promise will reject if you didn't add the specific scheme in
the  LSApplicationQueriesSchemes key inside  Info.plist (see bellow).

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| url                   | string                | The URL to open.      |
|                       |                       |                       |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+

  For web URLs, the protocol (  "http://" ,  "https://" ) must be set
  accordingly!

  This method has limitations on iOS 9+. From the official Apple
  documentation :

  -   If your app is linked against an earlier version of iOS but is
      running in iOS 9.0 or later, you can call this method up to 50
      times. After reaching that limit, subsequent calls always resolve
      to  false . If the user reinstalls or upgrades the app, iOS resets
      the limit.

  As of iOS 9, your app also needs to provide the
   LSApplicationQueriesSchemes key inside  Info.plist or  canOpenURL()
  will always resolve to  false .

  When targeting Android 11 (SDK 30) you must specify the intents for
  the schemes you want to handle in  AndroidManifest.xml . A list of
  common intents can be found here .

  For example to handle  https schemes the following needs to be added
  to your manifest:

      <manifest ...>
          <queries>
              <intent>
                  <action android:name="android.intent.action.VIEW" />
                  <data android:scheme="https"/>
              </intent>
          </queries>
      </manifest>

   

------------------------------------------------------------------------

 getInitialURL() 

    static getInitialURL(): Promise<string | null>;

 

If the app launch was triggered by an app link, it will give the link
url, otherwise it will give  null .

  To support deep linking on Android, refer
  https://developer.android.com/training/app-indexing/deep-linking.html#handling-intents

  getInitialURL may return  null while debugging is enabled. Disable the
  debugger to ensure it gets passed.

------------------------------------------------------------------------

 openSettings() 

    static openSettings(): Promise<void>;

 

Open the Settings app and displays the app’s custom settings, if it has
any.

------------------------------------------------------------------------

 openURL() 

    static openURL(url: string): Promise<any>;

 

Try to open the given  url with any of the installed apps.

You can use other URLs, like a location (e.g.
"geo:37.484847,-122.148386" on Android or "
https://maps.apple.com/?ll=37.484847,-122.148386 " on iOS), a contact,
or any other URL that can be opened with the installed apps.

The method returns a  Promise object. If the user confirms the open
dialog or the url automatically opens, the promise is resolved. If the
user cancels the open dialog or there are no registered applications for
the url, the promise is rejected.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| url                   | string                | The URL to open.      |
|                       |                       |                       |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+

  This method will fail if the system doesn't know how to open the
  specified URL. If you're passing in a non-http(s) URL, it's best to
  check  canOpenURL() first.

  For web URLs, the protocol (  "http://" ,  "https://" ) must be set
  accordingly!

  This method may behave differently in a simulator e.g.  "tel:" links
  are not able to be handled in the iOS simulator as there's no access
  to the dialer app.

------------------------------------------------------------------------

 sendIntent()

Android



    static sendIntent(
      action: string,
      extras?: Array<{key: string; value: string | number | boolean}>,
    ): Promise<void>;

 

Launch an Android intent with extras.

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| action                            | string                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+
| extras                            |  Array<{key: string, val          |
|                                   | ue: string ｜ number ｜ boolean}> |
+-----------------------------------+-----------------------------------+

# Linking Libraries #
 _     _       _    _               _     _ _                    _           
| |   (_)_ __ | | _(_)_ __   __ _  | |   (_) |__  _ __ __ _ _ __(_) ___  ___ 
| |   | | '_ \| |/ / | '_ \ / _` | | |   | | '_ \| '__/ _` | '__| |/ _ \/ __|
| |___| | | | |   <| | | | | (_| | | |___| | |_) | | | (_| | |  | |  __/\__ \
|_____|_|_| |_|_|\_\_|_| |_|\__, | |_____|_|_.__/|_|  \__,_|_|  |_|\___||___/
                            |___/                                            
-   Here are the few steps to link your libraries that contain native
    code
    -   Automatic linking
    -   Manual linking
Linking Libraries

Not every app uses all the native capabilities, and including the code
to support all those features would impact the binary size... But we
still want to support adding these features whenever you need them.

With that in mind we exposed many of these features as independent
static libraries.

For most of the libs it will be as quick as dragging two files,
sometimes a third step will be necessary, but no more than that.

 note

All the libraries we ship with React Native live in the  Libraries
folder in the root of the repository. Some of them are pure JavaScript,
and you only need to  require it. Other libraries also rely on some
native code, in that case you'll have to add these files to your app,
otherwise the app will throw an error as soon as you try to use the
library.

Here are the few steps to link your libraries that contain native code 

Automatic linking 

Install a library with native dependencies:

    npm install <library-with-native-dependencies> --save

 

 info

 --save or  --save-dev flag is very important for this step. React
Native will link your libs based on  dependencies and  devDependencies
in your  package.json file.

That's it! Next time you build your app the native code will be linked
thanks to the autolinking mechanism.

Manual linking 

Step 1 

If the library has native code, there must be an  .xcodeproj file inside
its folder. Drag this file to your project on Xcode (usually under the
 Libraries group on Xcode);



Step 2 

Click on your main project file (the one that represents the  .xcodeproj
) select  Build Phases and drag the static library from the  Products
folder inside the Library you are importing to
 Link Binary With Libraries



Step 3 

Not every library will need this step, what you need to consider is:

Do I need to know the contents of the library at compile time?

What that means is, are you using this library on the native side or
only in JavaScript? If you are only using it in JavaScript, you are good
to go!

If you do need to call it from native, then we need to know the
library's headers. To achieve that you have to go to your project's
file, select  Build Settings and search for  Header Search Paths . There
you should include the path to your library. (This documentation used to
recommend using  recursive , but this is no longer recommended, as it
can cause subtle build failures, especially with CocoaPods.)



# Metro #
 __  __      _             
|  \/  | ___| |_ _ __ ___  
| |\/| |/ _ \ __| '__/ _ \ 
| |  | |  __/ |_| | | (_) |
|_|  |_|\___|\__|_|  \___/ 
                           
-   Configuring Metro
    -   Advanced: Using a config function
-   Learn more about Metro
Metro

React Native uses Metro to build your JavaScript code and assets.

Configuring Metro 

Configuration options for Metro can be customized in your project's
 metro.config.js file. This can export either:

-   An object (recommended) that will be merged on top of Metro's
    internal config defaults.
-   A function that will be called with Metro's internal config defaults
    and should return a final config object.

 tip

Please see Configuring Metro on the Metro website for documentation on
all available config options.

In React Native, your Metro config should extend either
 @react-native/metro-config or  @expo/metro-config . These packages
contain essential defaults necessary to build and run React Native apps.

Below is the default  metro.config.js file in a React Native template
project:

    const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');

    /**
     * Metro configuration
     * https://facebook.github.io/metro/docs/configuration
     *
     * @type {import('metro-config').MetroConfig}
     */
    const config = {};

    module.exports = mergeConfig(getDefaultConfig(__dirname), config);

 

Metro options you wish to customize can be done so within the  config
object.

Advanced: Using a config function 

Exporting a config function is an opt-in to managing the final config
yourself — Metro will not apply any internal defaults . This pattern can
be useful when needing to read the base default config object from Metro
or to set options dynamically.

 info

From  @react-native/metro-config 0.72.1 , it is no longer necessary to
use a config function to access the complete default config. See the Tip
section below.

    const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');

    module.exports = function (baseConfig) {
      const defaultConfig = mergeConfig(baseConfig, getDefaultConfig(__dirname));
      const {resolver: {assetExts, sourceExts}} = defaultConfig;

      return mergeConfig(
        defaultConfig,
        {
          resolver: {
            assetExts: assetExts.filter(ext => ext !== 'svg'),
            sourceExts: [...sourceExts, 'svg'],
          },
        },
      );
    };

 

 tip

Using a config function is for advanced use cases. A simpler method than
the above, e.g. for customising  sourceExts , would be to read these
defaults from  @react-native/metro-config .

Alternative

    const defaultConfig = getDefaultConfig(__dirname);

    const config = {
      resolver: {
        sourceExts: [...defaultConfig.resolver.sourceExts, 'svg'],
      },
    };

    module.exports = mergeConfig(defaultConfig, config);

 

However! , we recommend copying and editing when overriding these config
values — placing the source of truth in your config file.

✅ Recommended

    const config = {
      resolver: {
        sourceExts: ['js', 'ts', 'tsx', 'svg'],
      },
    };

 

Learn more about Metro 

-   Metro website
-   Video: "Metro & React Native DevX" talk at App.js 2023

# Modal #
 __  __           _       _ 
|  \/  | ___   __| | __ _| |
| |\/| |/ _ \ / _` |/ _` | |
| |  | | (_) | (_| | (_| | |
|_|  |_|\___/ \__,_|\__,_|_|
                            
-   Example
-   Props
    -   View Props
    -    animated
    -    animationType
    -    hardwareAccelerated
        Android
    -    onDismiss
        iOS
    -    onOrientationChange
        iOS
    -    onRequestClose
    -    onShow
    -    presentationStyle
        iOS
    -    statusBarTranslucent
        Android
    -    supportedOrientations
        iOS
    -    transparent
    -    visible
Modal

The Modal component is a basic way to present content above an enclosing
view.

Example 

------------------------------------------------------------------------

Reference

Props 

View Props 

Inherits View Props .

------------------------------------------------------------------------

 animated 

  Deprecated. Use the  animationType prop instead.

------------------------------------------------------------------------

 animationType 

The  animationType prop controls how the modal animates.

Possible values:

-    slide slides in from the bottom,
-    fade fades into view,
-    none appears without an animation.

  Type                                   Default
  -------------------------------------- ---------
  enum(  'none' ,  'slide' ,  'fade' )    none

------------------------------------------------------------------------

 hardwareAccelerated

Android



The  hardwareAccelerated prop controls whether to force hardware
acceleration for the underlying window.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 onDismiss

iOS



The  onDismiss prop allows passing a function that will be called once
the modal has been dismissed.

  Type
  ----------
  function

------------------------------------------------------------------------

 onOrientationChange

iOS



The  onOrientationChange callback is called when the orientation changes
while the modal is being displayed. The orientation provided is only
'portrait' or 'landscape'. This callback is also called on initial
render, regardless of the current orientation.

  Type
  ----------
  function

------------------------------------------------------------------------

 onRequestClose 

The  onRequestClose callback is called when the user taps the hardware
back button on Android or the menu button on Apple TV. Because of this
required prop, be aware that  BackHandler events will not be emitted as
long as the modal is open. On iOS, this callback is called when a Modal
is being dismissed using a drag gesture when  presentationStyle is
 pageSheet or formSheet

+-----------------------------------------------------------------------+
| Type                                                                  |
+=======================================================================+
| function                                                              |
|                                                                       |
| Required                                                              |
|                                                                       |
| Android                                                               |
|                                                                       |
| TV                                                                    |
|                                                                       |
| -------------------------------------------------------------------   |
|                                                                       |
| function                                                              |
|                                                                       |
| iOS                                                                   |
+-----------------------------------------------------------------------+

------------------------------------------------------------------------

 onShow 

The  onShow prop allows passing a function that will be called once the
modal has been shown.

  Type
  ----------
  function

------------------------------------------------------------------------

 presentationStyle

iOS



The  presentationStyle prop controls how the modal appears (generally on
larger devices such as iPad or plus-sized iPhones). See
https://developer.apple.com/reference/uikit/uimodalpresentationstyle for
details.

Possible values:

-    fullScreen covers the screen completely
-    pageSheet covers portrait-width view centered (only on larger
    devices)
-    formSheet covers narrow-width view centered (only on larger
    devices)
-    overFullScreen covers the screen completely, but allows
    transparency

+-----------------------------------+-----------------------------------+
| Type                              | Default                           |
+===================================+===================================+
| enum(  'fullScreen' ,             |  fullScreen if                    |
|  'pageSheet' ,  'formSheet' ,     |  transparent={false}              |
|  'overFullScreen' )               |                                   |
|                                   | -------------------------------   |
|                                   |                                   |
|                                   |  overFullScreen if                |
|                                   |  transparent={true}               |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 statusBarTranslucent

Android



The  statusBarTranslucent prop determines whether your modal should go
under the system statusbar.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 supportedOrientations

iOS



The  supportedOrientations prop allows the modal to be rotated to any of
the specified orientations. On iOS, the modal is still restricted by
what's specified in your app's Info.plist's
UISupportedInterfaceOrientations field.

  When using  presentationStyle of  pageSheet or  formSheet , this
  property will be ignored by iOS.

  Type                                                                                                              Default
  ----------------------------------------------------------------------------------------------------------------- ---------------
  array of enums(  'portrait' ,  'portrait-upside-down' ,  'landscape' ,  'landscape-left' ,  'landscape-right' )    ['portrait']

------------------------------------------------------------------------

 transparent 

The  transparent prop determines whether your modal will fill the entire
view. Setting this to  true will render the modal over a transparent
background.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 visible 

The  visible prop determines whether your modal is visible.

  Type   Default
  ------ ---------
  bool    true

# More Resources #
 __  __                  ____                                         
|  \/  | ___  _ __ ___  |  _ \ ___  ___  ___  _   _ _ __ ___ ___  ___ 
| |\/| |/ _ \| '__/ _ \ | |_) / _ \/ __|/ _ \| | | | '__/ __/ _ \/ __|
| |  | | (_) | | |  __/ |  _ <  __/\__ \ (_) | |_| | | | (_|  __/\__ \
|_|  |_|\___/|_|  \___| |_| \_\___||___/\___/ \__,_|_|  \___\___||___/
                                                                      
-   Where to go from here
-   Dive deep
-   IDEs
-   Platforms to try
-   Example Apps
-   Find, make, and share your own Native Components and TurboModules
More Resources

There’s always more to learn: developer workflows, shipping to app
stores, internationalization, security and more.

Where to go from here 

-   Set up your environment
-   Set up your development workflow
-   Design and layout your app
-   Debug your app
-   Make your app cross platform
-   Get involved in the React Native community

Dive deep 

-   React’s Documentation
-   MDN’s JavaScript tutorials, reference, and guides
-   Android and iOS platform docs

IDEs 

We recommend using the VS Code code editor and its handy React Native
tools .

Platforms to try 

Expo is a framework of tools and services for React Native that focuses
on helping you build, ship, and iterate on your app, to use preview
deployment workflows that are popular with web development, and to
automate your development workflows. Expo also makes it possible to
build React Native apps without ever touching Xcode or Android Studio,
and it doesn't get in the way if you want to use those tools.

Ignite is a starter kit CLI with several React Native boilerplates. The
latest, Ignite Maverick, uses MobX-State-Tree for state management,
React Navigation, and other common libraries.It has generators for
screens, models, and more, and supports Expo out of the box. Ignite also
comes with a component library that is tuned for custom designs, theming
support, and testing. If you are looking for a preconfigured tech stack,
Ignite could be perfect for you.

Example Apps 

Try out apps from the Showcase to see what React Native is capable of!
Looking for something more hands on? Check out this set of example apps
on GitHub . You can look at their source code—try running one on a
simulator or device.

Find, make, and share your own Native Components and TurboModules 

React Native has a community of thousands of developers like you making
content, tools, tutorials—and Native Components!

Can’t find what you’re looking for in the Core Components? Visit React
Native Directory to find what the community has been creating.

Interested in making your own Native Component or Module? Making modules
for your own use case and sharing them with others on NPM and GitHub
helps grow the React Native ecosystem and community! Read the guides to
making your own Native Modules ( Android , iOS ) and Native Components (
Android , iOS ).

# Native Debugging #
 _   _       _   _           
| \ | | __ _| |_(_)_   _____ 
|  \| |/ _` | __| \ \ / / _ \
| |\  | (_| | |_| |\ V /  __/
|_| \_|\__,_|\__|_| \_/ \___|
                             
 ____       _                       _             
|  _ \  ___| |__  _   _  __ _  __ _(_)_ __   __ _ 
| | | |/ _ \ '_ \| | | |/ _` |/ _` | | '_ \ / _` |
| |_| |  __/ |_) | |_| | (_| | (_| | | | | | (_| |
|____/ \___|_.__/ \__,_|\__, |\__, |_|_| |_|\__, |
                        |___/ |___/         |___/ 
-   Accessing native logs
-   Debugging native code
    -   Android Studio
    -   Xcode
Native Debugging

Projects with Native Code Only

The following section only applies to projects with native code exposed.
If you are using the managed Expo workflow, see the guide on prebuild to
use this API.

Accessing native logs 

You can display the console logs for an iOS or Android app by using the
following commands in a terminal while the app is running:

    # For Android:
    npx react-native log-android
    # Or, for iOS:
    npx react-native log-ios

 

You may also access these through Debug > Open System Log… in the iOS
Simulator or by running  adb logcat "*:S" ReactNative:V ReactNativeJS:V
in a terminal while an Android app is running on a device or emulator.

 info

If you're using Expo CLI, console logs already appear in the same
terminal output as the bundler.

Debugging native code 

When working with native code, such as when writing native modules, you
can launch the app from Android Studio or Xcode and take advantage of
the native debugging features (setting up breakpoints, etc.) as you
would in case of building a standard native app.

Another option is to run your application using the React Native CLI and
attach the native debugger of the native IDE (Android Studio or Xcode)
to the process.

Android Studio 

On Android Studio you can do this by going on the "Run" option on the
menu bar, clicking on "Attach to Process..." and selecting the running
React Native app.

Xcode 

On Xcode click on "Debug" on the top menu bar, select the "Attach to
process" option, and select the application in the list of "Likely
Targets".

# Native Modules Intro #
 _   _       _   _             __  __           _       _           
| \ | | __ _| |_(_)_   _____  |  \/  | ___   __| |_   _| | ___  ___ 
|  \| |/ _` | __| \ \ / / _ \ | |\/| |/ _ \ / _` | | | | |/ _ \/ __|
| |\  | (_| | |_| |\ V /  __/ | |  | | (_) | (_| | |_| | |  __/\__ \
|_| \_|\__,_|\__|_| \_/ \___| |_|  |_|\___/ \__,_|\__,_|_|\___||___/
                                                                    
 ___       _             
|_ _|_ __ | |_ _ __ ___  
 | || '_ \| __| '__/ _ \ 
 | || | | | |_| | | (_) |
|___|_| |_|\__|_|  \___/ 
                         
-   Native Module Setup
-   Getting Started
Native Modules Intro

 info

Native Module and Native Components are our stable technologies used by
the legacy architecture. They will be deprecated in the future when the
New Architecture will be stable. The New Architecture uses Turbo Native
Module and Fabric Native Components to achieve similar results.

Sometimes a React Native app needs to access a native platform API that
is not available by default in JavaScript, for example the native APIs
to access Apple or Google Pay. Maybe you want to reuse some existing
Objective-C, Swift, Java or C++ libraries without having to reimplement
it in JavaScript, or write some high performance, multi-threaded code
for things like image processing.

The NativeModule system exposes instances of Java/Objective-C/C++
(native) classes to JavaScript (JS) as JS objects, thereby allowing you
to execute arbitrary native code from within JS. While we don't expect
this feature to be part of the usual development process, it is
essential that it exists. If React Native doesn't export a native API
that your JS app needs you should be able to export it yourself!

Native Module Setup 

There are two ways to write a native module for your React Native
application:

1.  Directly within your React Native application’s iOS/Android projects
2.  As a NPM package that can be installed as a dependency by your/other
    React Native applications

This guide will first walk you through implementing a native module
directly within a React Native application. However the native module
you build in the following guide can be distributed as an NPM package.
Check out the Setting Up a Native Module as a NPM Package guide if you
are interested in doing so.

Getting Started 

In the following sections we will walk you through guides on how to
build a native module directly within a React Native application. As a
prerequisite, you will need a React Native application to work within.
You can follow the steps here to setup a React Native application if you
do not already have one.

Imagine that you want to access the iOS/Android native calendar APIs
from JavaScript within a React Native application in order to create
calendar events. React Native does not expose a JavaScript API to
communicate with the native calendar libraries. However, through native
modules, you can write native code that communicates with native
calendar APIs. Then you can invoke that native code through JavaScript
in your React Native application.

In the following sections you will create such a Calendar native module
for both Android and iOS .

# Native Modules NPM Package Setup #
 _   _       _   _             __  __           _       _           
| \ | | __ _| |_(_)_   _____  |  \/  | ___   __| |_   _| | ___  ___ 
|  \| |/ _` | __| \ \ / / _ \ | |\/| |/ _ \ / _` | | | | |/ _ \/ __|
| |\  | (_| | |_| |\ V /  __/ | |  | | (_) | (_| | |_| | |  __/\__ \
|_| \_|\__,_|\__|_| \_/ \___| |_|  |_|\___/ \__,_|\__,_|_|\___||___/
                                                                    
 _   _ ____  __  __   ____            _                    
| \ | |  _ \|  \/  | |  _ \ __ _  ___| | ____ _  __ _  ___ 
|  \| | |_) | |\/| | | |_) / _` |/ __| |/ / _` |/ _` |/ _ \
| |\  |  __/| |  | | |  __/ (_| | (__|   < (_| | (_| |  __/
|_| \_|_|   |_|  |_| |_|   \__,_|\___|_|\_\__,_|\__, |\___|
                                                |___/      
 ____       _               
/ ___|  ___| |_ _   _ _ __  
\___ \ / _ \ __| | | | '_ \ 
 ___) |  __/ |_| |_| | |_) |
|____/ \___|\__|\__,_| .__/ 
                     |_|    

Native Modules NPM Package Setup

 info

Native Module and Native Components are our stable technologies used by
the legacy architecture. They will be deprecated in the future when the
New Architecture will be stable. The New Architecture uses Turbo Native
Module and Fabric Native Components to achieve similar results.

Native modules are usually distributed as npm packages, except that on
top of the usual JavaScript they will include some native code per
platform. To understand more about npm packages you may find this guide
useful.

To get set up with the basic project structure for a native module we
will use the community tool called create-react-native-library . You can
go ahead further and dive deep into how that library works, but for our
needs we will only execute the basic script:

    npx create-react-native-library@latest react-native-awesome-module

 

Where  react-native-awesome-module is the name you would like for the
new module. After doing this you will navigate into
 react-native-awesome-module folder and bootstrap the example project by
running:

    yarn

 

When the bootstrap is done, you will be able to start the example app by
executing one of the following commands:

    # Android app
    yarn example android
    # iOS app
    yarn example ios

 

When all steps above are done, you will be able to continue with Android
Native Modules or iOS Native Modules guides to add in some code.

  For a less opinionated setup, have a look at the third party tool
  create-react-native-module .

# Navigating Between Screens #
 _   _             _             _   _             
| \ | | __ ___   _(_) __ _  __ _| |_(_)_ __   __ _ 
|  \| |/ _` \ \ / / |/ _` |/ _` | __| | '_ \ / _` |
| |\  | (_| |\ V /| | (_| | (_| | |_| | | | | (_| |
|_| \_|\__,_| \_/ |_|\__, |\__,_|\__|_|_| |_|\__, |
                     |___/                   |___/ 
 ____       _                             ____                               
| __ )  ___| |___      _____  ___ _ __   / ___|  ___ _ __ ___  ___ _ __  ___ 
|  _ \ / _ \ __\ \ /\ / / _ \/ _ \ '_ \  \___ \ / __| '__/ _ \/ _ \ '_ \/ __|
| |_) |  __/ |_ \ V  V /  __/  __/ | | |  ___) | (__| | |  __/  __/ | | \__ \
|____/ \___|\__| \_/\_/ \___|\___|_| |_| |____/ \___|_|  \___|\___|_| |_|___/
                                                                             
-   React Navigation
    -   Installation and setup
    -   Usage
Navigating Between Screens

Mobile apps are rarely made up of a single screen. Managing the
presentation of, and transition between, multiple screens is typically
handled by what is known as a navigator.

This guide covers the various navigation components available in React
Native. If you are getting started with navigation, you will probably
want to use React Navigation . React Navigation provides a
straightforward navigation solution, with the ability to present common
stack navigation and tabbed navigation patterns on both Android and iOS.

If you're integrating React Native into an app that already manages
navigation natively, or looking for an alternative to React Navigation,
the following library provides native navigation on both platforms:
react-native-navigation .

React Navigation 

The community solution to navigation is a standalone library that allows
developers to set up the screens of an app with a few lines of code.

Installation and setup 

First, you need to install them in your project:

    npm install @react-navigation/native @react-navigation/native-stack

 

Next, install the required peer dependencies. You need to run different
commands depending on whether your project is an Expo managed project or
a bare React Native project.

-   If you have an Expo managed project, install the dependencies with
     expo :

        npx expo install react-native-screens react-native-safe-area-context

     

-   If you have a bare React Native project, install the dependencies
    with  npm :

        npm install react-native-screens react-native-safe-area-context

     

    For iOS with bare React Native project, make sure you have CocoaPods
    installed. Then install the pods to complete the installation:

        cd ios
        pod install
        cd ..

     

 note

You might get warnings related to peer dependencies after installation.
They are usually caused by incorrect version ranges specified in some
packages. You can safely ignore most warnings as long as your app
builds.

Now, you need to wrap the whole app in  NavigationContainer . Usually
you'd do this in your entry file, such as  index.js or  App.js :

    import * as React from 'react';
    import {NavigationContainer} from '@react-navigation/native';

    const App = () => {
      return (
        <NavigationContainer>
          {/* Rest of your app code */}
        </NavigationContainer>
      );
    };

    export default App;

 

Now you are ready to build and run your app on the device/simulator.

Usage 

Now you can create an app with a home screen and a profile screen:

    import * as React from 'react';
    import {NavigationContainer} from '@react-navigation/native';
    import {createNativeStackNavigator} from '@react-navigation/native-stack';

    const Stack = createNativeStackNavigator();

    const MyStack = () => {
      return (
        <NavigationContainer>
          <Stack.Navigator>
            <Stack.Screen
              name="Home"
              component={HomeScreen}
              options={{title: 'Welcome'}}
            />
            <Stack.Screen name="Profile" component={ProfileScreen} />
          </Stack.Navigator>
        </NavigationContainer>
      );
    };

 

In this example, there are 2 screens (  Home and  Profile ) defined
using the  Stack.Screen component. Similarly, you can define as many
screens as you like.

You can set options such as the screen title for each screen in the
 options prop of  Stack.Screen .

Each screen takes a  component prop that is a React component. Those
components receive a prop called  navigation which has various methods
to link to other screens. For example, you can use  navigation.navigate
to go to the  Profile screen:

    const HomeScreen = ({navigation}) => {
      return (
        <Button
          title="Go to Jane's profile"
          onPress={() =>
            navigation.navigate('Profile', {name: 'Jane'})
          }
        />
      );
    };
    const ProfileScreen = ({navigation, route}) => {
      return <Text>This is {route.params.name}'s profile</Text>;
    };

 

This  native-stack navigator uses the native APIs:
 UINavigationController on iOS and  Fragment on Android so that
navigation built with  createNativeStackNavigator will behave the same
and have the same performance characteristics as apps built natively on
top of those APIs.

React Navigation also has packages for different kind of navigators such
as tabs and drawer. You can use them to implement various patterns in
your app.

For a complete intro to React Navigation, follow the React Navigation
Getting Started Guide .

# Networking #
 _   _      _                      _    _             
| \ | | ___| |___      _____  _ __| | _(_)_ __   __ _ 
|  \| |/ _ \ __\ \ /\ / / _ \| '__| |/ / | '_ \ / _` |
| |\  |  __/ |_ \ V  V / (_) | |  |   <| | | | | (_| |
|_| \_|\___|\__| \_/\_/ \___/|_|  |_|\_\_|_| |_|\__, |
                                                |___/ 
-   Using Fetch
    -   Making requests
    -   Handling the response
-   Using Other Networking Libraries
-   WebSocket Support
-   Known Issues with  fetch and cookie based authentication
-   Configuring NSURLSession on iOS
Networking

Many mobile apps need to load resources from a remote URL. You may want
to make a POST request to a REST API, or you may need to fetch a chunk
of static content from another server.

Using Fetch 

React Native provides the Fetch API for your networking needs. Fetch
will seem familiar if you have used  XMLHttpRequest or other networking
APIs before. You may refer to MDN's guide on Using Fetch for additional
information.

Making requests 

In order to fetch content from an arbitrary URL, you can pass the URL to
fetch:

    fetch('https://mywebsite.com/mydata.json');

 

Fetch also takes an optional second argument that allows you to
customize the HTTP request. You may want to specify additional headers,
or make a POST request:

    fetch('https://mywebsite.com/endpoint/', {
      method: 'POST',
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        firstParam: 'yourValue',
        secondParam: 'yourOtherValue',
      }),
    });

 

Take a look at the Fetch Request docs for a full list of properties.

Handling the response 

The above examples show how you can make a request. In many cases, you
will want to do something with the response.

Networking is an inherently asynchronous operation. Fetch method will
return a Promise that makes it straightforward to write code that works
in an asynchronous manner:

    const getMoviesFromApi = () => {
      return fetch('https://reactnative.dev/movies.json')
        .then(response => response.json())
        .then(json => {
          return json.movies;
        })
        .catch(error => {
          console.error(error);
        });
    };

 

You can also use the  async /  await syntax in a React Native app:

    const getMoviesFromApiAsync = async () => {
      try {
        const response = await fetch(
          'https://reactnative.dev/movies.json',
        );
        const json = await response.json();
        return json.movies;
      } catch (error) {
        console.error(error);
      }
    };

 

Don't forget to catch any errors that may be thrown by  fetch ,
otherwise they will be dropped silently.

-   TypeScript
-   JavaScript

  By default, iOS 9.0 or later enforce App Transport Secruity (ATS). ATS
  requires any HTTP connection to use HTTPS. If you need to fetch from a
  cleartext URL (one that begins with  http ) you will first need to add
  an ATS exception . If you know ahead of time what domains you will
  need access to, it is more secure to add exceptions only for those
  domains; if the domains are not known until runtime you can disable
  ATS completely . Note however that from January 2017, Apple's App
  Store review will require reasonable justification for disabling ATS .
  See Apple's documentation for more information.

  On Android, as of API Level 28, clear text traffic is also blocked by
  default. This behaviour can be overridden by setting
   android:usesCleartextTraffic in the app manifest file.

Using Other Networking Libraries 

The XMLHttpRequest API is built into React Native. This means that you
can use third party libraries such as frisbee or axios that depend on
it, or you can use the XMLHttpRequest API directly if you prefer.

    const request = new XMLHttpRequest();
    request.onreadystatechange = e => {
      if (request.readyState !== 4) {
        return;
      }

      if (request.status === 200) {
        console.log('success', request.responseText);
      } else {
        console.warn('error');
      }
    };

    request.open('GET', 'https://mywebsite.com/endpoint/');
    request.send();

 

  The security model for XMLHttpRequest is different than on web as
  there is no concept of CORS in native apps.

WebSocket Support 

React Native also supports WebSockets , a protocol which provides
full-duplex communication channels over a single TCP connection.

    const ws = new WebSocket('ws://host.com/path');

    ws.onopen = () => {
      // connection opened
      ws.send('something'); // send a message
    };

    ws.onmessage = e => {
      // a message was received
      console.log(e.data);
    };

    ws.onerror = e => {
      // an error occurred
      console.log(e.message);
    };

    ws.onclose = e => {
      // connection closed
      console.log(e.code, e.reason);
    };

 

Known Issues with  fetch and cookie based authentication 

The following options are currently not working with  fetch

-    redirect:manual
-    credentials:omit

-   Having same name headers on Android will result in only the latest
    one being present. A temporary solution can be found here:
    https://github.com/facebook/react-native/issues/18837#issuecomment-398779994
    .
-   Cookie based authentication is currently unstable. You can view some
    of the issues raised here:
    https://github.com/facebook/react-native/issues/23185
-   As a minimum on iOS, when redirected through a  302 , if a
     Set-Cookie header is present, the cookie is not set properly. Since
    the redirect cannot be handled manually this might cause a scenario
    where infinite requests occur if the redirect is the result of an
    expired session.

Configuring NSURLSession on iOS 

For some applications it may be appropriate to provide a custom
 NSURLSessionConfiguration for the underlying  NSURLSession that is used
for network requests in a React Native application running on iOS. For
instance, one may need to set a custom user agent string for all network
requests coming from the app or supply  NSURLSession with an ephemeral
 NSURLSessionConfiguration . The function
 RCTSetCustomNSURLSessionConfigurationProvider allows for such
customization. Remember to add the following import to the file in which
 RCTSetCustomNSURLSessionConfigurationProvider will be called:

    #import <React/RCTHTTPRequestHandler.h>

 

 RCTSetCustomNSURLSessionConfigurationProvider should be called early in
the application life cycle such that it is readily available when needed
by React, for instance:

    -(void)application:(__unused UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

      // set RCTSetCustomNSURLSessionConfigurationProvider
      RCTSetCustomNSURLSessionConfigurationProvider(^NSURLSessionConfiguration *{
         NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
         // configure the session
         return configuration;
      });

      // set up React
      _bridge = [[RCTBridge alloc] initWithDelegate:self launchOptions:launchOptions];
    }

 

# Optimizing Flatlist Configuration #
  ___        _   _           _     _             
 / _ \ _ __ | |_(_)_ __ ___ (_)___(_)_ __   __ _ 
| | | | '_ \| __| | '_ ` _ \| |_  / | '_ \ / _` |
| |_| | |_) | |_| | | | | | | |/ /| | | | | (_| |
 \___/| .__/ \__|_|_| |_| |_|_/___|_|_| |_|\__, |
      |_|                                  |___/ 
 _____ _       _   _ _     _   
|  ___| | __ _| |_| (_)___| |_ 
| |_  | |/ _` | __| | / __| __|
|  _| | | (_| | |_| | \__ \ |_ 
|_|   |_|\__,_|\__|_|_|___/\__|
                               
  ____             __ _                       _   _             
 / ___|___  _ __  / _(_) __ _ _   _ _ __ __ _| |_(_) ___  _ __  
| |   / _ \| '_ \| |_| |/ _` | | | | '__/ _` | __| |/ _ \| '_ \ 
| |__| (_) | | | |  _| | (_| | |_| | | | (_| | |_| | (_) | | | |
 \____\___/|_| |_|_| |_|\__, |\__,_|_|  \__,_|\__|_|\___/|_| |_|
                        |___/                                   
-   Terms
-   Props
    -   removeClippedSubviews
    -   maxToRenderPerBatch
    -   updateCellsBatchingPeriod
    -   initialNumToRender
    -   windowSize
-   List items
    -   Use basic components
    -   Use light components
    -   Use  memo()
    -   Use cached optimized images
    -   Use getItemLayout
    -   Use keyExtractor or key
    -   Avoid anonymous function on renderItem
Optimizing Flatlist Configuration

Terms 

-   VirtualizedList: The component behind  FlatList (React Native's
    implementation of the  Virtual List concept.)

-   Memory consumption: How much information about your list is being
    stored in memory, which could lead to an app crash.

-   Responsiveness: Application ability to respond to interactions. Low
    responsiveness, for instance, is when you touch on a component and
    it waits a bit to respond, instead of responding immediately as
    expected.

-   Blank areas: When  VirtualizedList can't render your items fast
    enough, you may enter a part of your list with non-rendered
    components that appear as blank space.

-   Viewport: The visible area of content that is rendered to pixels.

-   Window: The area in which items should be mounted, which is
    generally much larger than the viewport.

Props 

Here are a list of props that can help to improve  FlatList performance:

removeClippedSubviews 

  Type      Default
  --------- ---------
  Boolean   False

If  true , views that are outside of the viewport are detached from the
native view hierarchy.

Pros: This reduces time spent on the main thread, and thus reduces the
risk of dropped frames, by excluding views outside of the viewport from
the native rendering and drawing traversals.

Cons: Be aware that this implementation can have bugs, such as missing
content (mainly observed on iOS), especially if you are doing complex
things with transforms and/or absolute positioning. Also note this does
not save significant memory because the views are not deallocated, only
detached.

maxToRenderPerBatch 

  Type     Default
  -------- ---------
  Number   10

It is a  VirtualizedList prop that can be passed through  FlatList .
This controls the amount of items rendered per batch, which is the next
chunk of items rendered on every scroll.

Pros: Setting a bigger number means less visual blank areas when
scrolling (increases the fill rate).

Cons: More items per batch means longer periods of JavaScript execution
potentially blocking other event processing, like presses, hurting
responsiveness.

updateCellsBatchingPeriod 

  Type     Default
  -------- ---------
  Number   50

While  maxToRenderPerBatch tells the amount of items rendered per batch,
setting  updateCellsBatchingPeriod tells your  VirtualizedList the delay
in milliseconds between batch renders (how frequently your component
will be rendering the windowed items).

Pros: Combining this prop with  maxToRenderPerBatch gives you the power
to, for example, render more items in a less frequent batch, or less
items in a more frequent batch.

Cons: Less frequent batches may cause blank areas, More frequent batches
may cause responsiveness issues.

initialNumToRender 

  Type     Default
  -------- ---------
  Number   10

The initial amount of items to render.

Pros: Define precise number of items that would cover the screen for
every device. This can be a big performance boost for the initial
render.

Cons: Setting a low  initialNumToRender may cause blank areas,
especially if it's too small to cover the viewport on initial render.

windowSize 

  Type     Default
  -------- ---------
  Number   21

The number passed here is a measurement unit where 1 is equivalent to
your viewport height. The default value is 21 (10 viewports above, 10
below, and one in between).

Pros: Bigger  windowSize will result in less chance of seeing blank
space while scrolling. On the other hand, smaller  windowSize will
result in fewer items mounted simultaneously, saving memory.

Cons: For a bigger  windowSize , you will have more memory consumption.
For a lower  windowSize , you will have a bigger chance of seeing blank
areas.

List items 

Below are some tips about list item components. They are the core of
your list, so they need to be fast.

Use basic components 

The more complex your components are, the slower they will render. Try
to avoid a lot of logic and nesting in your list items. If you are
reusing this list item component a lot in your app, create a component
only for your big lists and make them with as little logic and nesting
as possible.

Use light components 

The heavier your components are, the slower they render. Avoid heavy
images (use a cropped version or thumbnail for list items, as small as
possible). Talk to your design team, use as little effects and
interactions and information as possible in your list. Show them in your
item's detail.

Use  memo() 

 React.memo() creates a memoized component that will be re-rendered only
when the props passed to the component change. We can use this function
to optimize the components in the FlatList.

    import React, {memo} from 'react';
    import {View, Text} from 'react-native';

    const MyListItem = memo(
      ({title}: {title: string}) => (
        <View>
          <Text>{title}</Text>
        </View>
      ),
      (prevProps, nextProps) => {
        return prevProps.title === nextProps.title;
      },
    );

    export default MyListItem;

 

In this example, we have determined that MyListItem should be
re-rendered only when the title changes. We passed the comparison
function as the second argument to React.memo() so that the component is
re-rendered only when the specified prop is changed. If the comparison
function returns true, the component will not be re-rendered.

Use cached optimized images 

You can use the community packages (such as react-native-fast-image from
@DylanVann ) for more performant images. Every image in your list is a
 new Image() instance. The faster it reaches the  loaded hook, the
faster your JavaScript thread will be free again.

Use getItemLayout 

If all your list item components have the same height (or width, for a
horizontal list), providing the getItemLayout prop removes the need for
your  FlatList to manage async layout calculations. This is a very
desirable optimization technique.

If your components have dynamic size and you really need performance,
consider asking your design team if they may think of a redesign in
order to perform better.

Use keyExtractor or key 

You can set the  keyExtractor to your  FlatList component. This prop is
used for caching and as the React  key to track item re-ordering.

You can also use a  key prop in your item component.

Avoid anonymous function on renderItem 

For functional components, move the  renderItem function outside of the
returned JSX. Also, ensure that it is wrapped in a  useCallback hook to
prevent it from being recreated each render.

For class componenents, move the  renderItem function outside of the
render function, so it won't recreate itself each time the render
function is called.

    const renderItem = useCallback(({item}) => (
       <View key={item.key}>
          <Text>{item.title}</Text>
       </View>
     ), );

    return (
      // ...

      <FlatList data={items} renderItem={renderItem} />;
      // ...
    );

 

# Other Debugging Methods #
  ___  _   _                 ____       _                       _             
 / _ \| |_| |__   ___ _ __  |  _ \  ___| |__  _   _  __ _  __ _(_)_ __   __ _ 
| | | | __| '_ \ / _ \ '__| | | | |/ _ \ '_ \| | | |/ _` |/ _` | | '_ \ / _` |
| |_| | |_| | | |  __/ |    | |_| |  __/ |_) | |_| | (_| | (_| | | | | | (_| |
 \___/ \__|_| |_|\___|_|    |____/ \___|_.__/ \__,_|\__, |\__, |_|_| |_|\__, |
                                                    |___/ |___/         |___/ 
 __  __      _   _               _     
|  \/  | ___| |_| |__   ___   __| |___ 
| |\/| |/ _ \ __| '_ \ / _ \ / _` / __|
| |  | |  __/ |_| | | | (_) | (_| \__ \
|_|  |_|\___|\__|_| |_|\___/ \__,_|___/
                                       
-   Safari Developer Tools (direct JSC debugging)
-   Remote JavaScript Debugging (deprecated)
    -   Setup
    -   Debugging on a physical device
Other Debugging Methods

This page covers other JavaScript debugging methods besides what is
described in Opening the Debugger . If you are using a newly created
React Native or Expo app, we recommend starting there.

Safari Developer Tools (direct JSC debugging) 

You can use Safari to debug the iOS version of your app when using
JavaScriptCore (JSC) as your app's runtime.

1.  Physical devices only : Open the Settings app, and navigate to
    Safari > Advanced, and make sure "Web Inspector" is turned on.
2.  On your Mac, open Safari and enable the Develop menu. This can be
    found under Safari > Settings..., then the Advanced tab, then
    selecting "Show features for web developers".
3.  Find your device under the Develop menu, and select the "JSContext"
    item from the submenu. This will open Safari's Web Inspector, which
    includes Console and Sources panels similar to Chrome DevTools.

[Opening Safari Web Inspector]

 tip

While source maps may not be enabled by default, you can follow this
guide or video to enable them and set break points at the right places
in the source code.

 tip

Every time the app is reloaded, a new JSContext is created. Choosing
"Automatically Show Web Inspectors for JSContexts" saves you from having
to select the latest JSContext manually.

Remote JavaScript Debugging (deprecated) 

 warning

Remote JavaScript Debugging is deprecated in React Native 0.73 and will
be removed in a future release.

Remote JavaScript Debugging connects an external web browser (Chrome) to
your app and runs your JavaScript code inside a web page. This allows
you to use Chrome's debugger as you would with any web app. Note that
the browser environment can be very different, and not all React Native
modules will work when debugging this way.

Setup 

Since React Native 0.73, Remote JavaScript Debugging must be manually
enabled using the  NativeDevSettings module.

    import NativeDevSettings from 'react-native/Libraries/NativeModules/specs/NativeDevSettings';

    function MyApp() {
      // Assign this to a dev-only button or useEffect call
      const connectToRemoteDebugger = () => {
        NativeDevSettings.setIsDebuggingRemotely(true);
      };
    }

 

When  NativeDevSettings.setIsDebuggingRemotely(true) is invoked, this
will open a new tab at http://localhost:8081/debugger-ui .

From this page, open Chrome DevTools via:

-   View > Developer > Developer Tools
-    ⌥ Option  + Cmd ⌘  + I (macOS) / Ctrl  + Shift  + I (Windows and
    Linux).

The Console and Sources panels will allow you to inspect your React
Native code.

[The remote debugger window in Chrome]

 info

Under Remote JavaScript Debugging, the web version of React DevTools in
Chrome will not work with React Native. See the React DevTools guide to
learn how to use the standalone version of React DevTools.

 note

On Android, if the times between the debugger and device have drifted,
things such as animations and event behavior might not work properly.
This can be fixed by running  adb shell "date `date +%m%d%H%M%Y.%S%3N`"
. Root access is required if using a physical device.

Debugging on a physical device 

 info

If you're using Expo CLI, this is configured for you already.

-   Android
-   iOS

On iOS devices, open the file  RCTWebSocketExecutor.mm and change
"localhost" to the IP address of your computer.

On Android 5.0+ devices connected via USB, you can use the  adb command
line tool to set up port forwarding from the device to your computer:

    adb reverse tcp:8081 tcp:8081

 

 note

If you run into any issues, it may be possible that one of your Chrome
extensions is interacting in unexpected ways with the debugger. Try
disabling all of your extensions and re-enabling them one-by-one until
you find the problematic extension.

# Out-of-Tree Platforms #
  ___        _               __     _____              
 / _ \ _   _| |_       ___  / _|   |_   _| __ ___  ___ 
| | | | | | | __|____ / _ \| |_ _____| || '__/ _ \/ _ \
| |_| | |_| | ||_____| (_) |  _|_____| || | |  __/  __/
 \___/ \__,_|\__|     \___/|_|       |_||_|  \___|\___|
                                                       
 ____  _       _    __                          
|  _ \| | __ _| |_ / _| ___  _ __ _ __ ___  ___ 
| |_) | |/ _` | __| |_ / _ \| '__| '_ ` _ \/ __|
|  __/| | (_| | |_|  _| (_) | |  | | | | | \__ \
|_|   |_|\__,_|\__|_|  \___/|_|  |_| |_| |_|___/
                                                
-   Creating your own React Native platform
    -   Bundling
Out-of-Tree Platforms

React Native is not only for Android and iOS devices - our partners and
the community maintain projects that bring React Native to other
platforms, such as:

From Partners

-   React Native macOS - React Native for macOS and Cocoa.
-   React Native Windows - React Native for Microsoft's Universal
    Windows Platform (UWP).

From Community

-   React Native tvOS - React Native for Apple TV and Android TV
    devices.
-   React Native Web - React Native on the web using React DOM.
-   React Native Skia - React Native using Skia as a renderer. Currently
    supports Linux and macOS.

Creating your own React Native platform 

Right now the process of creating a React Native platform from scratch
is not very well documented - one of the goals of the upcoming
re-architecture ( Fabric ) is to make maintaining a platform easier.

Bundling 

As of React Native 0.57 you can now register your React Native platform
with React Native's JavaScript bundler, Metro . This means you can pass
 --platform example to  npx react-native bundle , and it will look for
JavaScript files with the  .example.js suffix.

To register your platform with RNPM, your module's name must match one
of these patterns:

-    react-native-example - It will search all top-level modules that
    start with  react-native-
-    @org/react-native-example - It will search for modules that start
    with  react-native- under any scope
-    @react-native-example/module - It will search in all modules under
    scopes with names starting with  @react-native-

You must also have an entry in your  package.json like this:

    {
      "rnpm": {
        "haste": {
          "providesModuleNodeModules": ["react-native-example"],
          "platforms": ["example"]
        }
      }
    }

 

 "providesModuleNodeModules" is an array of modules that will get added
to the Haste module search path, and  "platforms" is an array of
platform suffixes that will be added as valid platforms.

# PanResponder #
 ____             ____                                 _           
|  _ \ __ _ _ __ |  _ \ ___  ___ _ __   ___  _ __   __| | ___ _ __ 
| |_) / _` | '_ \| |_) / _ \/ __| '_ \ / _ \| '_ \ / _` |/ _ \ '__|
|  __/ (_| | | | |  _ <  __/\__ \ |_) | (_) | | | | (_| |  __/ |   
|_|   \__,_|_| |_|_| \_\___||___/ .__/ \___/|_| |_|\__,_|\___|_|   
                                |_|                                
-   Usage Pattern
-   Example
-   Methods
    -    create()
PanResponder

 PanResponder reconciles several touches into a single gesture. It makes
single-touch gestures resilient to extra touches, and can be used to
recognize basic multi-touch gestures.

By default,  PanResponder holds an  InteractionManager handle to block
long-running JS events from interrupting active gestures.

It provides a predictable wrapper of the responder handlers provided by
the gesture responder system . For each handler, it provides a new
 gestureState object alongside the native event object:

    onPanResponderMove: (event, gestureState) => {}

 

A native event is a synthetic touch event with form of PressEvent .

A  gestureState object has the following:

-    stateID - ID of the gestureState- persisted as long as there's at
    least one touch on screen
-    moveX - the latest screen coordinates of the recently-moved touch
-    moveY - the latest screen coordinates of the recently-moved touch
-    x0 - the screen coordinates of the responder grant
-    y0 - the screen coordinates of the responder grant
-    dx - accumulated distance of the gesture since the touch started
-    dy - accumulated distance of the gesture since the touch started
-    vx - current velocity of the gesture
-    vy - current velocity of the gesture
-    numberActiveTouches - Number of touches currently on screen

Usage Pattern 

    const ExampleComponent = () => {
      const panResponder = React.useRef(
        PanResponder.create({
          // Ask to be the responder:
          onStartShouldSetPanResponder: (evt, gestureState) => true,
          onStartShouldSetPanResponderCapture: (evt, gestureState) =>
            true,
          onMoveShouldSetPanResponder: (evt, gestureState) => true,
          onMoveShouldSetPanResponderCapture: (evt, gestureState) =>
            true,

          onPanResponderGrant: (evt, gestureState) => {
            // The gesture has started. Show visual feedback so the user knows
            // what is happening!
            // gestureState.d{x,y} will be set to zero now
          },
          onPanResponderMove: (evt, gestureState) => {
            // The most recent move distance is gestureState.move{X,Y}
            // The accumulated gesture distance since becoming responder is
            // gestureState.d{x,y}
          },
          onPanResponderTerminationRequest: (evt, gestureState) =>
            true,
          onPanResponderRelease: (evt, gestureState) => {
            // The user has released all touches while this view is the
            // responder. This typically means a gesture has succeeded
          },
          onPanResponderTerminate: (evt, gestureState) => {
            // Another component has become the responder, so this gesture
            // should be cancelled
          },
          onShouldBlockNativeResponder: (evt, gestureState) => {
            // Returns whether this component should block native components from becoming the JS
            // responder. Returns true by default. Is currently only supported on android.
            return true;
          },
        }),
      ).current;

      return <View {...panResponder.panHandlers} />;
    };

 

Example 

 PanResponder works with  Animated API to help build complex gestures in
the UI. The following example contains an animated  View component which
can be dragged freely across the screen

Try the PanResponder example in RNTester .

------------------------------------------------------------------------

Reference

Methods 

 create() 

    static create(config: PanResponderCallbacks): PanResponderInstance;

 

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| config                | object                | Refer below           |
|                       |                       |                       |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+

The  config object provides enhanced versions of all of the responder
callbacks that provide not only the  PressEvent , but also the
 PanResponder gesture state, by replacing the word  Responder with
 PanResponder in each of the typical  onResponder* callbacks. For
example, the  config object would look like:

-    onMoveShouldSetPanResponder: (e, gestureState) => {...}
-    onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}
-    onStartShouldSetPanResponder: (e, gestureState) => {...}
-    onStartShouldSetPanResponderCapture: (e, gestureState) => {...}
-    onPanResponderReject: (e, gestureState) => {...}
-    onPanResponderGrant: (e, gestureState) => {...}
-    onPanResponderStart: (e, gestureState) => {...}
-    onPanResponderEnd: (e, gestureState) => {...}
-    onPanResponderRelease: (e, gestureState) => {...}
-    onPanResponderMove: (e, gestureState) => {...}
-    onPanResponderTerminate: (e, gestureState) => {...}
-    onPanResponderTerminationRequest: (e, gestureState) => {...}
-    onShouldBlockNativeResponder: (e, gestureState) => {...}

In general, for events that have capture equivalents, we update the
gestureState once in the capture phase and can use it in the bubble
phase as well.

Be careful with  onStartShould* callbacks. They only reflect updated
 gestureState for start/end events that bubble/capture to the Node. Once
the node is the responder, you can rely on every start/end event being
processed by the gesture and  gestureState being updated accordingly.
(numberActiveTouches) may not be totally accurate unless you are the
responder.

# Performance Overview #
 ____            __                                           
|  _ \ ___ _ __ / _| ___  _ __ _ __ ___   __ _ _ __   ___ ___ 
| |_) / _ \ '__| |_ / _ \| '__| '_ ` _ \ / _` | '_ \ / __/ _ \
|  __/  __/ |  |  _| (_) | |  | | | | | | (_| | | | | (_|  __/
|_|   \___|_|  |_|  \___/|_|  |_| |_| |_|\__,_|_| |_|\___\___|
                                                              
  ___                       _               
 / _ \__   _____ _ ____   _(_) _____      __
| | | \ \ / / _ \ '__\ \ / / |/ _ \ \ /\ / /
| |_| |\ V /  __/ |   \ V /| |  __/\ V  V / 
 \___/  \_/ \___|_|    \_/ |_|\___| \_/\_/  
                                            
-   What you need to know about frames
    -   JS frame rate (JavaScript thread)
    -   UI frame rate (main thread)
-   Common sources of performance problems
    -   Running in development mode (  dev=true )
    -   Using  console.log statements
    -    ListView initial rendering is too slow or scroll performance is
        bad for large lists
    -   JS FPS plunges when re-rendering a view that hardly changes
    -   Dropping JS thread FPS because of doing a lot of work on the
        JavaScript thread at the same time
    -   Moving a view on the screen (scrolling, translating, rotating)
        drops UI thread FPS
    -   Animating the size of an image drops UI thread FPS
    -   My TouchableX view isn't very responsive
    -   Slow navigator transitions
Performance Overview

A compelling reason to use React Native instead of WebView-based tools
is to achieve 60 frames per second and provide a native look and feel to
your apps. Whenever feasible, we aim for React Native to handle
optimizations automatically, allowing you to focus on your app without
worrying about performance. However, there are certain areas where we
haven't quite reached that level yet, and others where React Native
(similar to writing native code directly) cannot determine the best
optimization approach for you. In such cases, manual intervention
becomes necessary. We strive to deliver buttery-smooth UI performance by
default, but there may be instances where that isn't possible.

This guide is intended to teach you some basics to help you to
troubleshoot performance issues , as well as discuss common sources of
problems and their suggested solutions .

What you need to know about frames 

Your grandparents' generation called movies "moving pictures" for a
reason: realistic motion in video is an illusion created by quickly
changing static images at a consistent speed. We refer to each of these
images as frames. The number of frames that is displayed each second has
a direct impact on how smooth and ultimately life-like a video (or user
interface) seems to be. iOS devices display 60 frames per second, which
gives you and the UI system about 16.67ms to do all of the work needed
to generate the static image (frame) that the user will see on the
screen for that interval. If you are unable to do the work necessary to
generate that frame within the allotted 16.67ms, then you will "drop a
frame" and the UI will appear unresponsive.

Now to confuse the matter a little bit, open up the Dev Menu in your app
and toggle  Show Perf Monitor . You will notice that there are two
different frame rates.



JS frame rate (JavaScript thread) 

For most React Native applications, your business logic will run on the
JavaScript thread. This is where your React application lives, API calls
are made, touch events are processed, etc... Updates to native-backed
views are batched and sent over to the native side at the end of each
iteration of the event loop, before the frame deadline (if all goes
well). If the JavaScript thread is unresponsive for a frame, it will be
considered a dropped frame. For example, if you were to call
 this.setState on the root component of a complex application and it
resulted in re-rendering computationally expensive component subtrees,
it's conceivable that this might take 200ms and result in 12 frames
being dropped. Any animations controlled by JavaScript would appear to
freeze during that time. If anything takes longer than 100ms, the user
will feel it.

This often happens during  Navigator transitions: when you push a new
route, the JavaScript thread needs to render all of the components
necessary for the scene in order to send over the proper commands to the
native side to create the backing views. It's common for the work being
done here to take a few frames and cause jank because the transition is
controlled by the JavaScript thread. Sometimes components will do
additional work on  componentDidMount , which might result in a second
stutter in the transition.

Another example is responding to touches: if you are doing work across
multiple frames on the JavaScript thread, you might notice a delay in
responding to  TouchableOpacity , for example. This is because the
JavaScript thread is busy and cannot process the raw touch events sent
over from the main thread. As a result,  TouchableOpacity cannot react
to the touch events and command the native view to adjust its opacity.

UI frame rate (main thread) 

Many people have noticed that performance of  NavigatorIOS is better out
of the box than  Navigator . The reason for this is that the animations
for the transitions are done entirely on the main thread, and so they
are not interrupted by frame drops on the JavaScript thread.

Similarly, you can happily scroll up and down through a  ScrollView when
the JavaScript thread is locked up because the  ScrollView lives on the
main thread. The scroll events are dispatched to the JS thread, but
their receipt is not necessary for the scroll to occur.

Common sources of performance problems 

Running in development mode (  dev=true ) 

JavaScript thread performance suffers greatly when running in dev mode.
This is unavoidable: a lot more work needs to be done at runtime to
provide you with good warnings and error messages, such as validating
propTypes and various other assertions. Always make sure to test
performance in release builds .

Using  console.log statements 

When running a bundled app, these statements can cause a big bottleneck
in the JavaScript thread. This includes calls from debugging libraries
such as redux-logger , so make sure to remove them before bundling. You
can also use this babel plugin that removes all the  console.* calls.
You need to install it first with
 npm i babel-plugin-transform-remove-console --save-dev , and then edit
the  .babelrc file under your project directory like this:

    {
      "env": {
        "production": {
          "plugins": ["transform-remove-console"]
        }
      }
    }

 

This will automatically remove all  console.* calls in the release
(production) versions of your project.

It is recommended to use the plugin even if no  console.* calls are made
in your project. A third party library could also call them.

 ListView initial rendering is too slow or scroll performance is bad for large lists 

Use the new  FlatList or  SectionList component instead. Besides
simplifying the API, the new list components also have significant
performance enhancements, the main one being nearly constant memory
usage for any number of rows.

If your  FlatList is rendering slow, be sure that you've implemented
 getItemLayout to optimize rendering speed by skipping measurement of
the rendered items.

JS FPS plunges when re-rendering a view that hardly changes 

If you are using a ListView, you must provide a  rowHasChanged function
that can reduce a lot of work by quickly determining whether or not a
row needs to be re-rendered. If you are using immutable data structures,
this would only need to be a reference equality check.

Similarly, you can implement  shouldComponentUpdate and indicate the
exact conditions under which you would like the component to re-render.
If you write pure components (where the return value of the render
function is entirely dependent on props and state), you can leverage
PureComponent to do this for you. Once again, immutable data structures
are useful to keep this fast -- if you have to do a deep comparison of a
large list of objects, it may be that re-rendering your entire component
would be quicker, and it would certainly require less code.

Dropping JS thread FPS because of doing a lot of work on the JavaScript thread at the same time 

"Slow Navigator transitions" is the most common manifestation of this,
but there are other times this can happen. Using InteractionManager can
be a good approach, but if the user experience cost is too high to delay
work during an animation, then you might want to consider
LayoutAnimation.

The Animated API currently calculates each keyframe on-demand on the
JavaScript thread unless you set  useNativeDriver: true , while
LayoutAnimation leverages Core Animation and is unaffected by JS thread
and main thread frame drops.

One case where I have used this is for animating in a modal (sliding
down from top and fading in a translucent overlay) while initializing
and perhaps receiving responses for several network requests, rendering
the contents of the modal, and updating the view where the modal was
opened from. See the Animations guide for more information about how to
use LayoutAnimation.

Caveats:

-   LayoutAnimation only works for fire-and-forget animations ("static"
    animations) -- if it must be interruptible, you will need to use
     Animated .

Moving a view on the screen (scrolling, translating, rotating) drops UI thread FPS 

This is especially true when you have text with a transparent background
positioned on top of an image, or any other situation where alpha
compositing would be required to re-draw the view on each frame. You
will find that enabling  shouldRasterizeIOS or
 renderToHardwareTextureAndroid can help with this significantly.

Be careful not to overuse this or your memory usage could go through the
roof. Profile your performance and memory usage when using these props.
If you don't plan to move a view anymore, turn this property off.

Animating the size of an image drops UI thread FPS 

On iOS, each time you adjust the width or height of an Image component
it is re-cropped and scaled from the original image. This can be very
expensive, especially for large images. Instead, use the
 transform: [{scale}] style property to animate the size. An example of
when you might do this is when you tap an image and zoom it in to full
screen.

My TouchableX view isn't very responsive 

Sometimes, if we do an action in the same frame that we are adjusting
the opacity or highlight of a component that is responding to a touch,
we won't see that effect until after the  onPress function has returned.
If  onPress does a  setState that results in a lot of work and a few
frames dropped, this may occur. A solution to this is to wrap any action
inside of your  onPress handler in  requestAnimationFrame :

    handleOnPress() {
      requestAnimationFrame(() => {
        this.doExpensiveAction();
      });
    }

 

Slow navigator transitions 

As mentioned above,  Navigator animations are controlled by the
JavaScript thread. Imagine the "push from right" scene transition: each
frame, the new scene is moved from the right to left, starting offscreen
(let's say at an x-offset of 320) and ultimately settling when the scene
sits at an x-offset of 0. Each frame during this transition, the
JavaScript thread needs to send a new x-offset to the main thread. If
the JavaScript thread is locked up, it cannot do this and so no update
occurs on that frame and the animation stutters.

One solution to this is to allow for JavaScript-based animations to be
offloaded to the main thread. If we were to do the same thing as in the
above example with this approach, we might calculate a list of all
x-offsets for the new scene when we are starting the transition and send
them to the main thread to execute in an optimized way. Now that the
JavaScript thread is freed of this responsibility, it's not a big deal
if it drops a few frames while rendering the scene -- you probably won't
even notice because you will be too distracted by the pretty transition.

Solving this is one of the main goals behind the new React Navigation
library. The views in React Navigation use native components and the
 Animated library to deliver 60 FPS animations that are run on the
native thread.

# PermissionsAndroid #
 ____                     _         _                    _              _      
|  _ \ ___ _ __ _ __ ___ (_)___ ___(_) ___  _ __  ___   / \   _ __   __| |_ __ 
| |_) / _ \ '__| '_ ` _ \| / __/ __| |/ _ \| '_ \/ __| / _ \ | '_ \ / _` | '__|
|  __/  __/ |  | | | | | | \__ \__ \ | (_) | | | \__ \/ ___ \| | | | (_| | |   
|_|   \___|_|  |_| |_| |_|_|___/___/_|\___/|_| |_|___/_/   \_\_| |_|\__,_|_|   
                                                                               
       _     _ 
  ___ (_) __| |
 / _ \| |/ _` |
| (_) | | (_| |
 \___/|_|\__,_|
               
-   Example
-   Permissions that require prompting the user
-   Result strings for requesting permissions
-   Methods
    -    check()
    -    request()
    -    requestMultiple()
PermissionsAndroid

Project with Native Code Required

The following section only applies to projects with native code exposed.
If you are using the managed Expo workflow, see the guide on Permissions
in the Expo documentation for the appropriate alternative.

 PermissionsAndroid provides access to Android M's new permissions
model. The so-called "normal" permissions are granted by default when
the application is installed as long as they appear in
 AndroidManifest.xml . However, "dangerous" permissions require a dialog
prompt. You should use this module for those permissions.

On devices before SDK version 23, the permissions are automatically
granted if they appear in the manifest, so  check should always result
to  true and  request should always resolve to
 PermissionsAndroid.RESULTS.GRANTED .

If a user has previously turned off a permission that you prompt for,
the OS will advise your app to show a rationale for needing the
permission. The optional  rationale argument will show a dialog prompt
only if necessary - otherwise the normal permission prompt will appear.

Example 

Permissions that require prompting the user 

Available as constants under  PermissionsAndroid.PERMISSIONS :

-    READ_CALENDAR : 'android.permission.READ_CALENDAR'
-    WRITE_CALENDAR : 'android.permission.WRITE_CALENDAR'
-    CAMERA : 'android.permission.CAMERA'
-    READ_CONTACTS : 'android.permission.READ_CONTACTS'
-    WRITE_CONTACTS : 'android.permission.WRITE_CONTACTS'
-    GET_ACCOUNTS : 'android.permission.GET_ACCOUNTS'
-    ACCESS_FINE_LOCATION : 'android.permission.ACCESS_FINE_LOCATION'
-    ACCESS_COARSE_LOCATION :
    'android.permission.ACCESS_COARSE_LOCATION'
-    ACCESS_BACKGROUND_LOCATION :
    'android.permission.ACCESS_BACKGROUND_LOCATION'
-    RECORD_AUDIO : 'android.permission.RECORD_AUDIO'
-    READ_PHONE_STATE : 'android.permission.READ_PHONE_STATE'
-    CALL_PHONE : 'android.permission.CALL_PHONE'
-    READ_CALL_LOG : 'android.permission.READ_CALL_LOG'
-    WRITE_CALL_LOG : 'android.permission.WRITE_CALL_LOG'
-    ADD_VOICEMAIL : 'com.android.voicemail.permission.ADD_VOICEMAIL'
-    USE_SIP : 'android.permission.USE_SIP'
-    PROCESS_OUTGOING_CALLS :
    'android.permission.PROCESS_OUTGOING_CALLS'
-    BODY_SENSORS : 'android.permission.BODY_SENSORS'
-    SEND_SMS : 'android.permission.SEND_SMS'
-    RECEIVE_SMS : 'android.permission.RECEIVE_SMS'
-    READ_SMS : 'android.permission.READ_SMS'
-    RECEIVE_WAP_PUSH : 'android.permission.RECEIVE_WAP_PUSH'
-    RECEIVE_MMS : 'android.permission.RECEIVE_MMS'
-    READ_EXTERNAL_STORAGE : 'android.permission.READ_EXTERNAL_STORAGE'
-    WRITE_EXTERNAL_STORAGE :
    'android.permission.WRITE_EXTERNAL_STORAGE'
-    BLUETOOTH_CONNECT : 'android.permission.BLUETOOTH_CONNECT'
-    BLUETOOTH_SCAN : 'android.permission.BLUETOOTH_SCAN'
-    BLUETOOTH_ADVERTISE : 'android.permission.BLUETOOTH_ADVERTISE'
-    ACCESS_MEDIA_LOCATION : 'android.permission.ACCESS_MEDIA_LOCATION'
-    ACCEPT_HANDOVER : 'android.permission.ACCEPT_HANDOVER'
-    ACTIVITY_RECOGNITION : 'android.permission.ACTIVITY_RECOGNITION'
-    ANSWER_PHONE_CALLS : 'android.permission.ANSWER_PHONE_CALLS'
-    READ_PHONE_NUMBERS : 'android.permission.READ_PHONE_NUMBERS'
-    UWB_RANGING : 'android.permission.UWB_RANGING'
-    BODY_SENSORS_BACKGROUND :
    'android.permission.BODY_SENSORS_BACKGROUND'
-    READ_MEDIA_IMAGES : 'android.permission.READ_MEDIA_IMAGES'
-    READ_MEDIA_VIDEO : 'android.permission.READ_MEDIA_VIDEO'
-    READ_MEDIA_AUDIO : 'android.permission.READ_MEDIA_AUDIO'
-    POST_NOTIFICATIONS : 'android.permission.POST_NOTIFICATIONS'
-    NEARBY_WIFI_DEVICES : 'android.permission.NEARBY_WIFI_DEVICES'
-    READ_VOICEMAIL : 'com.android.voicemail.permission.READ_VOICEMAIL',
-    WRITE_VOICEMAIL :
    'com.android.voicemail.permission.WRITE_VOICEMAIL',

Result strings for requesting permissions 

Available as constants under  PermissionsAndroid.RESULTS :

-    GRANTED : 'granted'
-    DENIED : 'denied'
-    NEVER_ASK_AGAIN : 'never_ask_again'

------------------------------------------------------------------------

Reference

Methods 

 check() 

    static check(permission: Permission): Promise<boolean>;

 

Returns a promise resolving to a boolean value as to whether the
specified permissions has been granted.

Parameters:

  Name         Type     Required   Description
  ------------ -------- ---------- ------------------------------
  permission   string   Yes        The permission to check for.

------------------------------------------------------------------------

 request() 

    static request(
      permission: Permission,
      rationale?: Rationale,
    ): Promise<PermissionStatus>;

 

Prompts the user to enable a permission and returns a promise resolving
to a string value (see result strings above) indicating whether the user
allowed or denied the request or does not want to be asked again.

If  rationale is provided, this function checks with the OS whether it
is necessary to show a dialog explaining why the permission is needed (
https://developer.android.com/training/permissions/requesting.html#explain
) and then shows the system permission dialog.

Parameters:

  Name         Type     Required   Description
  ------------ -------- ---------- ----------------------------
  permission   string   Yes        The permission to request.
  rationale    object   No         See  rationale below.

Rationale:

  Name             Type     Required   Description
  ---------------- -------- ---------- ----------------------------------
  title            string   Yes        The title of the dialog.
  message          string   Yes        The message of the dialog.
  buttonPositive   string   Yes        The text of the positive button.
  buttonNegative   string   No         The text of the negative button.
  buttonNeutral    string   No         The text of the neutral button.

------------------------------------------------------------------------

 requestMultiple() 

    static requestMultiple(
      permissions: Permission,
    ): Promise<{[key in Permission]: PermissionStatus}>;

 

Prompts the user to enable multiple permissions in the same dialog and
returns an object with the permissions as keys and strings as values
(see result strings above) indicating whether the user allowed or denied
the request or does not want to be asked again.

Parameters:

  Name          Type    Required   Description
  ------------- ------- ---------- ----------------------------------
  permissions   array   Yes        Array of permissions to request.

# PixelRatio #
 ____  _          _ ____       _   _       
|  _ \(_)_  _____| |  _ \ __ _| |_(_) ___  
| |_) | \ \/ / _ \ | |_) / _` | __| |/ _ \ 
|  __/| |>  <  __/ |  _ < (_| | |_| | (_) |
|_|   |_/_/\_\___|_|_| \_\__,_|\__|_|\___/ 
                                           
-   Fetching a correctly sized image
-   Pixel grid snapping
-   Example
-   Methods
    -    get()
    -    getFontScale()
    -    getPixelSizeForLayoutSize()
    -    roundToNearestPixel()
PixelRatio

 PixelRatio gives you access to the device's pixel density and font
scale.

Fetching a correctly sized image 

You should get a higher resolution image if you are on a high pixel
density device. A good rule of thumb is to multiply the size of the
image you display by the pixel ratio.

    const image = getImage({
      width: PixelRatio.getPixelSizeForLayoutSize(200),
      height: PixelRatio.getPixelSizeForLayoutSize(100),
    });
    <Image source={image} style={{width: 200, height: 100}} />;

 

Pixel grid snapping 

In iOS, you can specify positions and dimensions for elements with
arbitrary precision, for example 29.674825. But, ultimately the physical
display only have a fixed number of pixels, for example 640×1136 for
iPhone SE (1st generation) or 828×1792 for iPhone 11. iOS tries to be as
faithful as possible to the user value by spreading one original pixel
into multiple ones to trick the eye. The downside of this technique is
that it makes the resulting element look blurry.

In practice, we found out that developers do not want this feature and
they have to work around it by doing manual rounding in order to avoid
having blurry elements. In React Native, we are rounding all the pixels
automatically.

We have to be careful when to do this rounding. You never want to work
with rounded and unrounded values at the same time as you're going to
accumulate rounding errors. Having even one rounding error is deadly
because a one pixel border may vanish or be twice as big.

In React Native, everything in JavaScript and within the layout engine
works with arbitrary precision numbers. It's only when we set the
position and dimensions of the native element on the main thread that we
round. Also, rounding is done relative to the root rather than the
parent, again to avoid accumulating rounding errors.

Example 

------------------------------------------------------------------------

Reference

Methods 

 get() 

    static get(): number;

 

Returns the device pixel density. Some examples:

-    PixelRatio.get() === 1
    -   mdpi Android devices
-    PixelRatio.get() === 1.5
    -   hdpi Android devices
-    PixelRatio.get() === 2
    -   iPhone SE, 6S, 7, 8
    -   iPhone XR
    -   iPhone 11
    -   xhdpi Android devices
-    PixelRatio.get() === 3
    -   iPhone 6S Plus, 7 Plus, 8 Plus
    -   iPhone X, XS, XS Max
    -   iPhone 11 Pro, 11 Pro Max
    -   Pixel, Pixel 2
    -   xxhdpi Android devices
-    PixelRatio.get() === 3.5
    -   Nexus 6
    -   Pixel XL, Pixel 2 XL
    -   xxxhdpi Android devices

------------------------------------------------------------------------

 getFontScale() 

    static getFontScale(): number;

 

Returns the scaling factor for font sizes. This is the ratio that is
used to calculate the absolute font size, so any elements that heavily
depend on that should use this to do calculations.

-   on Android value reflects the user preference set in Settings >
    Display > Font size
-   on iOS value reflects the user preference set in Settings > Display
    & Brightness > Text Size , value can also be updated in Settings >
    Accessibility > Display & Text Size > Larger Text

If a font scale is not set, this returns the device pixel ratio.

------------------------------------------------------------------------

 getPixelSizeForLayoutSize() 

    static getPixelSizeForLayoutSize(layoutSize: number): number;

 

Converts a layout size (dp) to pixel size (px).

Guaranteed to return an integer number.

------------------------------------------------------------------------

 roundToNearestPixel() 

    static roundToNearestPixel(layoutSize: number): number;

 

Rounds a layout size (dp) to the nearest layout size that corresponds to
an integer number of pixels. For example, on a device with a PixelRatio
of 3,  PixelRatio.roundToNearestPixel(8.4) = 8.33 , which corresponds to
exactly (8.33 * 3) = 25 pixels.

# Platform #
 ____  _       _    __                      
|  _ \| | __ _| |_ / _| ___  _ __ _ __ ___  
| |_) | |/ _` | __| |_ / _ \| '__| '_ ` _ \ 
|  __/| | (_| | |_|  _| (_) | |  | | | | | |
|_|   |_|\__,_|\__|_|  \___/|_|  |_| |_| |_|
                                            
-   Example
-   Properties
    -    constants
    -    isPad
        iOS
    -    isTV
    -    isTesting
    -    OS
    -    Version
-   Methods
    -    select()
Platform

Example 

------------------------------------------------------------------------

Reference

Properties 

 constants 

    static constants: PlatformConstants;

 

Returns an object which contains all available common and specific
constants related to the platform.

Properties:

+-----------------+-----------------+-----------------+-----------------+
| Name            | Type            | Optional        | Description     |
+=================+=================+=================+=================+
| isTesting       | boolean         | No              |                 |
+-----------------+-----------------+-----------------+-----------------+
| rea             | object          | No              | Information     |
| ctNativeVersion |                 |                 | about React     |
|                 |                 |                 | Native version. |
|                 |                 |                 | Keys are  major |
|                 |                 |                 | ,  minor ,      |
|                 |                 |                 |  patch with     |
|                 |                 |                 | optional        |
|                 |                 |                 |  prerelease and |
|                 |                 |                 | values are      |
|                 |                 |                 |  number s.      |
+-----------------+-----------------+-----------------+-----------------+
| Version         | number          | No              | OS version      |
|                 |                 |                 | constant        |
| Android         |                 |                 | specific to     |
|                 |                 |                 | Android.        |
+-----------------+-----------------+-----------------+-----------------+
| Release         | string          | No              |                 |
|                 |                 |                 |                 |
| Android         |                 |                 |                 |
+-----------------+-----------------+-----------------+-----------------+
| Serial          | string          | No              | Hardware serial |
|                 |                 |                 | number of an    |
| Android         |                 |                 | Android device. |
+-----------------+-----------------+-----------------+-----------------+
| Fingerprint     | string          | No              | A string that   |
|                 |                 |                 | uniquely        |
| Android         |                 |                 | identifies the  |
|                 |                 |                 | build.          |
+-----------------+-----------------+-----------------+-----------------+
| Model           | string          | No              | The             |
|                 |                 |                 | e               |
| Android         |                 |                 | nd-user-visible |
|                 |                 |                 | name for the    |
|                 |                 |                 | Android device. |
+-----------------+-----------------+-----------------+-----------------+
| Brand           | string          | No              | The             |
|                 |                 |                 | c               |
| Android         |                 |                 | onsumer-visible |
|                 |                 |                 | brand with      |
|                 |                 |                 | which the       |
|                 |                 |                 | p               |
|                 |                 |                 | roduct/hardware |
|                 |                 |                 | will be         |
|                 |                 |                 | associated.     |
+-----------------+-----------------+-----------------+-----------------+
| Manufacturer    | string          | No              | The             |
|                 |                 |                 | manufacturer of |
| Android         |                 |                 | the Android     |
|                 |                 |                 | device.         |
+-----------------+-----------------+-----------------+-----------------+
| ServerHost      | string          | Yes             |                 |
|                 |                 |                 |                 |
| Android         |                 |                 |                 |
+-----------------+-----------------+-----------------+-----------------+
| uiMode          | string          | No              | Possible values |
|                 |                 |                 | are:  'car' ,   |
| Android         |                 |                 |  'desk' ,       |
|                 |                 |                 |  'normal' ,     |
|                 |                 |                 |  'tv' ,         |
|                 |                 |                 |  'watch' and    |
|                 |                 |                 |  'unknown' .    |
|                 |                 |                 | Read more about |
|                 |                 |                 | Android         |
|                 |                 |                 | ModeType .      |
+-----------------+-----------------+-----------------+-----------------+
| forc            | boolean         | No              | Indicate the    |
| eTouchAvailable |                 |                 | availability of |
|                 |                 |                 | 3D Touch on a   |
| iOS             |                 |                 | device.         |
+-----------------+-----------------+-----------------+-----------------+
| interfaceIdiom  | string          | No              | The interface   |
|                 |                 |                 | type for the    |
| iOS             |                 |                 | device. Read    |
|                 |                 |                 | more about      |
|                 |                 |                 | UIUse           |
|                 |                 |                 | rInterfaceIdiom |
|                 |                 |                 | .               |
+-----------------+-----------------+-----------------+-----------------+
| osVersion       | string          | No              | OS version      |
|                 |                 |                 | constant        |
| iOS             |                 |                 | specific to     |
|                 |                 |                 | iOS.            |
+-----------------+-----------------+-----------------+-----------------+
| systemName      | string          | No              | OS name         |
|                 |                 |                 | constant        |
| iOS             |                 |                 | specific to     |
|                 |                 |                 | iOS.            |
+-----------------+-----------------+-----------------+-----------------+

------------------------------------------------------------------------

 isPad

iOS



    static isPad: boolean;

 

Returns a boolean which defines if device is an iPad.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 isTV 

    static isTV: boolean;

 

Returns a boolean which defines if device is a TV.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 isTesting 

    static isTesting: boolean;

 

Returns a boolean which defines if application is running in Developer
Mode with testing flag set.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 OS 

    static OS: 'android' | 'ios';

 

Returns string value representing the current OS.

  Type
  -----------------------------
  enum(  'android' ,  'ios' )

------------------------------------------------------------------------

 Version 

    static Version: 'number' | 'string';

 

Returns the version of the OS.

+-----------------------------------------------------------------------+
| Type                                                                  |
+=======================================================================+
| number                                                                |
|                                                                       |
| Android                                                               |
|                                                                       |
| -------------------------------------------------------------------   |
|                                                                       |
| string                                                                |
|                                                                       |
| iOS                                                                   |
+-----------------------------------------------------------------------+

Methods 

 select() 

    static select(config: Record<string, T>): T;

 

Returns the most fitting value for the platform you are currently
running on.

Parameters: 

  Name     Type     Required   Description
  -------- -------- ---------- -------------------------------
  config   object   Yes        See config description below.

Select method returns the most fitting value for the platform you are
currently running on. That is, if you're running on a phone,  android
and  ios keys will take preference. If those are not specified,  native
key will be used and then the  default key.

The  config parameter is an object with the following keys:

-    android (any)
-    ios (any)
-    native (any)
-    default (any)

Example usage:

    import {Platform, StyleSheet} from 'react-native';

    const styles = StyleSheet.create({
      container: {
        flex: 1,
        ...Platform.select({
          android: {
            backgroundColor: 'green',
          },
          ios: {
            backgroundColor: 'red',
          },
          default: {
            // other platforms, web for example
            backgroundColor: 'blue',
          },
        }),
      },
    });

 

This will result in a container having  flex: 1 on all platforms, a
green background color on Android, a red background color on iOS, and a
blue background color on other platforms.

Since the value of the corresponding platform key can be of type  any ,
 select method can also be used to return platform-specific components,
like below:

    const Component = Platform.select({
      ios: () => require('ComponentIOS'),
      android: () => require('ComponentAndroid'),
    })();

    <Component />;

 

    const Component = Platform.select({
      native: () => require('ComponentForNative'),
      default: () => require('ComponentForWeb'),
    })();

    <Component />;

 

# PlatformColor #
 ____  _       _    __                       ____      _            
|  _ \| | __ _| |_ / _| ___  _ __ _ __ ___  / ___|___ | | ___  _ __ 
| |_) | |/ _` | __| |_ / _ \| '__| '_ ` _ \| |   / _ \| |/ _ \| '__|
|  __/| | (_| | |_|  _| (_) | |  | | | | | | |__| (_) | | (_) | |   
|_|   |_|\__,_|\__|_|  \___/|_|  |_| |_| |_|\____\___/|_|\___/|_|   
                                                                    
-   Supported colors
-   Example
PlatformColor

    PlatformColor(color1, [color2, ...colorN]);

 

You can use the  PlatformColor function to access native colors on the
target platform by supplying the native color’s corresponding string
value. You pass a string to the  PlatformColor function and, provided it
exists on that platform, it will return the corresponding native color,
which you can apply in any part of your application.

If you pass more than one string value to the  PlatformColor function,
it will treat the first value as the default and the rest as fallback.

    PlatformColor('bogusName', 'linkColor');

 

Since native colors can be sensitive to themes and/or high contrast,
this platform specific logic also translates inside your components.

Supported colors 

For a full list of the types of system colors supported, see:

-   Android:
    -   R.attr -  ?attr prefix
    -   R.color -  @android:color prefix
-   iOS (Objective-C and Swift notations):
    -   UIColor Standard Colors
    -   UIColor UI Element Colors

Developer notes 

-   Web

  If you’re familiar with design systems, another way of thinking about
  this is that  PlatformColor lets you tap into the local design
  system's color tokens so your app can blend right in!

Example 

The string value provided to the  PlatformColor function must match the
string as it exists on the native platform where the app is running. In
order to avoid runtime errors, the function should be wrapped in a
platform check, either through a  Platform.OS === 'platform' or a
 Platform.select() , as shown on the example above.

  Note: You can find a complete example that demonstrates proper,
  intended use of  PlatformColor in PlatformColorExample.js .

# Platform-Specific Code #
 ____  _       _    __                           ____                  _  __ _ 
|  _ \| | __ _| |_ / _| ___  _ __ _ __ ___      / ___| _ __   ___  ___(_)/ _(_)
| |_) | |/ _` | __| |_ / _ \| '__| '_ ` _ \ ____\___ \| '_ \ / _ \/ __| | |_| |
|  __/| | (_| | |_|  _| (_) | |  | | | | | |_____|__) | |_) |  __/ (__| |  _| |
|_|   |_|\__,_|\__|_|  \___/|_|  |_| |_| |_|    |____/| .__/ \___|\___|_|_| |_|
                                                      |_|                      
         ____          _      
  ___   / ___|___   __| | ___ 
 / __| | |   / _ \ / _` |/ _ \
| (__  | |__| (_) | (_| |  __/
 \___|  \____\___/ \__,_|\___|
                              
-   Platform module
    -   Detecting the Android version
    -   Detecting the iOS version
-   Platform-specific extensions
-   Native-specific extensions (i.e. sharing code with NodeJS and Web)
Platform-Specific Code

When building a cross-platform app, you'll want to re-use as much code
as possible. Scenarios may arise where it makes sense for the code to be
different, for example you may want to implement separate visual
components for Android and iOS.

React Native provides two ways to organize your code and separate it by
platform:

-   Using the  Platform module .
-   Using platform-specific file extensions .

Certain components may have properties that work on one platform only.
All of these props are annotated with  @platform and have a small badge
next to them on the website.

Platform module 

React Native provides a module that detects the platform in which the
app is running. You can use the detection logic to implement
platform-specific code. Use this option when only small parts of a
component are platform-specific.

    import {Platform, StyleSheet} from 'react-native';

    const styles = StyleSheet.create({
      height: Platform.OS === 'ios' ? 200 : 100,
    });

 

 Platform.OS will be  ios when running on iOS and  android when running
on Android.

There is also a  Platform.select method available, that given an object
where keys can be one of  'ios' | 'android' | 'native' | 'default' ,
returns the most fitting value for the platform you are currently
running on. That is, if you're running on a phone,  ios and  android
keys will take preference. If those are not specified,  native key will
be used and then the  default key.

    import {Platform, StyleSheet} from 'react-native';

    const styles = StyleSheet.create({
      container: {
        flex: 1,
        ...Platform.select({
          ios: {
            backgroundColor: 'red',
          },
          android: {
            backgroundColor: 'green',
          },
          default: {
            // other platforms, web for example
            backgroundColor: 'blue',
          },
        }),
      },
    });

 

This will result in a container having  flex: 1 on all platforms, a red
background color on iOS, a green background color on Android, and a blue
background color on other platforms.

Since it accepts  any value, you can also use it to return
platform-specific components, like below:

    const Component = Platform.select({
      ios: () => require('ComponentIOS'),
      android: () => require('ComponentAndroid'),
    })();

    <Component />;

 

    const Component = Platform.select({
      native: () => require('ComponentForNative'),
      default: () => require('ComponentForWeb'),
    })();

    <Component />;

 

Detecting the Android version 

On Android, the  Platform module can also be used to detect the version
of the Android Platform in which the app is running:

    import {Platform} from 'react-native';

    if (Platform.Version === 25) {
      console.log('Running on Nougat!');
    }

 

Note :  Version is set to the Android API version not the Android OS
version. To find a mapping please refer to Android Version History .

Detecting the iOS version 

On iOS, the  Version is a result of  -[UIDevice systemVersion] , which
is a string with the current version of the operating system. An example
of the system version is "10.3". For example, to detect the major
version number on iOS:

    import {Platform} from 'react-native';

    const majorVersionIOS = parseInt(Platform.Version, 10);
    if (majorVersionIOS <= 9) {
      console.log('Work around a change in behavior');
    }

 

Platform-specific extensions 

When your platform-specific code is more complex, you should consider
splitting the code out into separate files. React Native will detect
when a file has a  .ios. or  .android. extension and load the relevant
platform file when required from other components.

For example, say you have the following files in your project:

    BigButton.ios.js
    BigButton.android.js

 

You can then import the component as follows:

    import BigButton from './BigButton';

 

React Native will automatically pick up the right file based on the
running platform.

Native-specific extensions (i.e. sharing code with NodeJS and Web) 

You can also use the  .native.js extension when a module needs to be
shared between NodeJS/Web and React Native but it has no Android/iOS
differences. This is especially useful for projects that have common
code shared among React Native and ReactJS.

For example, say you have the following files in your project:

    Container.js # picked up by webpack, Rollup or any other Web bundler
    Container.native.js # picked up by the React Native bundler for both Android and iOS (Metro)

 

You can still import it without the  .native extension, as follows:

    import Container from './Container';

 

Pro tip: Configure your Web bundler to ignore  .native.js extensions in
order to avoid having unused code in your production bundle, thus
reducing the final bundle size.

# Pressable #
 ____                          _     _      
|  _ \ _ __ ___  ___ ___  __ _| |__ | | ___ 
| |_) | '__/ _ \/ __/ __|/ _` | '_ \| |/ _ \
|  __/| | |  __/\__ \__ \ (_| | |_) | |  __/
|_|   |_|  \___||___/___/\__,_|_.__/|_|\___|
                                            
-   How it works
-   Example
-   Props
    -    android_disableSound
        Android
    -    android_ripple
        Android
    -    children
    -    unstable_pressDelay
    -    delayLongPress
    -    disabled
    -    hitSlop
    -    onHoverIn
    -    onHoverOut
    -    onLongPress
    -    onPress
    -    onPressIn
    -    onPressOut
    -    pressRetentionOffset
    -    style
    -    testOnly_pressed
-   Type Definitions
    -   RippleConfig
Pressable

Pressable is a Core Component wrapper that can detect various stages of
press interactions on any of its defined children.

    <Pressable onPress={onPressFunction}>
      <Text>I'm pressable!</Text>
    </Pressable>

 

How it works 

On an element wrapped by  Pressable :

-    onPressIn is called when a press is activated.
-    onPressOut is called when the press gesture is deactivated.

After pressing  onPressIn , one of two things will happen:

1.  The person will remove their finger, triggering  onPressOut followed
    by  onPress .
2.  If the person leaves their finger longer than 500 milliseconds
    before removing it,  onLongPress is triggered. (  onPressOut will
    still fire when they remove their finger.)

[Diagram of the onPress events in sequence.]

Fingers are not the most precise instruments, and it is common for users
to accidentally activate the wrong element or miss the activation area.
To help,  Pressable has an optional  HitRect you can use to define how
far a touch can register away from the wrapped element. Presses can
start anywhere within a  HitRect .

 PressRect allows presses to move beyond the element and its  HitRect
while maintaining activation and being eligible for a "press"—think of
sliding your finger slowly away from a button you're pressing down on.

  The touch area never extends past the parent view bounds and the
  Z-index of sibling views always takes precedence if a touch hits two
  overlapping views.

[You can set  HitRect with  hitSlop and set  PressRect with
 pressRetentionOffset .]

   Pressable uses React Native's  Pressability API. For more information
  around the state machine flow of Pressability and how it works, check
  out the implementation for Pressability .

Example 

Props 

 android_disableSound

Android



If true, doesn't play Android system sound on press.

  Type      Default
  --------- ---------
  boolean    false

 android_ripple

Android



Enables the Android ripple effect and configures its properties.

  Type
  --------------
  RippleConfig

 children 

Either children or a function that receives a boolean reflecting whether
the component is currently pressed.

  Type
  ------------
  React Node

 unstable_pressDelay 

Duration (in milliseconds) to wait after press down before calling
 onPressIn .

  Type
  --------
  number

 delayLongPress 

Duration (in milliseconds) from  onPressIn before  onLongPress is
called.

  Type     Default
  -------- ---------
  number    500

 disabled 

Whether the press behavior is disabled.

  Type      Default
  --------- ---------
  boolean    false

 hitSlop 

Sets additional distance outside of element in which a press can be
detected.

  Type
  ----------------
  Rect or number

 onHoverIn 

Called when the hover is activated to provide visual feedback.

  Type
  ------------------------------------------
   ({ nativeEvent:  MouseEvent  }) => void

 onHoverOut 

Called when the hover is deactivated to undo visual feedback.

  Type
  ------------------------------------------
   ({ nativeEvent:  MouseEvent  }) => void

 onLongPress 

Called if the time after  onPressIn lasts longer than 500 milliseconds.
This time period can be customized with  delayLongPress .

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

 onPress 

Called after  onPressOut .

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

 onPressIn 

Called immediately when a touch is engaged, before  onPressOut and
 onPress .

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

 onPressOut 

Called when a touch is released.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

 pressRetentionOffset 

Additional distance outside of this view in which a touch is considered
a press before  onPressOut is triggered.

  Type             Default
  ---------------- ---------------------------------------------
  Rect or number    {bottom: 30, left: 20, right: 20, top: 20}

 style 

Either view styles or a function that receives a boolean reflecting
whether the component is currently pressed and returns view styles.

  Type
  ------------
  View Style

 testOnly_pressed 

Used only for documentation or testing (e.g. snapshot testing).

  Type      Default
  --------- ---------
  boolean    false

Type Definitions 

RippleConfig 

Ripple effect configuration for the  android_ripple property.

  Type
  --------
  object

Properties:

  Name         Type      Required   Description
  ------------ --------- ---------- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  color        color     No         Defines the color of the ripple effect.
  borderless   boolean   No         Defines if ripple effect should not include border.
  radius       number    No         Defines the radius of the ripple effect.
  foreground   boolean   No         Set to true to add the ripple effect to the foreground of the view, instead of the background. This is useful if one of your child views has a background of its own, or you're e.g. displaying images, and you don't want the ripple to be covered by them.

# PressEvent Object Type #
 ____                    _____                 _   
|  _ \ _ __ ___  ___ ___| ____|_   _____ _ __ | |_ 
| |_) | '__/ _ \/ __/ __|  _| \ \ / / _ \ '_ \| __|
|  __/| | |  __/\__ \__ \ |___ \ V /  __/ | | | |_ 
|_|   |_|  \___||___/___/_____| \_/ \___|_| |_|\__|
                                                   
  ___  _     _           _     _____                 
 / _ \| |__ (_) ___  ___| |_  |_   _|   _ _ __   ___ 
| | | | '_ \| |/ _ \/ __| __|   | || | | | '_ \ / _ \
| |_| | |_) | |  __/ (__| |_    | || |_| | |_) |  __/
 \___/|_.__// |\___|\___|\__|   |_| \__, | .__/ \___|
          |__/                      |___/|_|         
-   Example
-   Keys and values
    -    changedTouches
    -    force
        iOS
    -    identifier
    -    locationX
    -    locationY
    -    pageX
    -    pageY
    -    target
    -    timestamp
    -    touches
-   Used by
PressEvent Object Type

 PressEvent object is returned in the callback as a result of user press
interaction, for example  onPress in Button component.

Example 

    {
        changedTouches: [PressEvent],
        identifier: 1,
        locationX: 8,
        locationY: 4.5,
        pageX: 24,
        pageY: 49.5,
        target: 1127,
        timestamp: 85131876.58868201,
        touches: 
    }

 

Keys and values 

 changedTouches 

Array of all PressEvents that have changed since the last event.

  Type                   Optional
  ---------------------- ----------
  array of PressEvents   No

 force

iOS



Amount of force used during the 3D Touch press. Returns the float value
in range from  0.0 to  1.0 .

  Type     Optional
  -------- ----------
  number   Yes

 identifier 

Unique numeric identifier assigned to the event.

  Type     Optional
  -------- ----------
  number   No

 locationX 

Touch origin X coordinate inside touchable area (relative to the
element).

  Type     Optional
  -------- ----------
  number   No

 locationY 

Touch origin Y coordinate inside touchable area (relative to the
element).

  Type     Optional
  -------- ----------
  number   No

 pageX 

Touch origin X coordinate on the screen (relative to the root view).

  Type     Optional
  -------- ----------
  number   No

 pageY 

Touch origin Y coordinate on the screen (relative to the root view).

  Type     Optional
  -------- ----------
  number   No

 target 

The node id of the element receiving the PressEvent.

  Type                         Optional
  ---------------------------- ----------
  number,  null ,  undefined   No

 timestamp 

Timestamp value when a PressEvent occurred. Value is represented in
milliseconds.

  Type     Optional
  -------- ----------
  number   No

 touches 

Array of all current PressEvents on the screen.

  Type                   Optional
  ---------------------- ----------
  array of PressEvents   No

Used by 

-    Button
-    PanResponder
-    Pressable
-    ScrollView
-    Text
-    TextInput
-    TouchableHighlight
-    TouchableOpacity
-    TouchableNativeFeedback
-    TouchableWithoutFeedback
-    View

# Profiling #
 ____             __ _ _ _             
|  _ \ _ __ ___  / _(_) (_)_ __   __ _ 
| |_) | '__/ _ \| |_| | | | '_ \ / _` |
|  __/| | | (_) |  _| | | | | | | (_| |
|_|   |_|  \___/|_| |_|_|_|_| |_|\__, |
                                 |___/ 
-   Profiling Android UI Performance with  systrace
    -   1. Collecting a trace
    -   2. Reading the trace
    -   3. Find your process
-   Identifying a culprit
-   Resolving JavaScript issues
-   Resolving native UI Issues
    -   Too much GPU work
    -   Creating new views on the UI thread
Profiling

Use the built-in profiler to get detailed information about work done in
the JavaScript thread and main thread side-by-side. Access it by
selecting Perf Monitor from the Debug menu.

For iOS, Instruments is an invaluable tool, and on Android you should
learn to use  systrace .

But first, make sure that Development Mode is OFF! You should see
 __DEV__ === false, development-level warning are OFF, performance optimizations are ON
in your application logs.

Another way to profile JavaScript is to use the Chrome profiler while
debugging. This won't give you accurate results as the code is running
in Chrome but will give you a general idea of where bottlenecks might
be. Run the profiler under Chrome's  Performance tab. A flame graph will
appear under  User Timing . To view more details in tabular format,
click at the  Bottom Up tab below and then select
 DedicatedWorker Thread at the top left menu.

Profiling Android UI Performance with  systrace 

Android supports 10k+ different phones and is generalized to support
software rendering: the framework architecture and need to generalize
across many hardware targets unfortunately means you get less for free
relative to iOS. But sometimes, there are things you can improve -- and
many times it's not native code's fault at all!

The first step for debugging this jank is to answer the fundamental
question of where your time is being spent during each 16ms frame. For
that, we'll be using a standard Android profiling tool called  systrace
.

 systrace is a standard Android marker-based profiling tool (and is
installed when you install the Android platform-tools package). Profiled
code blocks are surrounded by start/end markers which are then
visualized in a colorful chart format. Both the Android SDK and React
Native framework provide standard markers that you can visualize.

1. Collecting a trace 

First, connect a device that exhibits the stuttering you want to
investigate to your computer via USB and get it to the point right
before the navigation/animation you want to profile. Run  systrace as
follows:

    $ <path_to_android_sdk>/platform-tools/systrace/systrace.py --time=10 -o trace.html sched gfx view -a <your_package_name>

 

A quick breakdown of this command:

-    time is the length of time the trace will be collected in seconds
-    sched ,  gfx , and  view are the android SDK tags (collections of
    markers) we care about:  sched gives you information about what's
    running on each core of your phone,  gfx gives you graphics info
    such as frame boundaries, and  view gives you information about
    measure, layout, and draw passes
-    -a <your_package_name> enables app-specific markers, specifically
    the ones built into the React Native framework.  your_package_name
    can be found in the  AndroidManifest.xml of your app and looks like
     com.example.app

Once the trace starts collecting, perform the animation or interaction
you care about. At the end of the trace, systrace will give you a link
to the trace which you can open in your browser.

2. Reading the trace 

After opening the trace in your browser (preferably Chrome), you should
see something like this:

[Example]

 Hint

Use the WASD keys to strafe and zoom.

If your trace .html file isn't opening correctly, check your browser
console for the following:

[ObjectObserveError]

Since  Object.observe was deprecated in recent browsers, you may have to
open the file from the Google Chrome Tracing tool. You can do so by:

-   Opening tab in chrome chrome://tracing
-   Selecting load
-   Selecting the html file generated from the previous command.

 Enable VSync highlighting

Check this checkbox at the top right of the screen to highlight the 16ms
frame boundaries:

[Enable VSync Highlighting]

You should see zebra stripes as in the screenshot above. If you don't,
try profiling on a different device: Samsung has been known to have
issues displaying vsyncs while the Nexus series is generally pretty
reliable.

3. Find your process 

Scroll until you see (part of) the name of your package. In this case, I
was profiling  com.facebook.adsmanager , which shows up as
 book.adsmanager because of silly thread name limits in the kernel.

On the left side, you'll see a set of threads which correspond to the
timeline rows on the right. There are a few threads we care about for
our purposes: the UI thread (which has your package name or the name UI
Thread),  mqt_js , and  mqt_native_modules . If you're running on
Android 5+, we also care about the Render Thread.

-   UI Thread. This is where standard android measure/layout/draw
    happens. The thread name on the right will be your package name (in
    my case book.adsmanager) or UI Thread. The events that you see on
    this thread should look something like this and have to do with
     Choreographer ,  traversals , and  DispatchUI :

    [UI Thread Example]

-   JS Thread. This is where JavaScript is executed. The thread name
    will be either  mqt_js or  <...> depending on how cooperative the
    kernel on your device is being. To identify it if it doesn't have a
    name, look for things like  JSCall ,  Bridge.executeJSCall , etc:

    [JS Thread Example]

-   Native Modules Thread. This is where native module calls (e.g. the
     UIManager ) are executed. The thread name will be either
     mqt_native_modules or  <...> . To identify it in the latter case,
    look for things like  NativeCall ,  callJavaModuleMethod , and
     onBatchComplete :

    [Native Modules Thread Example]

-   Bonus: Render Thread. If you're using Android L (5.0) and up, you
    will also have a render thread in your application. This thread
    generates the actual OpenGL commands used to draw your UI. The
    thread name will be either  RenderThread or  <...> . To identify it
    in the latter case, look for things like  DrawFrame and  queueBuffer
    :

    [Render Thread Example]

Identifying a culprit 

A smooth animation should look something like the following:

[Smooth Animation]

Each change in color is a frame -- remember that in order to display a
frame, all our UI work needs to be done by the end of that 16ms period.
Notice that no thread is working close to the frame boundary. An
application rendering like this is rendering at 60 FPS.

If you noticed chop, however, you might see something like this:

[Choppy Animation from JS]

Notice that the JS thread is executing almost all the time, and across
frame boundaries! This app is not rendering at 60 FPS. In this case, the
problem lies in JS .

You might also see something like this:

[Choppy Animation from UI]

In this case, the UI and render threads are the ones that have work
crossing frame boundaries. The UI that we're trying to render on each
frame is requiring too much work to be done. In this case, the problem
lies in the native views being rendered .

At this point, you'll have some very helpful information to inform your
next steps.

Resolving JavaScript issues 

If you identified a JS problem, look for clues in the specific JS that
you're executing. In the scenario above, we see  RCTEventEmitter being
called multiple times per frame. Here's a zoom-in of the JS thread from
the trace above:

[Too much JS]

This doesn't seem right. Why is it being called so often? Are they
actually different events? The answers to these questions will probably
depend on your product code. And many times, you'll want to look into
shouldComponentUpdate .

Resolving native UI Issues 

If you identified a native UI problem, there are usually two scenarios:

1.  the UI you're trying to draw each frame involves too much work on
    the GPU, or
2.  You're constructing new UI during the animation/interaction (e.g.
    loading in new content during a scroll).

Too much GPU work 

In the first scenario, you'll see a trace that has the UI thread and/or
Render Thread looking like this:

[Overloaded GPU]

Notice the long amount of time spent in  DrawFrame that crosses frame
boundaries. This is time spent waiting for the GPU to drain its command
buffer from the previous frame.

To mitigate this, you should:

-   investigate using  renderToHardwareTextureAndroid for complex,
    static content that is being animated/transformed (e.g. the
     Navigator slide/alpha animations)
-   make sure that you are not using  needsOffscreenAlphaCompositing ,
    which is disabled by default, as it greatly increases the per-frame
    load on the GPU in most cases.

Creating new views on the UI thread 

In the second scenario, you'll see something more like this:

[Creating Views]

Notice that first the JS thread thinks for a bit, then you see some work
done on the native modules thread, followed by an expensive traversal on
the UI thread.

There isn't a quick way to mitigate this unless you're able to postpone
creating new UI until after the interaction, or you are able to simplify
the UI you're creating. The react native team is working on an
infrastructure level solution for this that will allow new UI to be
created and configured off the main thread, allowing the interaction to
continue smoothly.

# Profiling with Hermes #
 ____             __ _ _ _                        _ _   _     
|  _ \ _ __ ___  / _(_) (_)_ __   __ _  __      _(_) |_| |__  
| |_) | '__/ _ \| |_| | | | '_ \ / _` | \ \ /\ / / | __| '_ \ 
|  __/| | | (_) |  _| | | | | | | (_| |  \ V  V /| | |_| | | |
|_|   |_|  \___/|_| |_|_|_|_| |_|\__, |   \_/\_/ |_|\__|_| |_|
                                 |___/                        
 _   _                               
| | | | ___ _ __ _ __ ___   ___  ___ 
| |_| |/ _ \ '__| '_ ` _ \ / _ \/ __|
|  _  |  __/ |  | | | | | |  __/\__ \
|_| |_|\___|_|  |_| |_| |_|\___||___/
                                     
-   Record a Hermes sampling profile
-   Execute command from CLI
    -   Enabling source map
    -   Common errors
-   Open the downloaded profile in Chrome DevTools
-   How does the Hermes Profile Transformer work?
Profiling with Hermes

You can visualize JavaScript's performance in a React Native app using
Hermes . Hermes is a small and lightweight JavaScript engine optimized
for running React Native (you can read more about using it with React
Native here ). Hermes helps improve app performance and also exposes
ways to analyze the performance of the JavaScript that it runs.

In this section, you will learn how to profile your React Native app
running on Hermes and how to visualize the profile using the Performance
tab on Chrome DevTools

 caution

Be sure to enable Hermes in your app before you get started!

Follow the instructions below to get started profiling:

1.  Record a Hermes sampling profile
2.  Execute command from CLI
3.  Open the downloaded profile on Chrome DevTools

Record a Hermes sampling profile 

To record a sampling profiler from the Dev Menu:

1.  Navigate to your running Metro server terminal.
2.  Press  d to open the Dev Menu.
3.  Select Enable Sampling Profiler.
4.  Execute your JavaScript by in your app (press buttons, etc.)
5.  Open the Dev Menu by pressing  d again.
6.  Select Disable Sampling Profiler to stop recording and save the
    sampling profiler.

A toast will show the location where the sampling profiler has been
saved, usually in  /data/user/0/com.appName/cache/*.cpuprofile

[Toast Notification of Profile saving]

Execute command from CLI 

You can use the React Native CLI to convert the Hermes tracing profile
to Chrome tracing profile, and then pull it to your local machine using:

    npx react-native profile-hermes [destinationDir]

 

Enabling source map 

 info

You may read about source maps on the Debugging Release Builds page.

Common errors 

 adb: no devices/emulators found or  adb: device offline 

-   Why this happens The CLI cannot access the device or emulator
    (through adb) you are using to run the app.
-   How to fix Make sure your Android device/emulator is connected and
    running. The command only works when it can access adb.

 There is no file in the cache/ directory 

-   Why this happens The CLI cannot find any .cpuprofile file in your
    app's cache/ directory. You might have forgotten to record a profile
    from the device.
-   How to fix Follow the instructions to enable/disable profiler from
    device.

 Error: your_profile_name.cpuprofile is an empty file 

-   Why this happens The profile is empty, it might be because Hermes is
    not running correctly.
-   How to fix Make sure your app is running on the latest version of
    Hermes.

Open the downloaded profile in Chrome DevTools 

To open the profile in Chrome DevTools:

1.  Open Chrome DevTools.
2.  Select the Performance tab.
3.  Right click and choose Load profile...

[Loading a performance profile on Chrome DevTools]

How does the Hermes Profile Transformer work? 

The Hermes Sample Profile is of the  JSON object format , while the
format that Google's DevTools supports is  JSON Array Format . (More
information about the formats can be found on the Trace Event Format
Document )

    export interface HermesCPUProfile {
      traceEvents: SharedEventProperties;
      samples: HermesSample;
      stackFrames: {[key in string]: HermesStackFrame};
    }

 

The Hermes profile has most of its information encoded into the  samples
and  stackFrames properties. Each sample is a snapshot of the function
call stack at that particular timestamp as each sample has a  sf
property which corresponds to a function call.

    export interface HermesSample {
      cpu: string;
      name: string;
      ts: string;
      pid: number;
      tid: string;
      weight: string;
      /**
       * Will refer to an element in the stackFrames object of the Hermes Profile
       */
      sf: number;
      stackFrameData?: HermesStackFrame;
    }

 

The information about a function call can be found in  stackFrames which
contains key-object pairs, where the key is the  sf number and the
corresponding object gives us all the relevant information about the
function including the  sf number of its parent function. This
parent-child relationship can be traced upwards to find the information
of all the functions running at a particular timestamp.

    export interface HermesStackFrame {
      line: string;
      column: string;
      funcLine: string;
      funcColumn: string;
      name: string;
      category: string;
      /**
       * A parent function may or may not exist
       */
      parent?: number;
    }

 

At this point, you should define a few more terms, namely:

1.  Nodes: The objects corresponding to  sf numbers in  stackFrames
2.  Active Nodes: The nodes which are currently running at a particular
    timestamp. A node is classified as running if its  sf number is in
    the function call stack. This call stack can be obtained from the
     sf number of the sample and tracing upwards till parent  sf s are
    available

The  samples and the  stackFrames in tandem can then be used to generate
all the start and end events at the corresponding timestamps, wherein:

1.  Start Nodes/Events: Nodes absent in the previous sample's function
    call stack but present in the current sample's.
2.  End Nodes/Events: Nodes present in the previous sample's function
    call stack but absent in the current sample's.

[CallStack Terms Explained]

You can now construct a  flamechart of function calls as you have all
the function information including its start and end timestamps.

The  hermes-profile-transformer can convert any profile generated using
Hermes into a format that can be directly displayed in Chrome DevTools.
More information about this can be found on
 @react-native-community/hermes-profile-transformer

# 🚧 ProgressViewIOS #
  /\/\    __ 
  >  <  _/ _)
 _\/\ |/ \ \ 
/ __` |\ \\ \
\____/  \ \_/
       (__/  
 ____                                  __     ___               ___ ___  ____  
|  _ \ _ __ ___   __ _ _ __ ___  ___ __\ \   / (_) _____      _|_ _/ _ \/ ___| 
| |_) | '__/ _ \ / _` | '__/ _ \/ __/ __\ \ / /| |/ _ \ \ /\ / /| | | | \___ \ 
|  __/| | | (_) | (_| | | |  __/\__ \__ \\ V / | |  __/\ V  V / | | |_| |___) |
|_|   |_|  \___/ \__, |_|  \___||___/___/ \_/  |_|\___| \_/\_/ |___\___/|____/ 
                 |___/                                                         
-   Example
-   Props
    -    progress
    -    progressImage
    -    progressTintColor
    -    progressViewStyle
    -    trackImage
    -    trackTintColor
🚧 ProgressViewIOS

  Removed. Use one of the community packages instead.

Uses  ProgressViewIOS to render a UIProgressView on iOS.

Example 

------------------------------------------------------------------------

Reference

Props 

Inherits View Props .

 progress 

The progress value (between 0 and 1).

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 progressImage 

A stretchable image to display as the progress bar.

  Type                     Required
  ------------------------ ----------
  Image.propTypes.source   No

------------------------------------------------------------------------

 progressTintColor 

The tint color of the progress bar itself.

  Type     Required
  -------- ----------
  string   No

------------------------------------------------------------------------

 progressViewStyle 

The progress bar style.

  Type                     Required
  ------------------------ ----------
  enum('default', 'bar')   No

------------------------------------------------------------------------

 trackImage 

A stretchable image to display behind the progress bar.

  Type                     Required
  ------------------------ ----------
  Image.propTypes.source   No

------------------------------------------------------------------------

 trackTintColor 

The tint color of the progress bar track.

  Type     Required
  -------- ----------
  string   No

# Props #
 ____                      
|  _ \ _ __ ___  _ __  ___ 
| |_) | '__/ _ \| '_ \/ __|
|  __/| | | (_) | |_) \__ \
|_|   |_|  \___/| .__/|___/
                |_|        

Props

Most components can be customized when they are created, with different
parameters. These created parameters are called  props , short for
properties.

For example, one basic React Native component is the  Image . When you
create an image, you can use a prop named  source to control what image
it shows.

Notice the braces surrounding  {pic} - these embed the variable  pic
into JSX. You can put any JavaScript expression inside braces in JSX.

Your own components can also use  props . This lets you make a single
component that is used in many different places in your app, with
slightly different properties in each place by referring to  props in
your  render function. Here's an example:

-   TypeScript
-   JavaScript

Using  name as a prop lets us customize the  Greeting component, so we
can reuse that component for each of our greetings. This example also
uses the  Greeting component in JSX, similar to the Core Components .
The power to do this is what makes React so cool - if you find yourself
wishing that you had a different set of UI primitives to work with, you
can invent new ones.

The other new thing going on here is the  View component. A  View is
useful as a container for other components, to help control style and
layout.

With  props and the basic  Text ,  Image , and  View components, you can
build a wide variety of static screens. To learn how to make your app
change over time, you need to learn about State .

# Publishing to Apple App Store #
 ____        _     _ _     _     _               _        
|  _ \ _   _| |__ | (_)___| |__ (_)_ __   __ _  | |_ ___  
| |_) | | | | '_ \| | / __| '_ \| | '_ \ / _` | | __/ _ \ 
|  __/| |_| | |_) | | \__ \ | | | | | | | (_| | | || (_) |
|_|    \__,_|_.__/|_|_|___/_| |_|_|_| |_|\__, |  \__\___/ 
                                         |___/            
    _                _           _                  ____  _                 
   / \   _ __  _ __ | | ___     / \   _ __  _ __   / ___|| |_ ___  _ __ ___ 
  / _ \ | '_ \| '_ \| |/ _ \   / _ \ | '_ \| '_ \  \___ \| __/ _ \| '__/ _ \
 / ___ \| |_) | |_) | |  __/  / ___ \| |_) | |_) |  ___) | || (_) | | |  __/
/_/   \_\ .__/| .__/|_|\___| /_/   \_\ .__/| .__/  |____/ \__\___/|_|  \___|
        |_|   |_|                    |_|   |_|                              
-   1. Configure release scheme
-   2. Build app for release
Publishing to Apple App Store

The publishing process is the same as any other native iOS app, with
some additional considerations to take into account.

 info

If you are using Expo, read the Expo guide for Deploying to App Stores
to build and submit your app for the Apple App Store. This guide works
with any React Native app to automate the deployment process.

1. Configure release scheme 

Building an app for distribution in the App Store requires using the
 Release scheme in Xcode. Apps built for  Release will automatically
disable the in-app Dev Menu, which will prevent your users from
inadvertently accessing the menu in production. It will also bundle the
JavaScript locally, so you can put the app on a device and test whilst
not connected to the computer.

To configure your app to be built using the  Release scheme, go to
Product → Scheme → Edit Scheme . Select the Run tab in the sidebar, then
set the Build Configuration dropdown to  Release .



Pro Tips 

As your App Bundle grows in size, you may start to see a blank screen
flash between your splash screen and the display of your root
application view. If this is the case, you can add the following code to
 AppDelegate.m in order to keep your splash screen displayed during the
transition.

      // Place this code after "[self.window makeKeyAndVisible]" and before "return YES;"
      UIStoryboard *sb = [UIStoryboard storyboardWithName:@"LaunchScreen" bundle:nil];
      UIViewController *vc = [sb instantiateInitialViewController];
      rootView.loadingView = vc.view;

 

The static bundle is built every time you target a physical device, even
in Debug. If you want to save time, turn off bundle generation in Debug
by adding the following to your shell script in the Xcode Build Phase
 Bundle React Native code and images :

     if [ "${CONFIGURATION}" == "Debug" ]; then
      export SKIP_BUNDLING=true
     fi

 

2. Build app for release 

You can now build your app for release by tapping Cmd ⌘  + B or
selecting Product → Build from the menu bar. Once built for release,
you'll be able to distribute the app to beta testers and submit the app
to the App Store.

 info

You can also use the  React Native CLI to perform this operation using
the option  --mode with the value  Release (e.g. from the root of your
project:  npm run ios -- --mode="Release" or  yarn ios --mode Release ).

Once you are done with the testing and ready to publish to App Store,
follow along with this guide.

-   Launch your terminal, and navigate into the iOS folder of your app
    and type  open . .
-   Double click on YOUR_APP_NAME.xcworkspace. It should launch XCode.
-   Click on  Product →  Archive . Make sure to set the device to "Any
    iOS Device (arm64)".

 note

Check your Bundle Identifier and make sure it is exactly same as the one
you have created in the Identifiers in Apple Developer Dashboard.

-   After the archive is completed, in the archive window, click on
     Distribute App .
-   Click on  App Store Connect now (if you want to publish in App
    Store).
-   Click  Upload → Make sure all the check boxes are selected, hit
     Next .
-   Choose between  Automatically manage signing and
     Manually manage signing based on your needs.
-   Click on  Upload .
-   Now you can find it in the App Store Connect under TestFlight.

Now fill up the necessary information and in the Build Section, select
the build of the app and click on  Save →  Submit For Review .

# Publishing to Google Play Store #
 ____        _     _ _     _     _               _        
|  _ \ _   _| |__ | (_)___| |__ (_)_ __   __ _  | |_ ___  
| |_) | | | | '_ \| | / __| '_ \| | '_ \ / _` | | __/ _ \ 
|  __/| |_| | |_) | | \__ \ | | | | | | | (_| | | || (_) |
|_|    \__,_|_.__/|_|_|___/_| |_|_|_| |_|\__, |  \__\___/ 
                                         |___/            
  ____                   _        ____  _             
 / ___| ___   ___   __ _| | ___  |  _ \| | __ _ _   _ 
| |  _ / _ \ / _ \ / _` | |/ _ \ | |_) | |/ _` | | | |
| |_| | (_) | (_) | (_| | |  __/ |  __/| | (_| | |_| |
 \____|\___/ \___/ \__, |_|\___| |_|   |_|\__,_|\__, |
                   |___/                        |___/ 
 ____  _                 
/ ___|| |_ ___  _ __ ___ 
\___ \| __/ _ \| '__/ _ \
 ___) | || (_) | | |  __/
|____/ \__\___/|_|  \___|
                         
-   Generating an upload key
    -   Windows
    -   macOS
-   Setting up Gradle variables
-   Adding signing config to your app's Gradle config
-   Generating the release AAB
-   Testing the release build of your app
-   Publishing to other stores
-   Enabling Proguard to reduce the size of the APK (optional)
-   Migrating old Android React Native apps to use App Signing by Google
    Play
-   Default Permissions
Publishing to Google Play Store

Android requires that all apps be digitally signed with a certificate
before they can be installed. In order to distribute your Android
application via Google Play store it needs to be signed with a release
key that then needs to be used for all future updates. Since 2017 it is
possible for Google Play to manage signing releases automatically thanks
to App Signing by Google Play functionality. However, before your
application binary is uploaded to Google Play it needs to be signed with
an upload key. The Signing Your Applications page on Android Developers
documentation describes the topic in detail. This guide covers the
process in brief, as well as lists the steps required to package the
JavaScript bundle.

 info

If you are using Expo, read the Expo guide for Deploying to App Stores
to build and submit your app for the Google Play Store. This guide works
with any React Native app to automate the deployment process.

Generating an upload key 

You can generate a private signing key using  keytool .

Windows 

On Windows  keytool must be run from
 C:\Program Files\Java\jdkx.x.x_x\bin , as administrator.

    keytool -genkeypair -v -storetype PKCS12 -keystore my-upload-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000

 

This command prompts you for passwords for the keystore and key and for
the Distinguished Name fields for your key. It then generates the
keystore as a file called  my-upload-key.keystore .

The keystore contains a single key, valid for 10000 days. The alias is a
name that you will use later when signing your app, so remember to take
note of the alias.

macOS 

On macOS, if you're not sure where your JDK bin folder is, then perform
the following command to find it:

    /usr/libexec/java_home

 

It will output the directory of the JDK, which will look something like
this:

    /Library/Java/JavaVirtualMachines/jdkX.X.X_XXX.jdk/Contents/Home

 

Navigate to that directory by using the command  cd /your/jdk/path and
use the keytool command with sudo permission as shown below.

    sudo keytool -genkey -v -keystore my-upload-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000

 

 caution

Remember to keep the keystore file private. In case you've lost upload
key or it's been compromised you should follow these instructions .

Setting up Gradle variables 

1.  Place the  my-upload-key.keystore file under the  android/app
    directory in your project folder.
2.  Edit the file  ~/.gradle/gradle.properties or
     android/gradle.properties , and add the following (replace  *****
    with the correct keystore password, alias and key password),

    MYAPP_UPLOAD_STORE_FILE=my-upload-key.keystore
    MYAPP_UPLOAD_KEY_ALIAS=my-key-alias
    MYAPP_UPLOAD_STORE_PASSWORD=*****
    MYAPP_UPLOAD_KEY_PASSWORD=*****

 

These are going to be global Gradle variables, which we can later use in
our Gradle config to sign our app.

 Note about using git

Saving the above Gradle variables in  ~/.gradle/gradle.properties
instead of  android/gradle.properties prevents them from being checked
in to git. You may have to create the  ~/.gradle/gradle.properties file
in your user's home directory before you can add the variables.

 Note about security

If you are not keen on storing your passwords in plaintext, and you are
running macOS, you can also store your credentials in the Keychain
Access app . Then you can skip the two last rows in
 ~/.gradle/gradle.properties .

Adding signing config to your app's Gradle config 

The last configuration step that needs to be done is to setup release
builds to be signed using upload key. Edit the file
 android/app/build.gradle in your project folder, and add the signing
config,

    ...
    android {
        ...
        defaultConfig { ... }
        signingConfigs {
            release {
                if (project.hasProperty('MYAPP_UPLOAD_STORE_FILE')) {
                    storeFile file(MYAPP_UPLOAD_STORE_FILE)
                    storePassword MYAPP_UPLOAD_STORE_PASSWORD
                    keyAlias MYAPP_UPLOAD_KEY_ALIAS
                    keyPassword MYAPP_UPLOAD_KEY_PASSWORD
                }
            }
        }
        buildTypes {
            release {
                ...
                signingConfig signingConfigs.release
            }
        }
    }
    ...

 

Generating the release AAB 

Run the following command in a terminal:

    npx react-native build-android --mode=release

 

This command uses Gradle's  bundleRelease under the hood that bundles
all the JavaScript needed to run your app into the AAB ( Android App
Bundle ). If you need to change the way the JavaScript bundle and/or
drawable resources are bundled (e.g. if you changed the default
file/folder names or the general structure of the project), have a look
at  android/app/build.gradle to see how you can update it to reflect
these changes.

 note

Make sure  gradle.properties does not include
 org.gradle.configureondemand=true as that will make the release build
skip bundling JS and assets into the app binary.

The generated AAB can be found under
 android/app/build/outputs/bundle/release/app-release.aab , and is ready
to be uploaded to Google Play.

In order for Google Play to accept AAB format the App Signing by Google
Play needs to be configured for your application on the Google Play
Console. If you are updating an existing app that doesn't use App
Signing by Google Play, please check our migration section to learn how
to perform that configuration change.

Testing the release build of your app 

Before uploading the release build to the Play Store, make sure you test
it thoroughly. First uninstall any previous version of the app you
already have installed. Install it on the device using the following
command in the project root:

-   npm
-   Yarn

    npm run android -- --mode="release"

 

    yarn android --mode release

 

Note that  --mode release is only available if you've set up signing as
described above.

You can terminate any running bundler instances, since all your
framework and JavaScript code is bundled in the APK's assets.

Publishing to other stores 

By default, the generated APK has the native code for both  x86 ,
 x86_64 ,  ARMv7a and  ARM64-v8a CPU architectures. This makes it easier
to share APKs that run on almost all Android devices. However, this has
the downside that there will be some unused native code on any device,
leading to unnecessarily bigger APKs.

You can create an APK for each CPU by adding the following line in your
 android/app/build.gradle file:

    android {

        splits {
            abi {
                reset()
                enable true
                universalApk false
                include "armeabi-v7a", "arm64-v8a", "x86", "x86_64"
            }
        }

    }

 

Upload these files to markets which support device targeting, such as
Amazon AppStore or F-Droid , and the users will automatically get the
appropriate APK. If you want to upload to other markets, such as
APKFiles , which do not support multiple APKs for a single app, change
the  universalApk false line to  true to create the default universal
APK with binaries for both CPUs.

Please note that you will also have to configure distinct version codes,
as suggested in this page from the official Android documentation.

Enabling Proguard to reduce the size of the APK (optional) 

Proguard is a tool that can slightly reduce the size of the APK. It does
this by stripping parts of the React Native Java bytecode (and its
dependencies) that your app is not using.

 Important

Make sure to thoroughly test your app if you've enabled Proguard.
Proguard often requires configuration specific to each native library
you're using. See  app/proguard-rules.pro .

To enable Proguard, edit  android/app/build.gradle :

    /**
     * Run Proguard to shrink the Java bytecode in release builds.
     */
    def enableProguardInReleaseBuilds = true

 

Migrating old Android React Native apps to use App Signing by Google Play 

If you are migrating from previous version of React Native chances are
your app does not use App Signing by Google Play feature. We recommend
you enable that in order to take advantage from things like automatic
app splitting. In order to migrate from the old way of signing you need
to start by generating new upload key and then replacing release signing
config in  android/app/build.gradle to use the upload key instead of the
release one (see section about adding signing config to gradle ). Once
that's done you should follow the instructions from Google Play Help
website in order to send your original release key to Google Play.

Default Permissions 

By default,  INTERNET permission is added to your Android app as pretty
much all apps use it.  SYSTEM_ALERT_WINDOW permission is added to your
Android APK in debug mode but it will be removed in production.

# RAM Bundles and Inline Requires #
 ____      _    __  __   ____                  _ _           
|  _ \    / \  |  \/  | | __ ) _   _ _ __   __| | | ___  ___ 
| |_) |  / _ \ | |\/| | |  _ \| | | | '_ \ / _` | |/ _ \/ __|
|  _ <  / ___ \| |  | | | |_) | |_| | | | | (_| | |  __/\__ \
|_| \_\/_/   \_\_|  |_| |____/ \__,_|_| |_|\__,_|_|\___||___/
                                                             
                 _   ___       _ _            
  __ _ _ __   __| | |_ _|_ __ | (_)_ __   ___ 
 / _` | '_ \ / _` |  | || '_ \| | | '_ \ / _ \
| (_| | | | | (_| |  | || | | | | | | | |  __/
 \__,_|_| |_|\__,_| |___|_| |_|_|_|_| |_|\___|
                                              
 ____                  _               
|  _ \ ___  __ _ _   _(_)_ __ ___  ___ 
| |_) / _ \/ _` | | | | | '__/ _ \/ __|
|  _ <  __/ (_| | |_| | | | |  __/\__ \
|_| \_\___|\__, |\__,_|_|_|  \___||___/
              |_|                      
-   Loading JavaScript
-   Inline Requires
-   Enable the RAM format
-   Configure Preloading and Inline Requires
-   Investigating the Loaded Modules
-   Updating the metro.config.js
-   Test and Measure Improvements
RAM Bundles and Inline Requires

If you have a large app you may want to consider the Random Access
Modules (RAM) bundle format, and using inline requires. This is useful
for apps that have a large number of screens which may not ever be
opened during a typical usage of the app. Generally it is useful to apps
that have large amounts of code that are not needed for a while after
startup. For instance the app includes complicated profile screens or
lesser used features, but most sessions only involve visiting the main
screen of the app for updates. We can optimize the loading of the bundle
by using the RAM format and requiring those features and screens inline
(when they are actually used).

Loading JavaScript 

Before react-native can execute JS code, that code must be loaded into
memory and parsed. With a standard bundle if you load a 50mb bundle, all
50mb must be loaded and parsed before any of it can be executed. The
optimization behind RAM bundles is that you can load only the portion of
the 50mb that you actually need at startup, and progressively load more
of the bundle as those sections are needed.

Inline Requires 

Inline requires delay the requiring of a module or file until that file
is actually needed. A basic example would look like this:

VeryExpensive.tsx

    import React, {Component} from 'react';
    import {Text} from 'react-native';
    // ... import some very expensive modules

    export default function VeryExpensive() {
      // ... lots and lots of rendering logic
      return <Text>Very Expensive Component</Text>;
    }

 

Optimized.tsx

    import {useCallback, useState} from 'react';
    import {TouchableOpacity, View, Text} from 'react-native';
    // Usually we would write a static import:
    // import VeryExpensive from './VeryExpensive';
    let VeryExpensive = null;
    export default function Optimize() {
      const [needsExpensive, setNeedsExpensive] = useState(false);
      const didPress = useCallback(() => {
        if (VeryExpensive == null) {
          VeryExpensive = require('./VeryExpensive').default;
        }
        setNeedsExpensive(true);
      }, );

      return (
        <View style={{marginTop: 20}}>
          <TouchableOpacity onPress={didPress}>
            <Text>Load</Text>
          </TouchableOpacity>
          {needsExpensive ? <VeryExpensive /> : null}
        </View>
      );
    }

 

Even without the RAM format, inline requires can lead to startup time
improvements, because the code within VeryExpensive.js will only execute
once it is required for the first time.

Enable the RAM format 

On iOS using the RAM format will create a single indexed file that react
native will load one module at a time. On Android, by default it will
create a set of files for each module. You can force Android to create a
single file, like iOS, but using multiple files can be more performant
and requires less memory.

Enable the RAM format in Xcode by editing the build phase "Bundle React
Native code and images". Before
 ../node_modules/react-native/scripts/react-native-xcode.sh add
 export BUNDLE_COMMAND="ram-bundle" :

    export BUNDLE_COMMAND="ram-bundle"
    export NODE_BINARY=node
    ../node_modules/react-native/scripts/react-native-xcode.sh

 

On Android enable the RAM format by editing your
 android/app/build.gradle file. Before the line
 apply from: "../../node_modules/react-native/react.gradle" add or amend
the  project.ext.react block:

    project.ext.react = [
      bundleCommand: "ram-bundle",
    ]

 

Use the following lines on Android if you want to use a single indexed
file:

    project.ext.react = [
      bundleCommand: "ram-bundle",
      extraPackagerArgs: ["--indexed-ram-bundle"]
    ]

 

 info

If you are using Hermes JS Engine , you should not have RAM bundles
feature enabled. In Hermes, when loading the bytecode,  mmap ensures
that the entire file is not loaded. Using Hermes with RAM bundles might
lead to issues, because those mechanisms are not compatible with each
other.

Configure Preloading and Inline Requires 

Now that we have a RAM bundle, there is overhead for calling  require .
 require now needs to send a message over the bridge when it encounters
a module it has not loaded yet. This will impact startup the most,
because that is where the largest number of require calls are likely to
take place while the app loads the initial module. Luckily we can
configure a portion of the modules to be preloaded. In order to do this,
you will need to implement some form of inline require.

Investigating the Loaded Modules 

In your root file (index.(ios|android).js) you can add the following
after the initial imports:

    const modules = require.getModules();
    const moduleIds = Object.keys(modules);
    const loadedModuleNames = moduleIds
      .filter(moduleId => modules[moduleId].isInitialized)
      .map(moduleId => modules[moduleId].verboseName);
    const waitingModuleNames = moduleIds
      .filter(moduleId => !modules[moduleId].isInitialized)
      .map(moduleId => modules[moduleId].verboseName);

    // make sure that the modules you expect to be waiting are actually waiting
    console.log(
      'loaded:',
      loadedModuleNames.length,
      'waiting:',
      waitingModuleNames.length,
    );

    // grab this text blob, and put it in a file named packager/modulePaths.js
    console.log(
      `module.exports = ${JSON.stringify(
        loadedModuleNames.sort(),
        null,
        2,
      )};`,
    );

 

When you run your app, you can look in the console and see how many
modules have been loaded, and how many are waiting. You may want to read
the moduleNames and see if there are any surprises. Note that inline
requires are invoked the first time the imports are referenced. You may
need to investigate and refactor to ensure only the modules you want are
loaded on startup. Note that you can change the Systrace object on
require to help debug problematic requires.

    require.Systrace.beginEvent = message => {
      if (message.includes(problematicModule)) {
        throw new Error();
      }
    };

 

Every app is different, but it may make sense to only load the modules
you need for the very first screen. When you are satisfied, put the
output of the loadedModuleNames into a file named
 packager/modulePaths.js .

Updating the metro.config.js 

We now need to update  metro.config.js in the root of the project to use
our newly generated  modulePaths.js file:

    const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');
    const fs = require('fs');
    const path = require('path');
    const modulePaths = require('./packager/modulePaths');

    const config = {
      transformer: {
        getTransformOptions: () => {
          const moduleMap = {};
          modulePaths.forEach(modulePath => {
            if (fs.existsSync(modulePath)) {
              moduleMap[path.resolve(modulePath)] = true;
            }
          });
          return {
            preloadedModules: moduleMap,
            transform: {inlineRequires: {blockList: moduleMap}},
          };
        },
      },
    };

    module.exports = mergeConfig(getDefaultConfig(__dirname), config);

 

See also Configuring Metro .

The  preloadedModules entry in the config indicates which modules should
be marked as preloaded when building a RAM bundle. When the bundle is
loaded, those modules are immediately loaded, before any requires have
even executed. The  blockList entry indicates that those modules should
not be required inline. Because they are preloaded, there is no
performance benefit from using an inline require. In fact the generated
JavaScript spends extra time resolving the inline require every time the
imports are referenced.

Test and Measure Improvements 

You should now be ready to build your app using the RAM format and
inline requires. Make sure you measure the before and after startup
times.

# React 18 & React Native #
 ____                 _     _  ___     ___     ____                 _   
|  _ \ ___  __ _  ___| |_  / |( _ )   ( _ )   |  _ \ ___  __ _  ___| |_ 
| |_) / _ \/ _` |/ __| __| | |/ _ \   / _ \/\ | |_) / _ \/ _` |/ __| __|
|  _ <  __/ (_| | (__| |_  | | (_) | | (_>  < |  _ <  __/ (_| | (__| |_ 
|_| \_\___|\__,_|\___|\__| |_|\___/   \___/\/ |_| \_\___|\__,_|\___|\__|
                                                                        
 _   _       _   _           
| \ | | __ _| |_(_)_   _____ 
|  \| |/ _` | __| \ \ / / _ \
| |\  | (_| | |_| |\ V /  __/
|_| \_|\__,_|\__|_| \_/ \___|
                             
-   React 18 and the React Native New Architecture
-   React 18 enabled by default
    -   Opt-ing out of React 18 on Android
    -   Opt-ing out of React 18 on iOS
    -   Users on React Native 0.69 not yet migrated to the New
        Architecture
React 18 & React Native

 caution

This documentation is still experimental and details are subject to
changes as we iterate. Feel free to share your feedback on the
discussion inside the working group for this page.

Moreover, it contains several manual steps . Please note that this won't
be representative of the final developer experience once the New
Architecture is stable. We're working on tools, templates and libraries
to help you get started fast on the New Architecture, without having to
go through the whole setup.

This page describes how to use React 18 with React Native using the
React Native's New Architecture.

  tl;dr: The first version of React Native compatible with React 18 is
  0.69.0 . In order to use the new features in React 18 including
  automatic batching,  startTransition , and  useDeferredValue , you
  must migrate your React Native app to the New Architecture.

React 18 and the React Native New Architecture 

React 18 introduces several new features including:

-   Automatic batching
-   New Strict Mode behaviors
-   New hooks (  useId ,  useSyncExternalStore )

It also includes new concurrent features:

-    startTransition
-    useTransition
-    useDeferredValue
-   Full Suspense support

The concurrent features in React 18 are built on top of the new
concurrent rendering engine. Concurrent rendering is a new
behind-the-scenes mechanism that enables React to prepare multiple
versions of your UI at the same time.

Previous versions of React Native built on the old architecture cannot
support concurrent rendering or concurrent features. This is because the
old architecture relied on mutating the native trees, which doesn’t
allow for React to prepare multiple versions of the tree at the same
time.

Fortunately, the New Architecture was written bottom-up with concurrent
rendering in mind, and is fully compatible with React 18. This means, in
order to upgrade to React 18 in your React Native app, your application
needs to be migrated to the React Native's New Architecture including
Fabric Native Components and Turbo Native Modules.

React 18 enabled by default 

Starting in React Native 0.69, React 18 is enabled by default when you
enable the New Architecture.

This means you’re able to use the new features in React 18 as soon as
you migrate. Since the new concurrent features are opt-in by using
features like  startTransition or  Suspense , we expect React 18 to work
out-of-the-box with minimal changes for users who migrate to the New
Architecture or create a new app with the New Architecture enabled.

However, if you do hit any issues, we provide an option to opt-out of
the new root in React 18. Opt-ing out means your app will run in React
17 mode, and none of the features of React 18 will be accessible.

Opt-ing out of React 18 on Android 

On Android, you will be able to override the  isConcurrentRootEnabled in
your ActivityDelegate (in the  MainActivity file), and enable/disable
Concurrent React.

-   Java
-   Kotlin

    public class MainActivity extends ReactActivity {

      public static class MainActivityDelegate extends ReactActivityDelegate {
        public MainActivityDelegate(ReactActivity activity, String mainComponentName) {
          super(activity, mainComponentName);
        }

        @Override
        protected ReactRootView createRootView() {
          ReactRootView reactRootView = new ReactRootView(getContext());
          // If you opted-in for the New Architecture, we enable the Fabric Renderer.
          reactRootView.setIsFabric(BuildConfig.IS_NEW_ARCHITECTURE_ENABLED);
          return reactRootView;
        }

    +   @Override
    +   protected boolean isConcurrentRootEnabled() {
    +     // If you opted-in for the New Architecture, we enable Concurrent Root (i.e. React 18).
    +     // More on this on https://reactjs.org/blog/2022/03/29/react-v18.html
    +     return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
    +   }
      }
    }

 

    class MainActivity : ReactActivity() {

        open class MainActivityDelegate(activity: ReactActivity?, mainComponentName: String?) : ReactActivityDelegate(activity, mainComponentName) {
            override fun createRootView(): ReactRootView = ReactRootView(context).apply {
                // If you opted-in for the New Architecture, we enable the Fabric Renderer.
                setIsFabric(BuildConfig.IS_NEW_ARCHITECTURE_ENABLED)
            }

    +       // If you opted-in for the New Architecture, we enable Concurrent Root (i.e. React 18).
    +       // More on this on https://reactjs.org/blog/2022/03/29/react-v18.html
    +       override fun isConcurrentRootEnabled() = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        }
    }

 

Opt-ing out of React 18 on iOS 

On iOS, you'll have access to the  concurrentRootEnabled method on your
 AppDelegate.mm file. You should change the returned value to  false (or
 NO ) to disable the feature.

    /// This method controls whether the `concurrentRoot`feature of React18 is turned on or off.
    ///
    /// @see: https://reactjs.org/blog/2022/03/29/react-v18.html
    /// @note: This requires to be rendering on Fabric (i.e. on the New Architecture).
    /// @return: `true` if the `concurrentRoot` feature is enabled. Otherwise, it returns `false`.
    - (BOOL)concurrentRootEnabled
    {
      // Switch this bool to turn on and off the concurrent root
      return true;
    }

 

Users on React Native 0.69 not yet migrated to the New Architecture 

Note: Users on React Native 0.69, but still on the Old Architecture will
still use React 17 mode even if React 18 is installed in the
 package.json file.

Overriding the  isConcurrentRootEnabled method will have no effect on
your app.

# React DevTools #
 ____                 _     ____             _____           _     
|  _ \ ___  __ _  ___| |_  |  _ \  _____   _|_   _|__   ___ | |___ 
| |_) / _ \/ _` |/ __| __| | | | |/ _ \ \ / / | |/ _ \ / _ \| / __|
|  _ <  __/ (_| | (__| |_  | |_| |  __/\ V /  | | (_) | (_) | \__ \
|_| \_\___|\__,_|\___|\__| |____/ \___| \_/   |_|\___/ \___/|_|___/
                                                                   
-   Integration with the Element Inspector
-   Debugging application state
-   Troubleshooting
React DevTools

React DevTools can be used to debug the React component hierarchy within
your app.

The standalone version of React DevTools allows connecting to React
Native apps. To use it, install or run the  react-devtools package. It
should connect to your simulator within a few seconds.

    npx react-devtools

 

[The React DevTools interface]

💡 Installing React DevTools globally

We recommend running  react-devtools via  npx , but you can also install
a given version globally.

-   npm
-   Yarn

    npm install -g react-devtools

 

    yarn global add react-devtools

 

Then, run the global  react-devtools command:

    react-devtools

 

💡 Adding React DevTools as a project dependency

If you prefer to avoid global installations, you can add  react-devtools
as a project dependency. Add the  react-devtools package to your project
using  npm install --save-dev react-devtools , then add
 "react-devtools": "react-devtools" to the  scripts section in your
 package.json , and then run  npm run react-devtools from your project
folder to open the DevTools.

 tip

Learn more about using DevTools in the React Developer Tools guide on
react.dev .

Integration with the Element Inspector 

React Native provides an Element Inspector, available under the Dev Menu
as "Show Element Inspector". The inspector lets you tap on any UI
element and see information about it.

[Video of the Element Inspector interface]

When React DevTools is connected, the Element Inspector will enter a
collapsed mode , and instead use DevTools as the primary UI. In this
mode, clicking on something in the simulator will navigate to the
relevant component in DevTools.

You can select "Hide Element Inspector" in the same menu to exit this
mode.

[React DevTools Element Inspector integration]

Debugging application state 

Reactotron is an open-source desktop app that allows you to inspect
Redux or MobX-State-Tree application state as well as view custom logs,
run custom commands such as resetting state, store and restore state
snapshots, and other helpful debugging features for React Native apps.

You can view installation instructions in the README . If you're using
Expo, here is an article detailing how to install on Expo .

Troubleshooting 

 tip

Once you have React DevTools running, follow the instructions. If you
had your application running prior to opening React DevTools, you may
need to open the Dev Menu to connect it.

[React DevTools connection flow]

 info

If connecting to an Android emulator proves troublesome, try running
 adb reverse tcp:8097 tcp:8097 in a new terminal.

# React Fundamentals #
 ____                 _   
|  _ \ ___  __ _  ___| |_ 
| |_) / _ \/ _` |/ __| __|
|  _ <  __/ (_| | (__| |_ 
|_| \_\___|\__,_|\___|\__|
                          
 _____                _                            _        _     
|  ___|   _ _ __   __| | __ _ _ __ ___   ___ _ __ | |_ __ _| |___ 
| |_ | | | | '_ \ / _` |/ _` | '_ ` _ \ / _ \ '_ \| __/ _` | / __|
|  _|| |_| | | | | (_| | (_| | | | | | |  __/ | | | || (_| | \__ \
|_|   \__,_|_| |_|\__,_|\__,_|_| |_| |_|\___|_| |_|\__\__,_|_|___/
                                                                  
-   Your first component
-   JSX
-   Custom Components
-   Props
-   State
React Fundamentals

React Native runs on React , a popular open source library for building
user interfaces with JavaScript. To make the most of React Native, it
helps to understand React itself. This section can get you started or
can serve as a refresher course.

We’re going to cover the core concepts behind React:

-   components
-   JSX
-   props
-   state

If you want to dig deeper, we encourage you to check out React’s
official documentation .

Your first component 

The rest of this introduction to React uses cats in its examples:
friendly, approachable creatures that need names and a cafe to work in.
Here is your very first Cat component:

Here is how you do it: To define your  Cat component, first use
JavaScript’s  import to import React and React Native’s  Text Core
Component:

    import React from 'react';
    import {Text} from 'react-native';

 

Your component starts as a function:

    const Cat = () => {};

 

You can think of components as blueprints. Whatever a function component
returns is rendered as a React element. React elements let you describe
what you want to see on the screen.

Here the  Cat component will render a  <Text> element:

    const Cat = () => {
      return <Text>Hello, I am your cat!</Text>;
    };

 

You can export your function component with JavaScript’s  export default
for use throughout your app like so:

    const Cat = () => {
      return <Text>Hello, I am your cat!</Text>;
    };

    export default Cat;

 

  This is one of many ways to export your component. This kind of export
  works well with the Snack Player. However, depending on your app’s
  file structure, you might need to use a different convention. This
  handy cheatsheet on JavaScript imports and exports can help.

Now take a closer look at that  return statement.
 <Text>Hello, I am your cat!</Text> is using a kind of JavaScript syntax
that makes writing elements convenient: JSX.

JSX 

React and React Native use JSX, a syntax that lets you write elements
inside JavaScript like so:  <Text>Hello, I am your cat!</Text> . The
React docs have a comprehensive guide to JSX you can refer to learn even
more. Because JSX is JavaScript, you can use variables inside it. Here
you are declaring a name for the cat,  name , and embedding it with
curly braces inside  <Text> .

Any JavaScript expression will work between curly braces, including
function calls like  {getFullName("Rum", "Tum", "Tugger")} :

-   TypeScript
-   JavaScript

You can think of curly braces as creating a portal into JS functionality
in your JSX!

  Because JSX is included in the React library, it won’t work if you
  don’t have  import React from 'react' at the top of your file!

Custom Components 

You’ve already met React Native’s Core Components . React lets you nest
these components inside each other to create new components. These
nestable, reusable components are at the heart of the React paradigm.

For example, you can nest  Text and  TextInput inside a  View below, and
React Native will render them together:

Developer notes 

-   Android
-   Web

  If you’re familiar with web development,  <View> and  <Text> might
  remind you of HTML! You can think of them as the  <div> and  <p> tags
  of application development.

  On Android, you usually put your views inside  LinearLayout ,
   FrameLayout ,  RelativeLayout , etc. to define how the view’s
  children will be arranged on the screen. In React Native,  View uses
  Flexbox for its children’s layout. You can learn more in our guide to
  layout with Flexbox .

You can render this component multiple times and in multiple places
without repeating your code by using  <Cat> :

Any component that renders other components is a parent component. Here,
 Cafe is the parent component and each  Cat is a child component.

You can put as many cats in your cafe as you like. Each  <Cat> renders a
unique element—which you can customize with props.

Props 

Props is short for “properties”. Props let you customize React
components. For example, here you pass each  <Cat> a different  name for
 Cat to render:

-   TypeScript
-   JavaScript

Most of React Native’s Core Components can be customized with props,
too. For example, when using  Image , you pass it a prop named  source
to define what image it shows:

 Image has many different props , including  style , which accepts a JS
object of design and layout related property-value pairs.

  Notice the double curly braces  {{ }} surrounding  style ‘s width and
  height. In JSX, JavaScript values are referenced with  {} . This is
  handy if you are passing something other than a string as props, like
  an array or number:  <Cat food={["fish", "kibble"]} age={2} /> .
  However, JS objects are also denoted with curly braces:
   {width: 200, height: 200} . Therefore, to pass a JS object in JSX,
  you must wrap the object in another pair of curly braces:
   {{width: 200, height: 200}}

You can build many things with props and the Core Components  Text ,
 Image , and  View ! But to build something interactive, you’ll need
state.

State 

While you can think of props as arguments you use to configure how
components render, state is like a component’s personal data storage.
State is useful for handling data that changes over time or that comes
from user interaction. State gives your components memory!

  As a general rule, use props to configure a component when it renders.
  Use state to keep track of any component data that you expect to
  change over time.

The following example takes place in a cat cafe where two hungry cats
are waiting to be fed. Their hunger, which we expect to change over time
(unlike their names), is stored as state. To feed the cats, press their
buttons—which will update their state.

You can add state to a component by calling React’s  useState Hook . A
Hook is a kind of function that lets you “hook into” React features. For
example,  useState is a Hook that lets you add state to function
components. You can learn more about other kinds of Hooks in the React
documentation.

-   TypeScript
-   JavaScript

First, you will want to import  useState from React like so:

    import React, {useState} from 'react';

 

Then you declare the component’s state by calling  useState inside its
function. In this example,  useState creates an  isHungry state
variable:

    const Cat = (props: CatProps) => {
      const [isHungry, setIsHungry] = useState(true);
      // ...
    };

 

  You can use  useState to track any kind of data: strings, numbers,
  Booleans, arrays, objects. For example, you can track the number of
  times a cat has been petted with
   const [timesPetted, setTimesPetted] = useState(0) !

Calling  useState does two things:

-   it creates a “state variable” with an initial value—in this case the
    state variable is  isHungry and its initial value is  true
-   it creates a function to set that state variable’s value—
     setIsHungry

It doesn’t matter what names you use. But it can be handy to think of
the pattern as  [<getter>, <setter>] = useState(<initialValue>) .

Next you add the  Button Core Component and give it an  onPress prop:

    <Button
      onPress={() => {
        setIsHungry(false);
      }}
      //..
    />

 

Now, when someone presses the button,  onPress will fire, calling the
 setIsHungry(false) . This sets the state variable  isHungry to  false .
When  isHungry is false, the  Button ’s  disabled prop is set to  true
and its  title also changes:

    <Button
      //..
      disabled={!isHungry}
      title={isHungry ? 'Pour me some milk, please!' : 'Thank you!'}
    />

 

  You might’ve noticed that although  isHungry is a const , it is
  seemingly reassignable! What is happening is when a state-setting
  function like  setIsHungry is called, its component will re-render. In
  this case the  Cat function will run again—and this time,  useState
  will give us the next value of  isHungry .

Finally, put your cats inside a  Cafe component:

    const Cafe = () => {
      return (
        <>
          <Cat name="Munkustrap" />
          <Cat name="Spot" />
        </>
      );
    };

 

  See the  <> and  </> above? These bits of JSX are fragments . Adjacent
  JSX elements must be wrapped in an enclosing tag. Fragments let you do
  that without nesting an extra, unnecessary wrapping element like  View
  .

------------------------------------------------------------------------

Now that you’ve covered both React and React Native’s Core Components,
let’s dive deeper on some of these core components by looking at
handling  <TextInput> .

# React Native Gradle Plugin #
 ____                 _     _   _       _   _           
|  _ \ ___  __ _  ___| |_  | \ | | __ _| |_(_)_   _____ 
| |_) / _ \/ _` |/ __| __| |  \| |/ _` | __| \ \ / / _ \
|  _ <  __/ (_| | (__| |_  | |\  | (_| | |_| |\ V /  __/
|_| \_\___|\__,_|\___|\__| |_| \_|\__,_|\__|_| \_/ \___|
                                                        
  ____               _ _        ____  _             _       
 / ___|_ __ __ _  __| | | ___  |  _ \| |_   _  __ _(_)_ __  
| |  _| '__/ _` |/ _` | |/ _ \ | |_) | | | | |/ _` | | '_ \ 
| |_| | | | (_| | (_| | |  __/ |  __/| | |_| | (_| | | | | |
 \____|_|  \__,_|\__,_|_|\___| |_|   |_|\__,_|\__, |_|_| |_|
                                              |___/         
-   Using the plugin
-   Configuring the plugin
    -    root
    -    reactNativeDir
    -    codegenDir
    -    cliFile
    -    debuggableVariants
    -    nodeExecutableAndArgs
    -    bundleCommand
    -    bundleConfig
    -    bundleAssetName
    -    entryFile
    -    extraPackagerArgs
    -    hermesCommand
    -    hermesFlags
-   Using Flavors & Build Variants
-   What is the plugin doing under the hood?
React Native Gradle Plugin

This guide describes how to configure the React Native Gradle Plugin
(often referred as RNGP), when building your React Native application
for Android.

Using the plugin 

The React Native Gradle Plugin is distributed as a separate NPM package
which is installed automatically with  react-native .

The plugin is already configured for new projects created using
 npx react-native init . You don't need to do any extra steps to install
it if you created your app with this command.

If you're integrating React Native into an existing project, please
refer to the corresponding page : it contains specific instructions on
how to install the plugin.

Configuring the plugin 

By default, the plugin will work out of the box with sensible defaults.
You should refer to this guide and customize the behavior only if you
need it.

To configure the plugin you can modify the  react block, inside your
 android/app/build.gradle :

    apply plugin: "com.facebook.react"

    /**
     * This is the configuration block to customize your React Native Android app.
     * By default you don't need to apply any configuration, just uncomment the lines you need.
     */
    react {
      // Custom configuration goes here.
    }

 

Each configuration key is described below:

 root 

This is the root folder of your React Native project, i.e. where the
 package.json file lives. Default is  .. . You can customize it as
follows:

    root = file("../")

 

 reactNativeDir 

This is the folder where the  react-native package lives. Default is
 ../node_modules/react-native . If you're in a monorepo or using a
different package manager, you can use adjust  reactNativeDir to your
setup.

You can customize it as follows:

    reactNativeDir = file("../node_modules/react-native")

 

 codegenDir 

This is the folder where the  react-native-codegen package lives.
Default is  ../node_modules/react-native-codegen . If you're in a
monorepo or using a different package manager, you can adjust
 codegenDir to your setup.

You can customize it as follows:

    codegenDir = file("../node_modules/@react-native/codegen")

 

 cliFile 

This is the entrypoint file for the React Native CLI. Default is
 ../node_modules/react-native/cli.js . The entrypoint file is needed as
the plugin needs to invoke the CLI for bundling and creating your app.

If you're in a monorepo or using a different package manager, you can
adjust  cliFile to your setup. You can customize it as follows:

    cliFile = file("../node_modules/react-native/cli.js")

 

 debuggableVariants 

This is the list of variants that are debuggable (see using variants for
more context on variants).

By default the plugin is considering as  debuggableVariants only  debug
, while  release is not. If you have other variants (like  staging ,
 lite , etc.) you'll need to adjust this accordingly.

Variants that are listed as  debuggableVariants will not come with a
shipped bundle, so you'll need Metro to run them.

You can customize it as follows:

    debuggableVariants = ["liteDebug", "prodDebug"]

 

 nodeExecutableAndArgs 

This is the list of node command and arguments that should be invoked
for all the scripts. By default is  [node] but can be customized to add
extra flags as follows:

    nodeExecutableAndArgs = ["node"]

 

 bundleCommand 

This is the name of the  bundle command to be invoked when creating the
bundle for your app. That's useful if you're using RAM Bundles . By
default is  bundle but can be customized to add extra flags as follows:

    bundleCommand = "ram-bundle"

 

 bundleConfig 

This is the path to a configuration file that will be passed to
 bundle --config <file> if provided. Default is empty (no config file
will be probided). More information on bundling config files can be
found on the CLI documentation . Can be customized as follow:

    bundleConfig = file(../rn-cli.config.js)

 

 bundleAssetName 

This is the name of the bundle file that should be generated. Default is
 index.android.bundle . Can be customized as follow:

    bundleAssetName = "MyApplication.android.bundle"

 

 entryFile 

The entry file used for bundle generation. The default is to search for
 index.android.js or  index.js . Can be customized as follow:

    entryFile = file("../js/MyApplication.android.js")

 

 extraPackagerArgs 

A list of extra flags that will be passed to the  bundle command. The
list of available flags is in the CLI documentation . Default is empty.
Can be customized as follows:

    extraPackagerArgs = 

 

 hermesCommand 

The path to the  hermesc command (the Hermes Compiler). React Native
comes with a version of the Hermes compiler bundled with it, so you
generally won't be needing to customize this. The plugin will use the
correct compiler for your system by default.

 hermesFlags 

The list of flags to pass to  hermesc . By default is
 ["-O", "-output-source-map"] . You can customize it as follows

    hermesFlags = ["-O", "-output-source-map"]

 

Using Flavors & Build Variants 

When building Android apps, you might want to use custom flavors to have
different versions of your app starting from the same project.

Please refer to the official Android guide to configure custom build
types (like  staging ) or custom flavors (like  full ,  lite , etc.). By
default new apps are create with two build types (  debug and  release )
and no custom flavors.

The combination of all the build types and all the flavors generates a
set of build variants . For instance for  debug /  staging /  release
build types and  full /  lite you will have 6 build variants:  fullDebug
,  fullStaging ,  fullRelease and so on.

If you're using custom variants beyond  debug and  release , you need to
instruct the React Native Gradle Plugin specifying which of your
variants are debuggable using the  debuggableVariants configuration as
follows:

    apply plugin: "com.facebook.react"

    react {
    + debuggableVariants = ["fullStaging", "fullDebug"]
    }

 

This is necessary because the plugin will skip the JS bundling for all
the  debuggableVariants : you'll need Metro to run them. For example, if
you list  fullStaging in the  debuggableVariants , you won't be able to
publish it to a store as it will be missing the bundle.

What is the plugin doing under the hood? 

The React Native Gradle Plugin is responsible for configuring your
Application build to ship React Native applications to production. The
plugin is also used inside 3rd party libraries, to run the Codegen used
for the New Architecture.

Here is a summary of the plugin responsibilities:

-   Add a  createBundle<Variant>JsAndAssets task for every non
    debuggable variant, that is responsible of invoking the  bundle ,
     hermesc and  compose-source-map commands.
-   Setting up the proper version of the
     com.facebook.react:react-android and
     com.facebook.react:hermes-android dependency, reading the React
    Native version from the  package.json of  react-native .
-   Setting up the proper Maven repositories (Maven Central, Google
    Maven Repo, JSC local Maven repo, etc.) needed to consume all the
    necessary Maven Dependencies.
-   Setting up the NDK to let you build apps that are using the New
    Architecture.
-   Setting up the  buildConfigFields so that you can know at runtime if
    Hermes or the New Architecture are enabled.
-   Setting up the Metro DevServer Port as an Android resource so the
    app knows on which port to connect.
-   Invoking the React Native Codegen if a library or app is using the
    Codegen for the New Architecture.

# React Node Object Type #
 ____                 _     _   _           _      
|  _ \ ___  __ _  ___| |_  | \ | | ___   __| | ___ 
| |_) / _ \/ _` |/ __| __| |  \| |/ _ \ / _` |/ _ \
|  _ <  __/ (_| | (__| |_  | |\  | (_) | (_| |  __/
|_| \_\___|\__,_|\___|\__| |_| \_|\___/ \__,_|\___|
                                                   
  ___  _     _           _     _____                 
 / _ \| |__ (_) ___  ___| |_  |_   _|   _ _ __   ___ 
| | | | '_ \| |/ _ \/ __| __|   | || | | | '_ \ / _ \
| |_| | |_) | |  __/ (__| |_    | || |_| | |_) |  __/
 \___/|_.__// |\___|\___|\__|   |_| \__, | .__/ \___|
          |__/                      |___/|_|         

React Node Object Type

A React Node is one of the following types:

-   Boolean (which is ignored)
-    null or  undefined (which is ignored)
-   Number
-   String
-   A React element (result of JSX)
-   An array of any of the above, possibly a nested one

# Rect Object Type #
 ____           _      ___  _     _           _     _____                 
|  _ \ ___  ___| |_   / _ \| |__ (_) ___  ___| |_  |_   _|   _ _ __   ___ 
| |_) / _ \/ __| __| | | | | '_ \| |/ _ \/ __| __|   | || | | | '_ \ / _ \
|  _ <  __/ (__| |_  | |_| | |_) | |  __/ (__| |_    | || |_| | |_) |  __/
|_| \_\___|\___|\__|  \___/|_.__// |\___|\___|\__|   |_| \__, | .__/ \___|
                               |__/                      |___/|_|         
-   Example
-   Keys and values
    -    bottom
    -    left
    -    right
    -    top
-   Used by
Rect Object Type

 Rect accepts numeric pixel values to describe how far to extend a
rectangular area. These values are added to the original area's size to
expand it.

Example 

    {
        bottom: 20,
        left: null,
        right: undefined,
        top: 50
    }

 

Keys and values 

 bottom 

  Type                         Required
  ---------------------------- ----------
  number,  null ,  undefined   No

 left 

  Type                         Required
  ---------------------------- ----------
  number,  null ,  undefined   No

 right 

  Type                         Required
  ---------------------------- ----------
  number,  null ,  undefined   No

 top 

  Type                         Required
  ---------------------------- ----------
  number,  null ,  undefined   No

Used by 

-    Image
-    Pressable
-    Text
-    TouchableWithoutFeedback

# RefreshControl #
 ____       __               _      ____            _             _ 
|  _ \ ___ / _|_ __ ___  ___| |__  / ___|___  _ __ | |_ _ __ ___ | |
| |_) / _ \ |_| '__/ _ \/ __| '_ \| |   / _ \| '_ \| __| '__/ _ \| |
|  _ <  __/  _| | |  __/\__ \ | | | |__| (_) | | | | |_| | | (_) | |
|_| \_\___|_| |_|  \___||___/_| |_|\____\___/|_| |_|\__|_|  \___/|_|
                                                                    
-   Example
-   Props
    -   View Props
    -   
        Required

         refreshing
    -    colors
        Android
    -    enabled
        Android
    -    onRefresh
    -    progressBackgroundColor
        Android
    -    progressViewOffset
    -    size
        Android
    -    tintColor
        iOS
    -    title
        iOS
    -    titleColor
        iOS
RefreshControl

This component is used inside a ScrollView or ListView to add pull to
refresh functionality. When the ScrollView is at  scrollY: 0 , swiping
down triggers an  onRefresh event.

Example 

  Note:  refreshing is a controlled prop, this is why it needs to be set
  to  true in the  onRefresh function otherwise the refresh indicator
  will stop immediately.

------------------------------------------------------------------------

Reference

Props 

View Props 

Inherits View Props .

------------------------------------------------------------------------

Required

 refreshing 

Whether the view should be indicating an active refresh.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 colors

Android



The colors (at least one) that will be used to draw the refresh
indicator.

  Type
  -----------------
  array of colors

------------------------------------------------------------------------

 enabled

Android



Whether the pull to refresh functionality is enabled.

  Type      Default
  --------- ---------
  boolean    true

------------------------------------------------------------------------

 onRefresh 

Called when the view starts refreshing.

  Type
  ----------
  function

------------------------------------------------------------------------

 progressBackgroundColor

Android



The background color of the refresh indicator.

  Type
  -------
  color

------------------------------------------------------------------------

 progressViewOffset 

Progress view top offset.

  Type     Default
  -------- ---------
  number    0

------------------------------------------------------------------------

 size

Android



Size of the refresh indicator.

  Type                            Default
  ------------------------------- ------------
  enum(  'default' ,  'large' )    'default'

------------------------------------------------------------------------

 tintColor

iOS



The color of the refresh indicator.

  Type
  -------
  color

------------------------------------------------------------------------

 title

iOS



The title displayed under the refresh indicator.

  Type
  --------
  string

------------------------------------------------------------------------

 titleColor

iOS



The color of the refresh indicator title.

  Type
  -------
  color

# RootTag #
 ____             _  _____           
|  _ \ ___   ___ | ||_   _|_ _  __ _ 
| |_) / _ \ / _ \| __|| |/ _` |/ _` |
|  _ < (_) | (_) | |_ | | (_| | (_| |
|_| \_\___/ \___/ \__||_|\__,_|\__, |
                               |___/ 
-   When to use a RootTag?
-   How to access the RootTag... if you need it
    -   Breaking Change in 0.65
    -   Breaking Change in 0.66
-   Future Plans
RootTag

 RootTag is an opaque identifier assigned to the native root view of
your React Native surface — i.e. the  ReactRootView or  RCTRootView
instance for Android or iOS respectively. In short, it is a surface
identifier.

When to use a RootTag? 

For most React Native developers, you likely won’t need to deal with
 RootTag s.

 RootTag s are useful for when an app renders multiple React Native root
views and you need to handle native API calls differently depending on
the surface. An example of this is when an app is using native
navigation and each screen is a separate React Native root view.

In native navigation, every React Native root view is rendered in a
platform’s navigation view (e.g.,  Activity for Android,
 UINavigationViewController for iOS). By this, you are able to leverage
the navigation paradigms of the platform such as native look and feel
and navigation transitions. The functionality to interact with the
native navigation APIs can be exposed to React Native via a native
module .

For example, to update the title bar of a screen, you would call the
navigation module’s API  setTitle("Updated Title") , but it would need
to know which screen in the stack to update. A  RootTag is necessary
here to identify the root view and its hosting container.

Another use case for  RootTag is when your app needs to attribute a
certain JavaScript call to native based on its originating root view. A
 RootTag is necessary to differentiate the source of the call from
different surfaces.

How to access the RootTag... if you need it 

In versions 0.65 and below, RootTag is accessed via a legacy context .
To prepare React Native for Concurrent features coming in React 18 and
beyond, we are migrating to the latest Context API via  RootTagContext
in 0.66. Version 0.65 supports both the legacy context and the
recommended  RootTagContext to allow developers time to migrate their
call-sites. See the breaking changes summary.

How to access  RootTag via the  RootTagContext .

    import {RootTagContext} from 'react-native';
    import NativeAnalytics from 'native-analytics';
    import NativeNavigation from 'native-navigation';

    function ScreenA() {
      const rootTag = useContext(RootTagContext);

      const updateTitle = title => {
        NativeNavigation.setTitle(rootTag, title);
      };

      const handleOneEvent = () => {
        NativeAnalytics.logEvent(rootTag, 'one_event');
      };

      // ...
    }

    class ScreenB extends React.Component {
      static contextType: typeof RootTagContext = RootTagContext;

      updateTitle(title) {
        NativeNavigation.setTitle(this.context, title);
      }

      handleOneEvent() {
        NativeAnalytics.logEvent(this.context, 'one_event');
      }

      // ...
    }

 

Learn more about the Context API for classes and hooks from the React
docs.

Breaking Change in 0.65 

 RootTagContext was formerly named  unstable_RootTagContext and changed
to  RootTagContext in 0.65. Please update any usages of
 unstable_RootTagContext in your codebase.

Breaking Change in 0.66 

The legacy context access to  RootTag will be removed and replaced by
 RootTagContext . Beginning in 0.65, we encourage developers to
proactively migrate  RootTag accesses to  RootTagContext .

Future Plans 

With the new React Native architecture progressing, there will be future
iterations to  RootTag , with the intention to keep the  RootTag type
opaque and prevent thrash in React Native codebases. Please do not rely
on the fact that RootTag currently aliases to a number! If your app
relies on RootTags, keep an eye on our version change logs, which you
can find here .

# Running On Device #
 ____                    _                ___        
|  _ \ _   _ _ __  _ __ (_)_ __   __ _   / _ \ _ __  
| |_) | | | | '_ \| '_ \| | '_ \ / _` | | | | | '_ \ 
|  _ <| |_| | | | | | | | | | | | (_| | | |_| | | | |
|_| \_\\__,_|_| |_|_| |_|_|_| |_|\__, |  \___/|_| |_|
                                 |___/               
 ____             _          
|  _ \  _____   _(_) ___ ___ 
| | | |/ _ \ \ / / |/ __/ _ \
| |_| |  __/\ V /| | (_|  __/
|____/ \___| \_/ |_|\___\___|
                             

Running On Device

It's always a good idea to test your app on an actual device before
releasing it to your users. This document will guide you through the
necessary steps to run your React Native app on a device and to get it
ready for production.

 info

If you used  create-expo-app to set up your project, you can run your
app on a device in Expo Go by scanning the QR code that is displayed
when you run  npm start . Refer to the Expo guide for running your
project on your device for more information.

-   Android
-   iOS

Running your app on Android devices 

Development OS 

-   macOS
-   Windows
-   Linux

1. Enable Debugging over USB 

Most Android devices can only install and run apps downloaded from
Google Play, by default. You will need to enable USB Debugging on your
device in order to install your app during development.

To enable USB debugging on your device, you will first need to enable
the "Developer options" menu by going to Settings → About phone →
Software information and then tapping the  Build number row at the
bottom seven times. You can then go back to Settings → Developer options
to enable "USB debugging".

2. Plug in your device via USB 

Let's now set up an Android device to run our React Native projects. Go
ahead and plug in your device via USB to your development machine.

Now check that your device is properly connecting to ADB, the Android
Debug Bridge, by running  adb devices .

    $ adb devices
    List of devices attached
    emulator-5554 offline   # Google emulator
    14ed2fcc device         # Physical device

 

Seeing  device in the right column means the device is connected. You
must have only one device connected at a time.

 note

If you see  unauthorized in the list you will need to run
 adb reverse tcp:8081 tcp:8081 and press allow USB debugging on the
device.

3. Run your app 

From the root of your project; type the following in your command prompt
to install and launch your app on the device:

-   npm
-   Yarn

    npm run android

 

    yarn android

 

  If you get a "bridge configuration isn't available" error, see Using
  adb reverse .

  Hint: You can also use the  React Native CLI to generate and run a
   release build (e.g. from the root of your project:
   yarn android --mode release ).

Connecting to the development server

You can also iterate quickly on a device by connecting to the
development server running on your development machine. There are
several ways of accomplishing this, depending on whether you have access
to a USB cable or a Wi-Fi network.

Method 1: Using adb reverse (recommended) 

You can use this method if your device is running Android 5.0 (Lollipop)
or newer, it has USB debugging enabled, and it is connected via USB to
your development machine.

Run the following in a command prompt:

    $ adb -s <device name> reverse tcp:8081 tcp:8081

 

To find the device name, run the following adb command:

    $ adb devices

 

You can now enable Live reloading from the Dev Menu . Your app will
reload whenever your JavaScript code has changed.

Method 2: Connect via Wi-Fi 

You can also connect to the development server over Wi-Fi. You'll first
need to install the app on your device using a USB cable, but once that
has been done you can debug wirelessly by following these instructions.
You'll need your development machine's current IP address before
proceeding.

You can find the IP address in System Settings (or System Preferences) →
Network .

1.  Make sure your laptop and your phone are on the same Wi-Fi network.
2.  Open your React Native app on your device.
3.  You'll see a red screen with an error . This is OK. The following
    steps will fix that.
4.  Open the in-app Dev Menu .
5.  Go to Dev Settings → Debug server host & port for device .
6.  Type in your machine's IP address and the port of the local dev
    server (e.g.  10.0.1.1:8081 ).
7.  Go back to the Dev Menu and select Reload JS .

You can now enable Live reloading from the Dev Menu . Your app will
reload whenever your JavaScript code has changed.

Building your app for production 

You have built a great app using React Native, and you are now itching
to release it in the Play Store. The process is the same as any other
native Android app, with some additional considerations to take into
account. Follow the guide for generating a signed APK to learn more.

1. Enable Debugging over USB 

Most Android devices can only install and run apps downloaded from
Google Play, by default. You will need to enable USB Debugging on your
device in order to install your app during development.

To enable USB debugging on your device, you will first need to enable
the "Developer options" menu by going to Settings → About phone →
Software information and then tapping the  Build number row at the
bottom seven times. You can then go back to Settings → Developer options
to enable "USB debugging".

2. Plug in your device via USB 

Let's now set up an Android device to run our React Native projects. Go
ahead and plug in your device via USB to your development machine.

Now check that your device is properly connecting to ADB, the Android
Debug Bridge, by running  adb devices .

    $ adb devices
    List of devices attached
    emulator-5554 offline   # Google emulator
    14ed2fcc device         # Physical device

 

Seeing  device in the right column means the device is connected. You
must have only one device connected at a time.

3. Run your app 

From the root of your project, run the following in your command prompt
to install and launch your app on the device:

-   npm
-   Yarn

    npm run android

 

    yarn android

 

  Hint: You can also use the  React Native CLI to generate and run a
   release build (e.g. from the root of your project:
   yarn android --mode release ).

Connecting to the development server

You can also iterate quickly on a device by connecting to the
development server running on your development machine. There are
several ways of accomplishing this, depending on whether you have access
to a USB cable or a Wi-Fi network.

Method 1: Using adb reverse (recommended) 

You can use this method if your device is running Android 5.0 (Lollipop)
or newer, it has USB debugging enabled, and it is connected via USB to
your development machine.

Run the following in a command prompt:

    $ adb -s <device name> reverse tcp:8081 tcp:8081

 

To find the device name, run the following adb command:

    $ adb devices

 

You can now enable Live reloading from the Dev Menu . Your app will
reload whenever your JavaScript code has changed.

Method 2: Connect via Wi-Fi 

You can also connect to the development server over Wi-Fi. You'll first
need to install the app on your device using a USB cable, but once that
has been done you can debug wirelessly by following these instructions.
You'll need your development machine's current IP address before
proceeding.

Open the command prompt and type  ipconfig to find your machine's IP
address ( more info ).

1.  Make sure your laptop and your phone are on the same Wi-Fi network.
2.  Open your React Native app on your device.
3.  You'll see a red screen with an error . This is OK. The following
    steps will fix that.
4.  Open the in-app Dev Menu .
5.  Go to Dev Settings → Debug server host & port for device .
6.  Type in your machine's IP address and the port of the local dev
    server (e.g.  10.0.1.1:8081 ).
7.  Go back to the Dev Menu and select Reload JS .

You can now enable Live reloading from the Dev Menu . Your app will
reload whenever your JavaScript code has changed.

Building your app for production 

You have built a great app using React Native, and you are now itching
to release it in the Play Store. The process is the same as any other
native Android app, with some additional considerations to take into
account. Follow the guide for generating a signed APK to learn more.

1. Enable Debugging over USB 

Most Android devices can only install and run apps downloaded from
Google Play, by default. You will need to enable USB Debugging on your
device in order to install your app during development.

To enable USB debugging on your device, you will first need to enable
the "Developer options" menu by going to Settings → About phone →
Software information and then tapping the  Build number row at the
bottom seven times. You can then go back to Settings → Developer options
to enable "USB debugging".

2. Plug in your device via USB 

Let's now set up an Android device to run our React Native projects. Go
ahead and plug in your device via USB to your development machine.

Next, check the manufacturer code by using  lsusb (on mac, you must
first install lsusb ).  lsusb should output something like this:

    $ lsusb
    Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
    Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
    Bus 001 Device 003: ID 22b8:2e76 Motorola PCS
    Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
    Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
    Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
    Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub

 

These lines represent the USB devices currently connected to your
machine.

You want the line that represents your phone. If you're in doubt, try
unplugging your phone and running the command again:

    $ lsusb
    Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
    Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
    Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
    Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
    Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
    Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub

 

You'll see that after removing the phone, the line which has the phone
model ("Motorola PCS" in this case) disappeared from the list. This is
the line that we care about.

 Bus 001 Device 003: ID 22b8:2e76 Motorola PCS

From the above line, you want to grab the first four digits from the
device ID:

 22b8:2e76

In this case, it's  22b8 . That's the identifier for Motorola.

You'll need to input this into your udev rules in order to get up and
running:

    echo 'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"' | sudo tee /etc/udev/rules.d/51-android-usb.rules

 

Make sure that you replace  22b8 with the identifier you get in the
above command.

Now check that your device is properly connecting to ADB, the Android
Debug Bridge, by running  adb devices .

    $ adb devices
    List of devices attached
    emulator-5554 offline   # Google emulator
    14ed2fcc device         # Physical device

 

Seeing  device in the right column means the device is connected. You
must have only one device connected at a time.

3. Run your app 

From the root of your project, type the following in your command prompt
to install and launch your app on the device:

-   npm
-   Yarn

    npm run android

 

    yarn android

 

  If you get a "bridge configuration isn't available" error, see Using
  adb reverse .

  Hint: You can also use the  React Native CLI to generate and run a
   release build (e.g. from the root of your project:
   yarn android --mode release ).

Connecting to the development server

You can also iterate quickly on a device by connecting to the
development server running on your development machine. There are
several ways of accomplishing this, depending on whether you have access
to a USB cable or a Wi-Fi network.

Method 1: Using adb reverse (recommended) 

You can use this method if your device is running Android 5.0 (Lollipop)
or newer, it has USB debugging enabled, and it is connected via USB to
your development machine.

Run the following in a command prompt:

    $ adb -s <device name> reverse tcp:8081 tcp:8081

 

To find the device name, run the following adb command:

    $ adb devices

 

You can now enable Live reloading from the Dev Menu . Your app will
reload whenever your JavaScript code has changed.

Method 2: Connect via Wi-Fi 

You can also connect to the development server over Wi-Fi. You'll first
need to install the app on your device using a USB cable, but once that
has been done you can debug wirelessly by following these instructions.
You'll need your development machine's current IP address before
proceeding.

Open a terminal and type  /sbin/ifconfig to find your machine's IP
address.

1.  Make sure your laptop and your phone are on the same Wi-Fi network.
2.  Open your React Native app on your device.
3.  You'll see a red screen with an error . This is OK. The following
    steps will fix that.
4.  Open the in-app Dev Menu .
5.  Go to Dev Settings → Debug server host & port for device .
6.  Type in your machine's IP address and the port of the local dev
    server (e.g.  10.0.1.1:8081 ).
7.  Go back to the Dev Menu and select Reload JS .

You can now enable Live reloading from the Dev Menu . Your app will
reload whenever your JavaScript code has changed.

Building your app for production 

You have built a great app using React Native, and you are now itching
to release it in the Play Store. The process is the same as any other
native Android app, with some additional considerations to take into
account. Follow the guide for generating a signed APK to learn more.

Running your app on iOS devices 

Development OS 

-   macOS
-   Windows
-   Linux

1. Plug in your device via USB 

Connect your iOS device to your Mac using a USB to Lightning cable.
Navigate to the  ios folder in your project, then open the  .xcodeproj
file, or if you are using CocoaPods open  .xcworkspace , within it using
Xcode.

If this is your first time running an app on your iOS device, you may
need to register your device for development. Open the Product menu from
Xcode's menubar, then go to Destination . Look for and select your
device from the list. Xcode will then register your device for
development.

2. Configure code signing 

Register for an Apple developer account if you don't have one yet.

Select your project in the Xcode Project Navigator, then select your
main target (it should share the same name as your project). Look for
the "General" tab. Go to "Signing" and make sure your Apple developer
account or team is selected under the Team dropdown. Do the same for the
tests target (it ends with Tests, and is below your main target).

Repeat this step for the Tests target in your project.



3. Build and Run your app 

If everything is set up correctly, your device will be listed as the
build target in the Xcode toolbar, and it will also appear in the
Devices pane ( Shift ⇧  + Cmd ⌘  + 2 ). You can now press the Build and
run button ( Cmd ⌘  + R ) or select Run from the Product menu. Your app
will launch on your device shortly.



  If you run into any issues, please take a look at Apple's Launching
  Your App on a Device docs.

Connecting to the development server

You can also iterate quickly on a device using the development server.
You only have to be on the same Wi-Fi network as your computer. Shake
your device to open the Dev Menu , then enable Live Reload. Your app
will reload whenever your JavaScript code has changed.



Troubleshooting 

  If you have any issues, ensure that your Mac and device are on the
  same network and can reach each other. Many open wireless networks
  with captive portals are configured to prevent devices from reaching
  other devices on the network. You may use your device's Personal
  Hotspot feature in this case. You may also share your internet
  (Wi-Fi/Ethernet) connection from your Mac to your device via USB and
  connect to the bundler through this tunnel for very high transfer
  speeds.

When trying to connect to the development server you might get a red
screen with an error saying:

  Connection to  http://localhost:8081/debugger-proxy?role=client timed
  out. Are you running node proxy? If you are running on the device,
  check if you have the right IP address in  RCTWebSocketExecutor.m .

To solve this issue check the following points.

1. Wi-Fi network. 

Make sure your laptop and your phone are on the same Wi-Fi network.

2. IP address 

Make sure that the build script detected the IP address of your machine
correctly (e.g.  10.0.1.123 ).



Open the Report navigator tab, select the last Build and search for  IP=
followed by an IP address. The IP address which gets embedded in the app
should match your machines IP address.

Building your app for production 

You have built a great app using React Native, and you are now itching
to release it in the App Store. The process is the same as any other
native iOS app, with some additional considerations to take into
account. Follow the guide for publishing to the Apple App Store to learn
more.

  A Mac is required in order to build your app for iOS devices.
  Alternatively, you can refer to our environment setup guide to learn
  how to build your app using Expo CLI, which will allow you to run your
  app using the Expo client app.

  A Mac is required in order to build your app for iOS devices.
  Alternatively, you can refer to our environment setup guide to learn
  how to build your app using Expo CLI, which will allow you to run your
  app using the Expo client app.

# Running On Simulator #
 ____                    _                ___        
|  _ \ _   _ _ __  _ __ (_)_ __   __ _   / _ \ _ __  
| |_) | | | | '_ \| '_ \| | '_ \ / _` | | | | | '_ \ 
|  _ <| |_| | | | | | | | | | | | (_| | | |_| | | | |
|_| \_\\__,_|_| |_|_| |_|_|_| |_|\__, |  \___/|_| |_|
                                 |___/               
 ____  _                 _       _             
/ ___|(_)_ __ ___  _   _| | __ _| |_ ___  _ __ 
\___ \| | '_ ` _ \| | | | |/ _` | __/ _ \| '__|
 ___) | | | | | | | |_| | | (_| | || (_) | |   
|____/|_|_| |_| |_|\__,_|_|\__,_|\__\___/|_|   
                                               
-   Starting the simulator
-   Specifying a device
    -   Specifying a version of device
-   Specifying an UDID
Running On Simulator

Starting the simulator 

Once you have your React Native project initialized, you can run the
following command inside the newly created project directory.

-   npm
-   Yarn

    npm run ios

 

    yarn ios

 

If everything is set up correctly, you should see your new app running
in the iOS Simulator shortly.

Specifying a device 

You can specify the device the simulator should run with the
 --simulator flag, followed by the device name as a string. The default
is  "iPhone 14" . If you wish to run your app on an iPhone SE (3rd
generation), run the following command:

-   npm
-   Yarn

    npm run ios -- --simulator="iPhone SE (3rd generation)"

 

    yarn ios --simulator "iPhone SE (3rd generation)"

 

The device names correspond to the list of devices available in Xcode.
You can check your available devices by running
 xcrun simctl list devices from the console.

Specifying a version of device 

If you have multiple iOS versions installed, you also need to specify
it's appropiate version. E.g. To run your app on an iPhone 14 Pro (16.0)
run the following command:

-   npm
-   Yarn

    npm run ios -- --simulator="iPhone 14 Pro (16.0)"

 

    yarn ios --simulator "iPhone 14 Pro (16.0)"

 

Specifying an UDID 

You can specify the device UDID returned from  xcrun simctl list devices
command. E.g. To run your app with UDID
 AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA run the following command:

-   npm
-   Yarn

    npm run ios -- --udid="AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA"

 

    yarn ios --udid "AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA"

 

# SafeAreaView #
 ____         __         _                 __     ___               
/ ___|  __ _ / _| ___   / \   _ __ ___  __ \ \   / (_) _____      __
\___ \ / _` | |_ / _ \ / _ \ | '__/ _ \/ _` \ \ / /| |/ _ \ \ /\ / /
 ___) | (_| |  _|  __// ___ \| | |  __/ (_| |\ V / | |  __/\ V  V / 
|____/ \__,_|_|  \___/_/   \_\_|  \___|\__,_| \_/  |_|\___| \_/\_/  
                                                                    
-   Example
-   Props
    -   View Props
SafeAreaView

The purpose of  SafeAreaView is to render content within the safe area
boundaries of a device. It is currently only applicable to iOS devices
with iOS version 11 or later.

 SafeAreaView renders nested content and automatically applies padding
to reflect the portion of the view that is not covered by navigation
bars, tab bars, toolbars, and other ancestor views. Moreover, and most
importantly, Safe Area's paddings reflect the physical limitation of the
screen, such as rounded corners or camera notches (i.e. the sensor
housing area on iPhone 13).

Example 

To use, wrap your top level view with a  SafeAreaView with a  flex: 1
style applied to it. You may also want to use a background color that
matches your application's design.

------------------------------------------------------------------------

Reference

Props 

View Props 

Inherits View Props .

  As padding is used to implement the behavior of the component, padding
  rules in styles applied to a  SafeAreaView will be ignored and can
  cause different results depending on the platform. See #22211 for
  details.

# ScrollView #
 ____                 _ ___     ___               
/ ___|  ___ _ __ ___ | | \ \   / (_) _____      __
\___ \ / __| '__/ _ \| | |\ \ / /| |/ _ \ \ /\ / /
 ___) | (__| | | (_) | | | \ V / | |  __/\ V  V / 
|____/ \___|_|  \___/|_|_|  \_/  |_|\___| \_/\_/  
                                                  
-   Example
-   Props
    -   View Props
    -    StickyHeaderComponent
    -    alwaysBounceHorizontal
        iOS
    -    alwaysBounceVertical
        iOS
    -    automaticallyAdjustContentInsets
        iOS
    -    automaticallyAdjustKeyboardInsets
        iOS
    -    automaticallyAdjustsScrollIndicatorInsets
        iOS
    -    bounces
        iOS
    -    bouncesZoom
        iOS
    -    canCancelContentTouches
        iOS
    -    centerContent
        iOS
    -    contentContainerStyle
    -    contentInset
        iOS
    -    contentInsetAdjustmentBehavior
        iOS
    -    contentOffset
    -    decelerationRate
    -    directionalLockEnabled
        iOS
    -    disableIntervalMomentum
    -    disableScrollViewPanResponder
    -    endFillColor
        Android
    -    fadingEdgeLength
        Android
    -    horizontal
    -    indicatorStyle
        iOS
    -    invertStickyHeaders
    -    keyboardDismissMode
    -    keyboardShouldPersistTaps
    -    maintainVisibleContentPosition
    -    maximumZoomScale
        iOS
    -    minimumZoomScale
        iOS
    -    nestedScrollEnabled
        Android
    -    onContentSizeChange
    -    onMomentumScrollBegin
    -    onMomentumScrollEnd
    -    onScroll
    -    onScrollBeginDrag
    -    onScrollEndDrag
    -    onScrollToTop
        iOS
    -    overScrollMode
        Android
    -    pagingEnabled
    -    persistentScrollbar
        Android
    -    pinchGestureEnabled
        iOS
    -    refreshControl
    -    removeClippedSubviews
    -    scrollEnabled
    -    scrollEventThrottle
    -    scrollIndicatorInsets
        iOS
    -    scrollPerfTag
        Android
    -    scrollToOverflowEnabled
        iOS
    -    scrollsToTop
        iOS
    -    showsHorizontalScrollIndicator
    -    showsVerticalScrollIndicator
    -    snapToAlignment
        iOS
    -    snapToEnd
    -    snapToInterval
    -    snapToOffsets
    -    snapToStart
    -    stickyHeaderHiddenOnScroll
    -    stickyHeaderIndices
    -    zoomScale
        iOS
-   Methods
    -    flashScrollIndicators()
    -    scrollTo()
    -    scrollToEnd()
ScrollView

Component that wraps platform ScrollView while providing integration
with touch locking "responder" system.

Keep in mind that ScrollViews must have a bounded height in order to
work, since they contain unbounded-height children into a bounded
container (via a scroll interaction). In order to bound the height of a
ScrollView, either set the height of the view directly (discouraged) or
make sure all parent views have bounded height. Forgetting to transfer
 {flex: 1} down the view stack can lead to errors here, which the
element inspector makes quick to debug.

Doesn't yet support other contained responders from blocking this scroll
view from becoming the responder.

 <ScrollView> vs  <FlatList> - which one to use?

 ScrollView renders all its react child components at once, but this has
a performance downside.

Imagine you have a very long list of items you want to display, maybe
several screens worth of content. Creating JS components and native
views for everything all at once, much of which may not even be shown,
will contribute to slow rendering and increased memory usage.

This is where  FlatList comes into play.  FlatList renders items lazily,
when they are about to appear, and removes items that scroll way off
screen to save memory and processing time.

 FlatList is also handy if you want to render separators between your
items, multiple columns, infinite scroll loading, or any number of other
features it supports out of the box.

Example 

------------------------------------------------------------------------

Reference

Props 

View Props 

Inherits View Props .

------------------------------------------------------------------------

 StickyHeaderComponent 

A React Component that will be used to render sticky headers, should be
used together with  stickyHeaderIndices . You may need to set this
component if your sticky header uses custom transforms, for example,
when you want your list to have an animated and hidable header. If a
component has not been provided, the default  ScrollViewStickyHeader
component will be used.

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 alwaysBounceHorizontal

iOS



When true, the scroll view bounces horizontally when it reaches the end
even if the content is smaller than the scroll view itself.

+-----------------------------------+-----------------------------------+
| Type                              | Default                           |
+===================================+===================================+
| bool                              |  true when  horizontal={true}     |
|                                   |                                   |
|                                   | -------------------------------   |
|                                   |                                   |
|                                   |  false otherwise                  |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 alwaysBounceVertical

iOS



When true, the scroll view bounces vertically when it reaches the end
even if the content is smaller than the scroll view itself.

+-----------------------------------+-----------------------------------+
| Type                              | Default                           |
+===================================+===================================+
| bool                              |  false when  vertical={true}      |
|                                   |                                   |
|                                   | -------------------------------   |
|                                   |                                   |
|                                   |  true otherwise                   |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 automaticallyAdjustContentInsets

iOS



Controls whether iOS should automatically adjust the content inset for
scroll views that are placed behind a navigation bar or tab bar/toolbar.

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 automaticallyAdjustKeyboardInsets

iOS



Controls whether the ScrollView should automatically adjust its
 contentInset and  scrollViewInsets when the Keyboard changes its size.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 automaticallyAdjustsScrollIndicatorInsets

iOS



Controls whether iOS should automatically adjust the scroll indicator
insets. See Apple's documentation on the property .

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 bounces

iOS



When true, the scroll view bounces when it reaches the end of the
content if the content is larger than the scroll view along the axis of
the scroll direction. When  false , it disables all bouncing even if the
 alwaysBounce* props are  true .

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 bouncesZoom

iOS



When  true , gestures can drive zoom past min/max and the zoom will
animate to the min/max value at gesture end, otherwise the zoom will not
exceed the limits.

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 canCancelContentTouches

iOS



When  false , once tracking starts, won't try to drag if the touch
moves.

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 centerContent

iOS



When  true , the scroll view automatically centers the content when the
content is smaller than the scroll view bounds; when the content is
larger than the scroll view, this property has no effect.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 contentContainerStyle 

These styles will be applied to the scroll view content container which
wraps all of the child views. Example:

    return (
      <ScrollView contentContainerStyle={styles.contentContainer}>
      </ScrollView>
    );
    ...
    const styles = StyleSheet.create({
      contentContainer: {
        paddingVertical: 20
      }
    });

 

  Type
  ------------
  View Style

------------------------------------------------------------------------

 contentInset

iOS



The amount by which the scroll view content is inset from the edges of
the scroll view.

  Type                                                                  Default
  --------------------------------------------------------------------- -----------------------------------------
  object:  {top: number, left: number, bottom: number, right: number}    {top: 0, left: 0, bottom: 0, right: 0}

------------------------------------------------------------------------

 contentInsetAdjustmentBehavior

iOS



This property specifies how the safe area insets are used to modify the
content area of the scroll view. Available on iOS 11 and later.

  Type                                                              Default
  ----------------------------------------------------------------- ----------
  enum(  'automatic' ,  'scrollableAxes' ,  'never' ,  'always' )    'never'

------------------------------------------------------------------------

 contentOffset 

Used to manually set the starting scroll offset.

  Type    Default
  ------- ---------------
  Point    {x: 0, y: 0}

------------------------------------------------------------------------

 decelerationRate 

A floating-point number that determines how quickly the scroll view
decelerates after the user lifts their finger. You may also use string
shortcuts  "normal" and  "fast" which match the underlying iOS settings
for  UIScrollViewDecelerationRateNormal and
 UIScrollViewDecelerationRateFast respectively.

-    'normal' 0.998 on iOS, 0.985 on Android.
-    'fast' , 0.99 on iOS, 0.9 on Android.

  Type                                  Default
  ------------------------------------- -----------
  enum(  'fast' ,  'normal' ), number    'normal'

------------------------------------------------------------------------

 directionalLockEnabled

iOS



When true, the ScrollView will try to lock to only vertical or
horizontal scrolling while dragging.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 disableIntervalMomentum 

When true, the scroll view stops on the next index (in relation to
scroll position at release) regardless of how fast the gesture is. This
can be used for pagination when the page is less than the width of the
horizontal ScrollView or the height of the vertical ScrollView.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 disableScrollViewPanResponder 

When true, the default JS pan responder on the ScrollView is disabled,
and full control over touches inside the ScrollView is left to its child
components. This is particularly useful if  snapToInterval is enabled,
since it does not follow typical touch patterns. Do not use this on
regular ScrollView use cases without  snapToInterval as it may cause
unexpected touches to occur while scrolling.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 endFillColor

Android



Sometimes a scrollview takes up more space than its content fills. When
this is the case, this prop will fill the rest of the scrollview with a
color to avoid setting a background and creating unnecessary overdraw.
This is an advanced optimization that is not needed in the general case.

  Type
  -------
  color

------------------------------------------------------------------------

 fadingEdgeLength

Android



Fades out the edges of the the scroll content.

If the value is greater than  0 , the fading edges will be set
accordingly to the current scroll direction and position, indicating if
there is more content to show.

  Type     Default
  -------- ---------
  number    0

------------------------------------------------------------------------

 horizontal 

When  true , the scroll view's children are arranged horizontally in a
row instead of vertically in a column.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 indicatorStyle

iOS



The style of the scroll indicators.

-    'default' same as  black .
-    'black' , scroll indicator is  black . This style is good against a
    light background.
-    'white' , scroll indicator is  white . This style is good against a
    dark background.

  Type                                       Default
  ------------------------------------------ ------------
  enum(  'default' ,  'black' ,  'white' )    'default'

------------------------------------------------------------------------

 invertStickyHeaders 

If sticky headers should stick at the bottom instead of the top of the
ScrollView. This is usually used with inverted ScrollViews.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 keyboardDismissMode 

Determines whether the keyboard gets dismissed in response to a drag.

-    'none' , drags do not dismiss the keyboard.
-    'on-drag' , the keyboard is dismissed when a drag begins.

iOS Only

-    'interactive' , the keyboard is dismissed interactively with the
    drag and moves in synchrony with the touch, dragging upwards cancels
    the dismissal. On Android this is not supported and it will have the
    same behavior as  'none' .

+-----------------------------------+-----------------------------------+
| Type                              | Default                           |
+===================================+===================================+
| enum(  'none' ,  'on-drag' )      |  'none'                           |
|                                   |                                   |
| Android                           |                                   |
|                                   |                                   |
| -------------------------------   |                                   |
|                                   |                                   |
| enum(  'none' ,  'on-drag' ,      |                                   |
|  'interactive' )                  |                                   |
|                                   |                                   |
| iOS                               |                                   |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

 keyboardShouldPersistTaps 

Determines when the keyboard should stay visible after a tap.

-    'never' tapping outside of the focused text input when the keyboard
    is up dismisses the keyboard. When this happens, children won't
    receive the tap.
-    'always' , the keyboard will not dismiss automatically, and the
    scroll view will not catch taps, but children of the scroll view can
    catch taps.
-    'handled' , the keyboard will not dismiss automatically when the
    tap was handled by children of the scroll view (or captured by an
    ancestor).
-    false , deprecated , use  'never' instead
-    true , deprecated , use  'always' instead

  Type                                                         Default
  ------------------------------------------------------------ ----------
  enum(  'always' ,  'never' ,  'handled' ,  false ,  true )    'never'

------------------------------------------------------------------------

 maintainVisibleContentPosition 

When set, the scroll view will adjust the scroll position so that the
first child that is currently visible and at or beyond
 minIndexForVisible will not change position. This is useful for lists
that are loading content in both directions, e.g. a chat thread, where
new messages coming in might otherwise cause the scroll position to
jump. A value of 0 is common, but other values such as 1 can be used to
skip loading spinners or other content that should not maintain
position.

The optional  autoscrollToTopThreshold can be used to make the content
automatically scroll to the top after making the adjustment if the user
was within the threshold of the top before the adjustment was made. This
is also useful for chat-like applications where you want to see new
messages scroll into place, but not if the user has scrolled up a ways
and it would be disruptive to scroll a bunch.

Caveat 1: Reordering elements in the scrollview with this enabled will
probably cause jumpiness and jank. It can be fixed, but there are
currently no plans to do so. For now, don't re-order the content of any
ScrollViews or Lists that use this feature.

Caveat 2: This uses  contentOffset and  frame.origin in native code to
compute visibility. Occlusion, transforms, and other complexity won't be
taken into account as to whether content is "visible" or not.

  Type
  -------------------------------------------------------------------------
  object:  {minIndexForVisible: number, autoscrollToTopThreshold: number}

------------------------------------------------------------------------

 maximumZoomScale

iOS



The maximum allowed zoom scale.

  Type     Default
  -------- ---------
  number    1.0

------------------------------------------------------------------------

 minimumZoomScale

iOS



The minimum allowed zoom scale.

  Type     Default
  -------- ---------
  number    1.0

------------------------------------------------------------------------

 nestedScrollEnabled

Android



Enables nested scrolling for Android API level 21+.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 onContentSizeChange 

Called when scrollable content view of the ScrollView changes.

The handler function will recieve two parameters: the content width and
content height  (contentWidth, contentHeight) .

It's implemented using onLayout handler attached to the content
container which this ScrollView renders.

  Type
  ----------
  function

------------------------------------------------------------------------

 onMomentumScrollBegin 

Called when the momentum scroll starts (scroll which occurs as the
ScrollView starts gliding).

  Type
  ----------
  function

------------------------------------------------------------------------

 onMomentumScrollEnd 

Called when the momentum scroll ends (scroll which occurs as the
ScrollView glides to a stop).

  Type
  ----------
  function

------------------------------------------------------------------------

 onScroll 

Fires at most once per frame during scrolling. The frequency of the
events can be controlled using the  scrollEventThrottle prop. The event
has the following shape (all values are numbers):

    {
      nativeEvent: {
        contentInset: {bottom, left, right, top},
        contentOffset: {x, y},
        contentSize: {height, width},
        layoutMeasurement: {height, width},
        zoomScale
      }
    }

 

  Type
  ----------
  function

------------------------------------------------------------------------

 onScrollBeginDrag 

Called when the user begins to drag the scroll view.

  Type
  ----------
  function

------------------------------------------------------------------------

 onScrollEndDrag 

Called when the user stops dragging the scroll view and it either stops
or begins to glide.

  Type
  ----------
  function

------------------------------------------------------------------------

 onScrollToTop

iOS



Fires when the scroll view scrolls to top after the status bar has been
tapped.

  Type
  ----------
  function

------------------------------------------------------------------------

 overScrollMode

Android



Used to override default value of overScroll mode.

Possible values:

-    'auto' - Allow a user to over-scroll this view only if the content
    is large enough to meaningfully scroll.
-    'always' - Always allow a user to over-scroll this view.
-    'never' - Never allow a user to over-scroll this view.

  Type                                     Default
  ---------------------------------------- ---------
  enum(  'auto' ,  'always' ,  'never' )    'auto'

------------------------------------------------------------------------

 pagingEnabled 

When true, the scroll view stops on multiples of the scroll view's size
when scrolling. This can be used for horizontal pagination.

  Note: Vertical pagination is not supported on Android.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 persistentScrollbar

Android



Causes the scrollbars not to turn transparent when they are not in use.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 pinchGestureEnabled

iOS



When true, ScrollView allows use of pinch gestures to zoom in and out.

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 refreshControl 

A RefreshControl component, used to provide pull-to-refresh
functionality for the ScrollView. Only works for vertical ScrollViews (
 horizontal prop must be  false ).

See RefreshControl .

  Type
  ---------
  element

------------------------------------------------------------------------

 removeClippedSubviews 

Experimental: When  true , offscreen child views (whose  overflow value
is  hidden ) are removed from their native backing superview when
offscreen. This can improve scrolling performance on long lists.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 scrollEnabled 

When false, the view cannot be scrolled via touch interaction.

Note that the view can always be scrolled by calling  scrollTo .

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 scrollEventThrottle 

This controls how often the scroll event will be fired while scrolling
(as a time interval in ms). A lower number yields better accuracy for
code that is tracking the scroll position, but can lead to scroll
performance problems due to the volume of information being sent over
the bridge. You will not notice a difference between values set between
1-16 as the JS run loop is synced to the screen refresh rate. If you do
not need precise scroll position tracking, set this value higher to
limit the information being sent across the bridge. The default value is
 0 , which results in the scroll event being sent only once each time
the view is scrolled.

  Type     Default
  -------- ---------
  number    0

------------------------------------------------------------------------

 scrollIndicatorInsets

iOS



The amount by which the scroll view indicators are inset from the edges
of the scroll view. This should normally be set to the same value as the
 contentInset .

  Type                                                                  Default
  --------------------------------------------------------------------- -----------------------------------------
  object:  {top: number, left: number, bottom: number, right: number}    {top: 0, left: 0, bottom: 0, right: 0}

------------------------------------------------------------------------

 scrollPerfTag

Android



Tag used to log scroll performance on this scroll view. Will force
momentum events to be turned on (see sendMomentumEvents). This doesn't
do anything out of the box and you need to implement a custom native
FpsListener for it to be useful.

  Type
  --------
  string

------------------------------------------------------------------------

 scrollToOverflowEnabled

iOS



When  true , the scroll view can be programmatically scrolled beyond its
content size.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 scrollsToTop

iOS



When  true , the scroll view scrolls to top when the status bar is
tapped.

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 showsHorizontalScrollIndicator 

When  true , shows a horizontal scroll indicator.

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 showsVerticalScrollIndicator 

When  true , shows a vertical scroll indicator.

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 snapToAlignment

iOS



When  snapToInterval is set,  snapToAlignment will define the
relationship of the snapping to the scroll view.

Possible values:

-    'start' will align the snap at the left (horizontal) or top
    (vertical).
-    'center' will align the snap in the center.
-    'end' will align the snap at the right (horizontal) or bottom
    (vertical).

  Type                                    Default
  --------------------------------------- ----------
  enum(  'start' ,  'center' ,  'end' )    'start'

------------------------------------------------------------------------

 snapToEnd 

Use in conjunction with  snapToOffsets . By default, the end of the list
counts as a snap offset. Set  snapToEnd to false to disable this
behavior and allow the list to scroll freely between its end and the
last  snapToOffsets offset.

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 snapToInterval 

When set, causes the scroll view to stop at multiples of the value of
 snapToInterval . This can be used for paginating through children that
have lengths smaller than the scroll view. Typically used in combination
with  snapToAlignment and  decelerationRate="fast" . Overrides less
configurable  pagingEnabled prop.

  Type
  --------
  number

------------------------------------------------------------------------

 snapToOffsets 

When set, causes the scroll view to stop at the defined offsets. This
can be used for paginating through variously sized children that have
lengths smaller than the scroll view. Typically used in combination with
 decelerationRate="fast" . Overrides less configurable  pagingEnabled
and  snapToInterval props.

  Type
  -----------------
  array of number

------------------------------------------------------------------------

 snapToStart 

Use in conjunction with  snapToOffsets . By default, the beginning of
the list counts as a snap offset. Set  snapToStart to  false to disable
this behavior and allow the list to scroll freely between its start and
the first  snapToOffsets offset.

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 stickyHeaderHiddenOnScroll 

When set to  true , sticky header will be hidden when scrolling down the
list, and it will dock at the top of the list when scrolling up.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 stickyHeaderIndices 

An array of child indices determining which children get docked to the
top of the screen when scrolling. For example, passing
 stickyHeaderIndices={[0]} will cause the first child to be fixed to the
top of the scroll view. You can also use like [x,y,z] to make multiple
items sticky when they are at the top. This property is not supported in
conjunction with  horizontal={true} .

  Type
  -----------------
  array of number

------------------------------------------------------------------------

 zoomScale

iOS



The current scale of the scroll view content.

  Type     Default
  -------- ---------
  number    1.0

------------------------------------------------------------------------

Methods 

 flashScrollIndicators() 

    flashScrollIndicators();

 

Displays the scroll indicators momentarily.

------------------------------------------------------------------------

 scrollTo() 

    scrollTo(
      options?: {x?: number, y?: number, animated?: boolean} | number,
      deprecatedX?: number,
      deprecatedAnimated?: boolean,
    );

 

Scrolls to a given x, y offset, either immediately, with a smooth
animation.

Example:

 scrollTo({x: 0, y: 0, animated: true})

  Note: The weird function signature is due to the fact that, for
  historical reasons, the function also accepts separate arguments as an
  alternative to the options object. This is deprecated due to ambiguity
  (y before x), and SHOULD NOT BE USED.

------------------------------------------------------------------------

 scrollToEnd() 

    scrollToEnd(options?: {animated?: boolean});

 

If this is a vertical ScrollView scrolls to the bottom. If this is a
horizontal ScrollView scrolls to the right.

Use  scrollToEnd({animated: true}) for smooth animated scrolling,
 scrollToEnd({animated: false}) for immediate scrolling. If no options
are passed,  animated defaults to  true .

# SectionList #
 ____            _   _             _     _     _   
/ ___|  ___  ___| |_(_) ___  _ __ | |   (_)___| |_ 
\___ \ / _ \/ __| __| |/ _ \| '_ \| |   | / __| __|
 ___) |  __/ (__| |_| | (_) | | | | |___| \__ \ |_ 
|____/ \___|\___|\__|_|\___/|_| |_|_____|_|___/\__|
                                                   
-   Example
-   Props
    -   VirtualizedList Props
    -   
        Required

         renderItem
    -   
        Required

         sections
    -    extraData
    -    initialNumToRender
    -    inverted
    -    ItemSeparatorComponent
    -    keyExtractor
    -    ListEmptyComponent
    -    ListFooterComponent
    -    ListHeaderComponent
    -    onRefresh
    -    onViewableItemsChanged
    -    refreshing
    -    removeClippedSubviews
    -    renderSectionFooter
    -    renderSectionHeader
    -    SectionSeparatorComponent
    -    stickySectionHeadersEnabled
-   Methods
    -    flashScrollIndicators()
        iOS
    -    recordInteraction()
    -    scrollToLocation()
-   Type Definitions
    -   Section
SectionList

A performant interface for rendering sectioned lists, supporting the
most handy features:

-   Fully cross-platform.
-   Configurable viewability callbacks.
-   List header support.
-   List footer support.
-   Item separator support.
-   Section header support.
-   Section separator support.
-   Heterogeneous data and item rendering support.
-   Pull to Refresh.
-   Scroll loading.

If you don't need section support and want a simpler interface, use
 <FlatList> .

Example 

This is a convenience wrapper around  <VirtualizedList> , and thus
inherits its props (as well as those of  <ScrollView> ) that aren't
explicitly listed here, along with the following caveats:

-   Internal state is not preserved when content scrolls out of the
    render window. Make sure all your data is captured in the item data
    or external stores like Flux, Redux, or Relay.
-   This is a  PureComponent which means that it will not re-render if
     props remain shallow-equal. Make sure that everything your
     renderItem function depends on is passed as a prop (e.g.  extraData
    ) that is not  === after updates, otherwise your UI may not update
    on changes. This includes the  data prop and parent component state.
-   In order to constrain memory and enable smooth scrolling, content is
    rendered asynchronously offscreen. This means it's possible to
    scroll faster than the fill rate and momentarily see blank content.
    This is a tradeoff that can be adjusted to suit the needs of each
    application, and we are working on improving it behind the scenes.
-   By default, the list looks for a  key prop on each item and uses
    that for the React key. Alternatively, you can provide a custom
     keyExtractor prop.

------------------------------------------------------------------------

Reference

Props 

VirtualizedList Props 

Inherits VirtualizedList Props .

------------------------------------------------------------------------

Required

 renderItem 

Default renderer for every item in every section. Can be over-ridden on
a per-section basis. Should return a React element.

  Type
  ----------
  function

The render function will be passed an object with the following keys:

-   'item' (object) - the item object as specified in this section's
     data key
-   'index' (number) - Item's index within the section.
-   'section' (object) - The full section object as specified in
     sections .
-   'separators' (object) - An object with the following keys:
    -   'highlight' (function) -  () => void
    -   'unhighlight' (function) -  () => void
    -   'updateProps' (function) -  (select, newProps) => void
        -   'select' (enum) - possible values are 'leading', 'trailing'
        -   'newProps' (object)

------------------------------------------------------------------------

Required

 sections 

The actual data to render, akin to the  data prop in  FlatList .

  Type
  --------------------
  array of Section s

------------------------------------------------------------------------

 extraData 

A marker property for telling the list to re-render (since it implements
 PureComponent ). If any of your  renderItem , Header, Footer, etc.
functions depend on anything outside of the  data prop, stick it here
and treat it immutably.

  Type
  ------
  any

------------------------------------------------------------------------

 initialNumToRender 

How many items to render in the initial batch. This should be enough to
fill the screen but not much more. Note these items will never be
unmounted as part of the windowed rendering in order to improve
perceived performance of scroll-to-top actions.

  Type     Default
  -------- ---------
  number    10

------------------------------------------------------------------------

 inverted 

Reverses the direction of scroll. Uses scale transforms of -1.

  Type      Default
  --------- ---------
  boolean    false

------------------------------------------------------------------------

 ItemSeparatorComponent 

Rendered in between each item, but not at the top or bottom. By default,
 highlighted ,  section , and  [leading/trailing][Item/Section] props
are provided.  renderItem provides  separators.highlight /  unhighlight
which will update the  highlighted prop, but you can also add custom
props with  separators.updateProps . Can be a React Component (e.g.
 SomeComponent ), or a React element (e.g.  <SomeComponent /> ).

  Type
  ------------------------------
  component, function, element

------------------------------------------------------------------------

 keyExtractor 

Used to extract a unique key for a given item at the specified index.
Key is used for caching and as the React key to track item re-ordering.
The default extractor checks  item.key , then falls back to using the
index, like React does. Note that this sets keys for each item, but each
overall section still needs its own key.

  Type
  -----------------------------------------
  (item: object, index: number) => string

------------------------------------------------------------------------

 ListEmptyComponent 

Rendered when the list is empty. Can be a React Component (e.g.
 SomeComponent ), or a React element (e.g.  <SomeComponent /> ).

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 ListFooterComponent 

Rendered at the very end of the list. Can be a React Component (e.g.
 SomeComponent ), or a React element (e.g.  <SomeComponent /> ).

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 ListHeaderComponent 

Rendered at the very beginning of the list. Can be a React Component
(e.g.  SomeComponent ), or a React element (e.g.  <SomeComponent /> ).

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 onRefresh 

If provided, a standard RefreshControl will be added for "Pull to
Refresh" functionality. Make sure to also set the  refreshing prop
correctly. To offset the RefreshControl from the top (e.g. by 100 pts),
use  progressViewOffset={100} .

  Type
  ----------
  function

------------------------------------------------------------------------

 onViewableItemsChanged 

Called when the viewability of rows changes, as defined by the
 viewabilityConfig prop.

  Type
  -------------------------------------------------------------------------------
   (callback: {changed:  ViewToken  , viewableItems:  ViewToken  }) => void

------------------------------------------------------------------------

 refreshing 

Set this true while waiting for new data from a refresh.

  Type      Default
  --------- ---------
  boolean    false

------------------------------------------------------------------------

 removeClippedSubviews 

  Note: may have bugs (missing content) in some circumstances - use at
  your own risk.

This may improve scroll performance for large lists.

  Type      Default
  --------- ---------
  boolean    false

------------------------------------------------------------------------

 renderSectionFooter 

Rendered at the bottom of each section.

  Type
  ---------------------------------------------------
   (info: {section:  Section  }) => element ｜ null

------------------------------------------------------------------------

 renderSectionHeader 

Rendered at the top of each section. These stick to the top of the
 ScrollView by default on iOS. See  stickySectionHeadersEnabled .

  Type
  ---------------------------------------------------
   (info: {section:  Section  }) => element ｜ null

------------------------------------------------------------------------

 SectionSeparatorComponent 

Rendered at the top and bottom of each section (note this is different
from  ItemSeparatorComponent which is only rendered between items).
These are intended to separate sections from the headers above and below
and typically have the same highlight response as
 ItemSeparatorComponent . Also receives  highlighted ,
 [leading/trailing][Item/Section] , and any custom props from
 separators.updateProps .

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 stickySectionHeadersEnabled 

Makes section headers stick to the top of the screen until the next one
pushes it off. Only enabled by default on iOS because that is the
platform standard there.

+-----------------------------------+-----------------------------------+
| Type                              | Default                           |
+===================================+===================================+
| boolean                           |  false                            |
|                                   |                                   |
|                                   | Android                           |
|                                   |                                   |
|                                   | -------------------------------   |
|                                   |                                   |
|                                   |  true                             |
|                                   |                                   |
|                                   | iOS                               |
+-----------------------------------+-----------------------------------+

Methods 

 flashScrollIndicators()

iOS



    flashScrollIndicators();

 

Displays the scroll indicators momentarily.

------------------------------------------------------------------------

 recordInteraction() 

    recordInteraction();

 

Tells the list an interaction has occurred, which should trigger
viewability calculations, e.g. if  waitForInteractions is true and the
user has not scrolled. This is typically called by taps on items or by
navigation actions.

------------------------------------------------------------------------

 scrollToLocation() 

    scrollToLocation(params: SectionListScrollParams);

 

Scrolls to the item at the specified  sectionIndex and  itemIndex
(within the section) positioned in the viewable area such that
 viewPosition 0 places it at the top (and may be covered by a sticky
header), 1 at the bottom, and 0.5 centered in the middle.

  Note: Cannot scroll to locations outside the render window without
  specifying the  getItemLayout or  onScrollToIndexFailed prop.

Parameters:

+-----------------------------------+-----------------------------------+
| Name                              | Type                              |
+===================================+===================================+
| params                            | object                            |
|                                   |                                   |
| Required                          |                                   |
+-----------------------------------+-----------------------------------+

Valid  params keys are:

-   'animated' (boolean) - Whether the list should do an animation while
    scrolling. Defaults to  true .
-   'itemIndex' (number) - Index within section for the item to scroll
    to. Required.
-   'sectionIndex' (number) - Index for section that contains the item
    to scroll to. Required.
-   'viewOffset' (number) - A fixed number of pixels to offset the final
    target position, e.g. to compensate for sticky headers.
-   'viewPosition' (number) - A value of  0 places the item specified by
    index at the top,  1 at the bottom, and  0.5 centered in the middle.

Type Definitions 

Section 

An object that identifies the data to be rendered for a given section.

  Type
  ------
  any

Properties:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| data                  | array                 | The data for          |
|                       |                       | rendering items in    |
| Required              |                       | this section. Array   |
|                       |                       | of objects, much like |
|                       |                       |  FlatList 's data     |
|                       |                       | prop .                |
+-----------------------+-----------------------+-----------------------+
| key                   | string                | Optional key to keep  |
|                       |                       | track of section      |
|                       |                       | re-ordering. If you   |
|                       |                       | don't plan on         |
|                       |                       | re-ordering sections, |
|                       |                       | the array index will  |
|                       |                       | be used by default.   |
+-----------------------+-----------------------+-----------------------+
| renderItem            | function              | Optionally define an  |
|                       |                       | arbitrary item        |
|                       |                       | renderer for this     |
|                       |                       | section, overriding   |
|                       |                       | the default           |
|                       |                       |  renderItem for the   |
|                       |                       | list.                 |
+-----------------------+-----------------------+-----------------------+
| I                     | component, element    | Optionally define an  |
| temSeparatorComponent |                       | arbitrary item        |
|                       |                       | separator for this    |
|                       |                       | section, overriding   |
|                       |                       | the default           |
|                       |                       |  I                    |
|                       |                       | temSeparatorComponent |
|                       |                       | for the list.         |
+-----------------------+-----------------------+-----------------------+
| keyExtractor          | function              | Optionally define an  |
|                       |                       | arbitrary key         |
|                       |                       | extractor for this    |
|                       |                       | section, overriding   |
|                       |                       | the default           |
|                       |                       |  keyExtractor .       |
+-----------------------+-----------------------+-----------------------+

# Security #
 ____                       _ _         
/ ___|  ___  ___ _   _ _ __(_) |_ _   _ 
\___ \ / _ \/ __| | | | '__| | __| | | |
 ___) |  __/ (__| |_| | |  | | |_| |_| |
|____/ \___|\___|\__,_|_|  |_|\__|\__, |
                                  |___/ 
-   Storing Sensitive Info
    -   Async Storage
    -   Secure Storage
-   Authentication and Deep Linking
    -   OAuth2 and Redirects
-   Network Security
    -   SSL Pinning
-   Summary
Security

Security is often overlooked when building apps. It is true that it is
impossible to build software that is completely impenetrable—we’ve yet
to invent a completely impenetrable lock (bank vaults do, after all,
still get broken into). However, the probability of falling victim to a
malicious attack or being exposed for a security vulnerability is
inversely proportional to the effort you’re willing to put in to
protecting your application against any such eventuality. Although an
ordinary padlock is pickable, it is still much harder to get past than a
cabinet hook!

[ ]

In this guide, you will learn about best practices for storing sensitive
information, authentication, network security, and tools that will help
you secure your app. This is not a preflight checklist—it is a catalogue
of options, each of which will help further protect your app and users.

Storing Sensitive Info 

Never store sensitive API keys in your app code. Anything included in
your code could be accessed in plain text by anyone inspecting the app
bundle. Tools like react-native-dotenv and react-native-config are great
for adding environment-specific variables like API endpoints, but they
should not be confused with server-side environment variables, which can
often contain secrets and API keys.

If you must have an API key or a secret to access some resource from
your app, the most secure way to handle this would be to build an
orchestration layer between your app and the resource. This could be a
serverless function (e.g. using AWS Lambda or Google Cloud Functions)
which can forward the request with the required API key or secret.
Secrets in server side code cannot be accessed by the API consumers the
same way secrets in your app code can.

For persisted user data, choose the right type of storage based on its
sensitivity. As your app is used, you’ll often find the need to save
data on the device, whether to support your app being used offline, cut
down on network requests or save your user’s access token between
sessions so they wouldn’t have to re-authenticate each time they use the
app.

  Persisted vs unpersisted — persisted data is written to the device’s
  disk, which lets the data be read by your app across application
  launches without having to do another network request to fetch it or
  asking the user to re-enter it. But this also can make that data more
  vulnerable to being accessed by attackers. Unpersisted data is never
  written to disk—so there's no data to access!

Async Storage 

Async Storage is a community-maintained module for React Native that
provides an asynchronous, unencrypted, key-value store. Async Storage is
not shared between apps: every app has its own sandbox environment and
has no access to data from other apps.

  Do use async storage when...                    Don't use async storage for...
  ----------------------------------------------- --------------------------------
  Persisting non-sensitive data across app runs   Token storage
  Persisting Redux state                          Secrets
  Persisting GraphQL state                        
  Storing global app-wide variables               

Developer Notes 

-   Web

  Async Storage is the React Native equivalent of Local Storage from the
  web

Secure Storage 

React Native does not come bundled with any way of storing sensitive
data. However, there are pre-existing solutions for Android and iOS
platforms.

iOS - Keychain Services 

Keychain Services allows you to securely store small chunks of sensitive
info for the user. This is an ideal place to store certificates, tokens,
passwords, and any other sensitive information that doesn’t belong in
Async Storage.

Android - Secure Shared Preferences 

Shared Preferences is the Android equivalent for a persistent key-value
data store. Data in Shared Preferences is not encrypted by default , but
Encrypted Shared Preferences wraps the Shared Preferences class for
Android, and automatically encrypts keys and values.

Android - Keystore 

The Android Keystore system lets you store cryptographic keys in a
container to make it more difficult to extract from the device.

In order to use iOS Keychain services or Android Secure Shared
Preferences, you can either write a bridge yourself or use a library
which wraps them for you and provides a unified API at your own risk.
Some libraries to consider:

-   expo-secure-store
-   react-native-encrypted-storage - uses Keychain on iOS and
    EncryptedSharedPreferences on Android.
-   react-native-keychain
-   react-native-sensitive-info - secure for iOS, but uses Android
    Shared Preferences for Android (which is not secure by default).
    There is however a branch that uses Android Keystore.
    -   redux-persist-sensitive-storage - wraps
        react-native-sensitive-info for Redux.

  Be mindful of unintentionally storing or exposing sensitive info. This
  could happen accidentally, for example saving sensitive form data in
  redux state and persisting the whole state tree in Async Storage. Or
  sending user tokens and personal info to an application monitoring
  service such as Sentry or Crashlytics.

Authentication and Deep Linking 

[ ]

Mobile apps have a unique vulnerability that is non-existent in the web:
deep linking . Deep linking is a way of sending data directly to a
native application from an outside source. A deep link looks like
 app:// where  app is your app scheme and anything following the //
could be used internally to handle the request.

For example, if you were building an ecommerce app, you could use
 app://products/1 to deep link to your app and open the product detail
page for a product with id 1. You can think of these kind of like URLs
on the web, but with one crucial distinction:

Deep links are not secure and you should never send any sensitive
information in them.

The reason deep links are not secure is because there is no centralized
method of registering URL schemes. As an application developer, you can
use almost any url scheme you choose by configuring it in Xcode for iOS
or adding an intent on Android .

There is nothing stopping a malicious application from hijacking your
deep link by also registering to the same scheme and then obtaining
access to the data your link contains. Sending something like
 app://products/1 is not harmful, but sending tokens is a security
concern.

When the operating system has two or more applications to choose from
when opening a link, Android will show the user a Disambiguation dialog
and ask them to choose which application to use to open the link. On iOS
however, the operating system will make the choice for you, so the user
will be blissfully unaware. Apple has made steps to address this issue
in later iOS versions (iOS 11) where they instituted a
first-come-first-served principle, although this vulnerability could
still be exploited in different ways which you can read more about here
. Using universal links will allow linking to content within your app
securely in iOS.

OAuth2 and Redirects 

The OAuth2 authentication protocol is incredibly popular nowadays,
prided as the most complete and secure protocol around. The OpenID
Connect protocol is also based on this. In OAuth2, the user is asked to
authenticate via a third party. On successful completion, this third
party redirects back to the requesting application with a verification
code which can be exchanged for a JWT — a JSON Web Token . JWT is an
open standard for securely transmitting information between parties on
the web.

On the web, this redirect step is secure, because URLs on the web are
guaranteed to be unique. This is not true for apps because, as mentioned
earlier, there is no centralized method of registering URL schemes! In
order to address this security concern, an additional check must be
added in the form of PKCE.

PKCE , pronounced “Pixy” stands for Proof of Key Code Exchange, and is
an extension to the OAuth 2 spec. This involves adding an additional
layer of security which verifies that the authentication and token
exchange requests come from the same client. PKCE uses the SHA 256
Cryptographic Hash Algorithm. SHA 256 creates a unique “signature” for a
text or file of any size, but it is:

-   Always the same length regardless of the input file
-   Guaranteed to always produce the same result for the same input
-   One way (that is, you can’t reverse engineer it to reveal the
    original input)

Now you have two values:

-   code_verifier - a large random string generated by the client
-   code_challenge - the SHA 256 of the code_verifier

During the initial  /authorize request, the client also sends the
 code_challenge for the  code_verifier it keeps in memory. After the
authorize request has returned correctly, the client also sends the
 code_verifier that was used to generate the  code_challenge . The IDP
will then calculate the  code_challenge , see if it matches what was set
on the very first  /authorize request, and only send the access token if
the values match.

This guarantees that only the application that triggered the initial
authorization flow would be able to successfully exchange the
verification code for a JWT. So even if a malicious application gets
access to the verification code, it will be useless on its own. To see
this in action, check out this example .

A library to consider for native OAuth is react-native-app-auth .
React-native-app-auth is an SDK for communicating with OAuth2 providers.
It wraps the native AppAuth-iOS and AppAuth-Android libraries and can
support PKCE.

  React-native-app-auth can support PKCE only if your Identity Provider
  supports it.

[OAuth2 with PKCE]

Network Security 

Your APIs should always use SSL encryption . SSL encryption protects
against the requested data being read in plain text between when it
leaves the server and before it reaches the client. You’ll know the
endpoint is secure, because it starts with  https:// instead of  http://
.

SSL Pinning 

Using https endpoints could still leave your data vulnerable to
interception. With https, the client will only trust the server if it
can provide a valid certificate that is signed by a trusted Certificate
Authority that is pre-installed on the client. An attacker could take
advantage of this by installing a malicious root CA certificate to the
user’s device, so the client would trust all certificates that are
signed by the attacker. Thus, relying on certificates alone could still
leave you vulnerable to a man-in-the-middle attack .

SSL pinning is a technique that can be used on the client side to avoid
this attack. It works by embedding (or pinning) a list of trusted
certificates to the client during development, so that only the requests
signed with one of the trusted certificates will be accepted, and any
self-signed certificates will not be.

  When using SSL pinning, you should be mindful of certificate expiry.
  Certificates expire every 1-2 years and when one does, it’ll need to
  be updated in the app as well as on the server. As soon as the
  certificate on the server has been updated, any apps with the old
  certificate embedded in them will cease to work.

Summary 

There is no bulletproof way to handle security, but with conscious
effort and diligence, it is possible to significantly reduce the
likelihood of a security breach in your application. Invest in security
proportional to the sensitivity of the data stored in your application,
the number of users, and the damage a hacker could do when gaining
access to their account. And remember: it’s significantly harder to
access information that was never requested in the first place.

# Settings #
 ____       _   _   _                 
/ ___|  ___| |_| |_(_)_ __   __ _ ___ 
\___ \ / _ \ __| __| | '_ \ / _` / __|
 ___) |  __/ |_| |_| | | | | (_| \__ \
|____/ \___|\__|\__|_|_| |_|\__, |___/
                            |___/     
-   Example
-   Methods
    -    clearWatch()
    -    get()
    -    set()
    -    watchKeys()
Settings

 Settings serves as a wrapper for  NSUserDefaults , a persistent
key-value store available only on iOS.

Example 

------------------------------------------------------------------------

Reference

Methods 

 clearWatch() 

    static clearWatch(watchId: number);

 

 watchId is the number returned by  watchKeys() when the subscription
was originally configured.

------------------------------------------------------------------------

 get() 

    static get(key: string): any;

 

Get the current value for a given  key in  NSUserDefaults .

------------------------------------------------------------------------

 set() 

    static set(settings: Record<string, any>);

 

Set one or more values in  NSUserDefaults .

------------------------------------------------------------------------

 watchKeys() 

    static watchKeys(keys: string | array<string>, callback: () => void): number;

 

Subscribe to be notified when the value for any of the keys specified by
the  keys parameter has been changed in  NSUserDefaults . Returns a
 watchId number that may be used with  clearWatch() to unsubscribe.

  Note:  watchKeys() by design ignores internal  set() calls and fires
  callback only on changes preformed outside of React Native code.

# Setting up the development environment #
 ____       _   _   _                             _   _          
/ ___|  ___| |_| |_(_)_ __   __ _   _   _ _ __   | |_| |__   ___ 
\___ \ / _ \ __| __| | '_ \ / _` | | | | | '_ \  | __| '_ \ / _ \
 ___) |  __/ |_| |_| | | | | (_| | | |_| | |_) | | |_| | | |  __/
|____/ \___|\__|\__|_|_| |_|\__, |  \__,_| .__/   \__|_| |_|\___|
                            |___/        |_|                     
     _                _                                  _   
  __| | _____   _____| | ___  _ __  _ __ ___   ___ _ __ | |_ 
 / _` |/ _ \ \ / / _ \ |/ _ \| '_ \| '_ ` _ \ / _ \ '_ \| __|
| (_| |  __/\ V /  __/ | (_) | |_) | | | | | |  __/ | | | |_ 
 \__,_|\___| \_/ \___|_|\___/| .__/|_| |_| |_|\___|_| |_|\__|
                             |_|                             
                 _                                      _   
  ___ _ ____   _(_)_ __ ___  _ __  _ __ ___   ___ _ __ | |_ 
 / _ \ '_ \ \ / / | '__/ _ \| '_ \| '_ ` _ \ / _ \ '_ \| __|
|  __/ | | \ V /| | | | (_) | | | | | | | | |  __/ | | | |_ 
 \___|_| |_|\_/ |_|_|  \___/|_| |_|_| |_| |_|\___|_| |_|\__|
                                                            

Setting up the development environment

This page will help you install and build your first React Native app.

If you are new to mobile development , the easiest way to get started is
with Expo Go. Expo is a set of tools and services built around React
Native and, while it has many features , the most relevant feature for
us right now is that it can get you writing a React Native app within
minutes. You will only need a recent version of Node.js and a phone or
emulator. If you'd like to try out React Native directly in your web
browser before installing any tools, you can try out Snack .

If you are already familiar with mobile development , you may want to
use React Native CLI. It requires Xcode or Android Studio to get
started. If you already have one of these tools installed, you should be
able to get up and running within a few minutes. If they are not
installed, you should expect to spend about an hour installing and
configuring them.

-   Expo Go Quickstart
-   React Native CLI Quickstart

Run the following command to create a new React Native project called
"AwesomeProject":

-   npm
-   Yarn

    npx create-expo-app AwesomeProject

    cd AwesomeProject
    npx expo start

 

    yarn create expo-app AwesomeProject

    cd AwesomeProject
    yarn expo start

 

This will start a development server for you.

Running your React Native application

Install the Expo Go app on your iOS or Android phone and connect to the
same wireless network as your computer. On Android, use the Expo Go app
to scan the QR code from your terminal to open your project. On iOS, use
the built-in QR code scanner of the default iOS Camera app.

Modifying your app

Now that you have successfully run the app, let's modify it. Open
 App.js in your text editor of choice and edit some lines. The
application should reload automatically once you save your changes.

That's it!

Congratulations! You've successfully run and modified your first React
Native app.



Now what?

Expo also has docs you can reference if you have questions specific to
the tool. You can also ask for help on the Expo Discord .

If you have a problem with Expo, before creating a new issue, please see
if there's an existing issue about it in the Expo issues .

If you're curious to learn more about React Native, check out the
Introduction to React Native .

Running your app on a simulator or virtual device

Expo Go allows you to run your React Native app on a physical device
without installing iOS and Android native SDKs. If you want to run your
app on the iOS Simulator or an Android Virtual Device, please refer to
the instructions for "React Native CLI Quickstart" to learn how to
install Xcode or set up your Android development environment.

Once you've set these up, you can launch your app on an Android Virtual
Device by running  npm run android , or on the iOS Simulator by running
 npm run ios (macOS only).

Caveats

The Expo Go app is a great tool to get started — it exists to help
developers quickly get projects off the ground, to experiment with ideas
(such as on Snack ) and share their work with minimal friction. Expo Go
makes this possible by including a feature-rich native runtime made up
of every module in the Expo SDK , so all you need to do to use a module
is install the package with  npx expo install and reload your app.

The tradeoff is that the Expo Go app does not allow you to add custom
native code — you can only use native modules built into the Expo SDK.
There are many great libraries available outside of the Expo SDK, and
you may even want to build your own native library. You can leverage
these libraries with development builds , or by using "prebuild" to
generate the native projects, or both. Learn more about adding native
code to projects created with  create-expo-app .

 create-expo-app configures your project to use the most recent React
Native version that is supported by the Expo SDK. The Expo Go app
usually gains support for a given React Native version with new SDK
versions (released quarterly). You can check this document to find out
what versions are supported.

If you're integrating React Native into an existing project, you can use
the Expo SDK and development builds , but you will need to set up a
native development environment. Select "React Native CLI Quickstart"
above for instructions on configuring a native build environment for
React Native.

Follow these instructions if you need to build native code in your
project. For example, if you are integrating React Native into an
existing application, or if you ran "prebuild" from Expo to generate
your project's native code, you'll need this section.

The instructions are a bit different depending on your development
operating system, and whether you want to start developing for iOS or
Android. If you want to develop for both Android and iOS, that's fine -
you can pick one to start with, since the setup is a bit different.

Development OS 

-   macOS
-   Windows
-   Linux

Target OS 

-   Android
-   iOS

Installing dependencies 

You will need Node, Watchman, the React Native command line interface, a
JDK, and Android Studio.

While you can use any editor of your choice to develop your app, you
will need to install Android Studio in order to set up the necessary
tooling to build your React Native app for Android.

Node & Watchman

We recommend installing Node and Watchman using Homebrew . Run the
following commands in a Terminal after installing Homebrew:

    brew install node
    brew install watchman

 

If you have already installed Node on your system, make sure it is Node
18 or newer.

Watchman is a tool by Facebook for watching changes in the filesystem.
It is highly recommended you install it for better performance.

Java Development Kit

We recommend installing the OpenJDK distribution called Azul Zulu using
Homebrew . Run the following commands in a Terminal after installing
Homebrew:

    brew tap homebrew/cask-versions
    brew install --cask zulu17

    # Get path to where cask was installed to double-click installer
    brew info --cask zulu17

 

After you install the JDK, update your  JAVA_HOME environment variable.
If you used above steps, JDK will likely be at
 /Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home

The Zulu OpenJDK distribution offers JDKs for both Intel and M1 Macs .
This will make sure your builds are faster on M1 Macs compared to using
an Intel-based JDK.

If you have already installed JDK on your system, we recommend JDK 17.
You may encounter problems using higher JDK versions.

Android development environment

Setting up your development environment can be somewhat tedious if
you're new to Android development. If you're already familiar with
Android development, there are a few things you may need to configure.
In either case, please make sure to carefully follow the next few steps.

1. Install Android Studio

Download and install Android Studio . While on Android Studio
installation wizard, make sure the boxes next to all of the following
items are checked:

-    Android SDK
-    Android SDK Platform
-    Android Virtual Device

Then, click "Next" to install all of these components.

  If the checkboxes are grayed out, you will have a chance to install
  these components later on.

Once setup has finalized and you're presented with the Welcome screen,
proceed to the next step.

2. Install the Android SDK

Android Studio installs the latest Android SDK by default. Building a
React Native app with native code, however, requires the
 Android 14 (UpsideDownCake) SDK in particular. Additional Android SDKs
can be installed through the SDK Manager in Android Studio.

To do that, open Android Studio, click on "More Actions" button and
select "SDK Manager".

[Android Studio Welcome]

  The SDK Manager can also be found within the Android Studio "Settings"
  dialog, under Languages & Frameworks → Android SDK .

Select the "SDK Platforms" tab from within the SDK Manager, then check
the box next to "Show Package Details" in the bottom right corner. Look
for and expand the  Android 14 (UpsideDownCake) entry, then make sure
the following items are checked:

-    Android SDK Platform 34
-    Intel x86 Atom_64 System Image or
     Google APIs Intel x86 Atom System Image or (for Apple M1 Silicon)
     Google APIs ARM 64 v8a System Image

Next, select the "SDK Tools" tab and check the box next to "Show Package
Details" here as well. Look for and expand the "Android SDK Build-Tools"
entry, then make sure that  34.0.0 is selected.

Finally, click "Apply" to download and install the Android SDK and
related build tools.

3. Configure the ANDROID_HOME environment variable

The React Native tools require some environment variables to be set up
in order to build apps with native code.

Add the following lines to your  ~/.zprofile or  ~/.zshrc (if you are
using  bash , then  ~/.bash_profile or  ~/.bashrc ) config file:

    export ANDROID_HOME=$HOME/Library/Android/sdk
    export PATH=$PATH:$ANDROID_HOME/emulator
    export PATH=$PATH:$ANDROID_HOME/platform-tools

 

Run  source ~/.zprofile (or  source ~/.bash_profile for  bash ) to load
the config into your current shell. Verify that ANDROID_HOME has been
set by running  echo $ANDROID_HOME and the appropriate directories have
been added to your path by running  echo $PATH .

  Please make sure you use the correct Android SDK path. You can find
  the actual location of the SDK in the Android Studio "Settings"
  dialog, under Languages & Frameworks → Android SDK .

React Native Command Line Interface

React Native has a built-in command line interface. Rather than install
and manage a specific version of the CLI globally, we recommend you
access the current version at runtime using  npx , which ships with
Node.js. With  npx react-native <command> , the current stable version
of the CLI will be downloaded and executed at the time the command is
run.

Creating a new application

  If you previously installed a global  react-native-cli package, please
  remove it as it may cause unexpected issues:

      npm uninstall -g react-native-cli @react-native-community/cli

   

React Native has a built-in command line interface, which you can use to
generate a new project. You can access it without installing anything
globally using  npx , which ships with Node.js. Let's create a new React
Native project called "AwesomeProject":

    npx react-native@latest init AwesomeProject

 

This is not necessary if you are integrating React Native into an
existing application, or if you've installed Expo in your project, or if
you're adding Android support to an existing React Native project (see
Integration with Existing Apps ). You can also use a third-party CLI to
init your React Native app, such as Ignite CLI .

[Optional] Using a specific version or template

If you want to start a new project with a specific React Native version,
you can use the  --version argument:

    npx react-native@X.XX.X init AwesomeProject --version X.XX.X

 

You can also start a project with a custom React Native template with
the  --template argument.

Preparing the Android device

You will need an Android device to run your React Native Android app.
This can be either a physical Android device, or more commonly, you can
use an Android Virtual Device which allows you to emulate an Android
device on your computer.

Either way, you will need to prepare the device to run Android apps for
development.

Using a physical device

If you have a physical Android device, you can use it for development in
place of an AVD by plugging it in to your computer using a USB cable and
following the instructions here .

Using a virtual device

If you use Android Studio to open  ./AwesomeProject/android , you can
see the list of available Android Virtual Devices (AVDs) by opening the
"AVD Manager" from within Android Studio. Look for an icon that looks
like this:

[Android Studio AVD Manager]

If you have recently installed Android Studio, you will likely need to
create a new AVD . Select "Create Virtual Device...", then pick any
Phone from the list and click "Next", then select the UpsideDownCake API
Level 34 image.

Click "Next" then "Finish" to create your AVD. At this point you should
be able to click on the green triangle button next to your AVD to launch
it, then proceed to the next step.

Running your React Native application

Step 1: Start Metro

Metro is the JavaScript build tool for React Native. To start the Metro
development server, run the following from your project folder:

-   npm
-   Yarn

    npm start

 

    yarn start

 

 note

If you're familiar with web development, Metro is similar to bundlers
such as Vite and webpack, but is designed end-to-end for React Native.
For instance, Metro uses Babel to transform syntax such as JSX into
executable JavaScript.

Step 2: Start your application

-   npm
-   Yarn

    npm run android

 

    yarn android

 

If everything is set up correctly, you should see your new app running
in your Android emulator shortly.

[AwesomeProject on Android]

This is one way to run your app - you can also run it directly from
within Android Studio.

  If you can't get this to work, see the Troubleshooting page.

Modifying your app

Now that you have successfully run the app, let's modify it.

-   Open  App.tsx in your text editor of choice and edit some lines.
-   Press the R key twice or select  Reload from the Dev Menu ( Cmd ⌘  +
    M ) to see your changes!

That's it!

Congratulations! You've successfully run and modified your first React
Native app.



Now what?

-   If you want to add this new React Native code to an existing
    application, check out the Integration guide .

If you're curious to learn more about React Native, check out the
Introduction to React Native .

Installing dependencies 

You will need Node, Watchman, the React Native command line interface,
Xcode and CocoaPods.

While you can use any editor of your choice to develop your app, you
will need to install Xcode in order to set up the necessary tooling to
build your React Native app for iOS.

Node & Watchman 

We recommend installing Node and Watchman using Homebrew . Run the
following commands in a Terminal after installing Homebrew:

    brew install node
    brew install watchman

 

If you have already installed Node on your system, make sure it is Node
18 or newer.

Watchman is a tool by Facebook for watching changes in the filesystem.
It is highly recommended you install it for better performance.

Xcode 

Please use the latest version of Xcode.

The easiest way to install Xcode is via the Mac App Store . Installing
Xcode will also install the iOS Simulator and all the necessary tools to
build your iOS app.

Command Line Tools 

You will also need to install the Xcode Command Line Tools. Open Xcode,
then choose Settings... (or Preferences...) from the Xcode menu. Go to
the Locations panel and install the tools by selecting the most recent
version in the Command Line Tools dropdown.

[Xcode Command Line Tools]

Installing an iOS Simulator in Xcode 

To install a simulator, open Xcode > Settings... (or Preferences...) and
select the Platforms (or Components) tab. Select a simulator with the
corresponding version of iOS you wish to use.

If you are using Xcode version 14.0 or greater than to install a
simulator, open Xcode > Settings > Platforms tab, then click "+" icon
and select iOS… option.

CocoaPods 

CocoaPods is one of the dependency management system available for iOS.
CocoaPods is a Ruby gem . You can install CocoaPods using the version of
Ruby that ships with the latest version of macOS.

For more information, please visit CocoaPods Getting Started guide .

React Native Command Line Interface 

React Native has a built-in command line interface. Rather than install
and manage a specific version of the CLI globally, we recommend you
access the current version at runtime using  npx , which ships with
Node.js. With  npx react-native <command> , the current stable version
of the CLI will be downloaded and executed at the time the command is
run.

Creating a new application 

  If you previously installed a global  react-native-cli package, please
  remove it as it may cause unexpected issues:

      npm uninstall -g react-native-cli @react-native-community/cli

   

You can use React Native's built-in command line interface to generate a
new project. Let's create a new React Native project called
"AwesomeProject":

    npx react-native@latest init AwesomeProject

 

This is not necessary if you are integrating React Native into an
existing application, or if you've installed Expo in your project, or if
you're adding iOS support to an existing React Native project (see
Integration with Existing Apps ). You can also use a third-party CLI to
init your React Native app, such as Ignite CLI .

 info

If you are having trouble with iOS, try to reinstall the dependencies by
running:

1.   cd ios to navigate to the  ios folder.
2.   bundle install to install Bundler
3.   bundle exec pod install to install the iOS dependencies managed by
    CocoaPods.

[Optional] Using a specific version or template 

If you want to start a new project with a specific React Native version,
you can use the  --version argument:

    npx react-native@X.XX.X init AwesomeProject --version X.XX.X

 

You can also start a project with a custom React Native template with
the  --template argument.

  Note If the above command is failing, you may have old version of
   react-native or  react-native-cli installed globally on your pc. Try
  uninstalling the cli and run the cli using  npx .

[Optional] Configuring your environment 

Starting from React Native version 0.69, it is possible to configure the
Xcode environment using the  .xcode.env file provided by the template.

The  .xcode.env file contains an environment variable to export the path
to the  node executable in the  NODE_BINARY variable. This is the
suggested approach to decouple the build infrastructure from the system
version of  node . You should customize this variable with your own path
or your own  node version manager, if it differs from the default.

On top of this, it's possible to add any other environment variable and
to source the  .xcode.env file in your build script phases. If you need
to run script that requires some specific environment, this is the
suggested approach : it allows to decouple the build phases from a
specific environment.

 info

If you are already using NVM (a command which helps you install and
switch between versions of Node.js) and zsh , you might want to move the
code that initialize NVM from your  ~/.zshrc into a  ~/.zshenv file to
help Xcode find your Node executable:

    export NVM_DIR="$HOME/.nvm"
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm

 

You might also want to ensure that all "shell script build phase" of
your Xcode project, is using  /bin/zsh as its shell.

Running your React Native application 

Step 1: Start Metro 

Metro is the JavaScript build tool for React Native. To start the Metro
development server, run the following from your project folder:

-   npm
-   Yarn

    npm start

 

    yarn start

 

 note

If you're familiar with web development, Metro is similar to bundlers
such as Vite and webpack, but is designed end-to-end for React Native.
For instance, Metro uses Babel to transform syntax such as JSX into
executable JavaScript.

Step 2: Start your application 

Let Metro Bundler run in its own terminal. Open a new terminal inside
your React Native project folder. Run the following:

-   npm
-   Yarn

    npm run ios

 

    yarn ios

 

You should see your new app running in the iOS Simulator shortly.

[AwesomeProject on iOS]

This is one way to run your app. You can also run it directly from
within Xcode.

  If you can't get this to work, see the Troubleshooting page.

Running on a device 

The above command will automatically run your app on the iOS Simulator
by default. If you want to run the app on an actual physical iOS device,
please follow the instructions here .

Modifying your app 

Now that you have successfully run the app, let's modify it.

-   Open  App.tsx in your text editor of choice and edit some lines.
-   Hit Cmd ⌘  + R in your iOS Simulator to reload the app and see your
    changes!

That's it! 

Congratulations! You've successfully run and modified your first React
Native app.



Now what? 

-   If you want to add this new React Native code to an existing
    application, check out the Integration guide .

If you're curious to learn more about React Native, check out the
Introduction to React Native .

Target OS 

-   Android
-   iOS

Installing dependencies

You will need Node, the React Native command line interface, a JDK, and
Android Studio.

While you can use any editor of your choice to develop your app, you
will need to install Android Studio in order to set up the necessary
tooling to build your React Native app for Android.

Node, JDK

We recommend installing Node via Chocolatey , a popular package manager
for Windows.

It is recommended to use an LTS version of Node. If you want to be able
to switch between different versions, you might want to install Node via
nvm-windows , a Node version manager for Windows.

React Native also requires Java SE Development Kit (JDK) , which can be
installed using Chocolatey as well.

Open an Administrator Command Prompt (right click Command Prompt and
select "Run as Administrator"), then run the following command:

    choco install -y nodejs-lts microsoft-openjdk17

 

If you have already installed Node on your system, make sure it is Node
18 or newer. If you already have a JDK on your system, we recommend
JDK17. You may encounter problems using higher JDK versions.

  You can find additional installation options on Node's Downloads page
  .

  If you're using the latest version of Java Development Kit, you'll
  need to change the Gradle version of your project so it can recognize
  the JDK. You can do that by going to
   {project root folder}\android\gradle\wrapper\gradle-wrapper.properties
  and changing the  distributionUrl value to upgrade the Gradle version.
  You can check out here the latest releases of Gradle .

Android development environment

Setting up your development environment can be somewhat tedious if
you're new to Android development. If you're already familiar with
Android development, there are a few things you may need to configure.
In either case, please make sure to carefully follow the next few steps.

1. Install Android Studio

Download and install Android Studio . While on Android Studio
installation wizard, make sure the boxes next to all of the following
items are checked:

-    Android SDK
-    Android SDK Platform
-    Android Virtual Device
-   If you are not already using Hyper-V:  Performance (Intel ® HAXM) (
    See here for AMD or Hyper-V )

Then, click "Next" to install all of these components.

  If the checkboxes are grayed out, you will have a chance to install
  these components later on.

Once setup has finalized and you're presented with the Welcome screen,
proceed to the next step.

2. Install the Android SDK

Android Studio installs the latest Android SDK by default. Building a
React Native app with native code, however, requires the
 Android 14 (UpsideDownCake) SDK in particular. Additional Android SDKs
can be installed through the SDK Manager in Android Studio.

To do that, open Android Studio, click on "More Actions" button and
select "SDK Manager".

[Android Studio Welcome]

  The SDK Manager can also be found within the Android Studio "Settings"
  dialog, under Languages & Frameworks → Android SDK .

Select the "SDK Platforms" tab from within the SDK Manager, then check
the box next to "Show Package Details" in the bottom right corner. Look
for and expand the  Android 14 (UpsideDownCake) entry, then make sure
the following items are checked:

-    Android SDK Platform 34
-    Intel x86 Atom_64 System Image or
     Google APIs Intel x86 Atom System Image

Next, select the "SDK Tools" tab and check the box next to "Show Package
Details" here as well. Look for and expand the  Android SDK Build-Tools
entry, then make sure that  34.0.0 is selected.

Finally, click "Apply" to download and install the Android SDK and
related build tools.

3. Configure the ANDROID_HOME environment variable

The React Native tools require some environment variables to be set up
in order to build apps with native code.

1.  Open the Windows Control Panel.
2.  Click on User Accounts, then click User Accounts again
3.  Click on Change my environment variables
4.  Click on New... to create a new  ANDROID_HOME user variable that
    points to the path to your Android SDK:

[ANDROID_HOME Environment Variable]

The SDK is installed, by default, at the following location:

    %LOCALAPPDATA%\Android\Sdk

 

You can find the actual location of the SDK in the Android Studio
"Settings" dialog, under Languages & Frameworks → Android SDK .

Open a new Command Prompt window to ensure the new environment variable
is loaded before proceeding to the next step.

1.  Open powershell
2.  Copy and paste Get-ChildItem -Path Env:\ into powershell
3.  Verify  ANDROID_HOME has been added

4. Add platform-tools to Path

1.  Open the Windows Control Panel.
2.  Click on User Accounts, then click User Accounts again
3.  Click on Change my environment variables
4.  Select the Path variable.
5.  Click Edit.
6.  Click New and add the path to platform-tools to the list.

The default location for this folder is:

    %LOCALAPPDATA%\Android\Sdk\platform-tools

 

React Native Command Line Interface

React Native has a built-in command line interface. Rather than install
and manage a specific version of the CLI globally, we recommend you
access the current version at runtime using  npx , which ships with
Node.js. With  npx react-native <command> , the current stable version
of the CLI will be downloaded and executed at the time the command is
run.

Creating a new application

  If you previously installed a global  react-native-cli package, please
  remove it as it may cause unexpected issues:

      npm uninstall -g react-native-cli @react-native-community/cli

   

React Native has a built-in command line interface, which you can use to
generate a new project. You can access it without installing anything
globally using  npx , which ships with Node.js. Let's create a new React
Native project called "AwesomeProject":

    npx react-native@latest init AwesomeProject

 

This is not necessary if you are integrating React Native into an
existing application, or if you've installed Expo in your project, or if
you're adding Android support to an existing React Native project (see
Integration with Existing Apps ). You can also use a third-party CLI to
init your React Native app, such as Ignite CLI .

[Optional] Using a specific version or template

If you want to start a new project with a specific React Native version,
you can use the  --version argument:

    npx react-native@X.XX.X init AwesomeProject --version X.XX.X

 

You can also start a project with a custom React Native template with
the  --template argument.

Preparing the Android device

You will need an Android device to run your React Native Android app.
This can be either a physical Android device, or more commonly, you can
use an Android Virtual Device which allows you to emulate an Android
device on your computer.

Either way, you will need to prepare the device to run Android apps for
development.

Using a physical device

If you have a physical Android device, you can use it for development in
place of an AVD by plugging it in to your computer using a USB cable and
following the instructions here .

Using a virtual device

If you use Android Studio to open  ./AwesomeProject/android , you can
see the list of available Android Virtual Devices (AVDs) by opening the
"AVD Manager" from within Android Studio. Look for an icon that looks
like this:

[Android Studio AVD Manager]

If you have recently installed Android Studio, you will likely need to
create a new AVD . Select "Create Virtual Device...", then pick any
Phone from the list and click "Next", then select the UpsideDownCake API
Level 34 image.

  If you don't have HAXM installed, click on "Install HAXM" or follow
  these instructions to set it up, then go back to the AVD Manager.

Click "Next" then "Finish" to create your AVD. At this point you should
be able to click on the green triangle button next to your AVD to launch
it, then proceed to the next step.

Running your React Native application

Step 1: Start Metro

Metro is the JavaScript build tool for React Native. To start the Metro
development server, run the following from your project folder:

-   npm
-   Yarn

    npm start

 

    yarn start

 

 note

If you're familiar with web development, Metro is similar to bundlers
such as Vite and webpack, but is designed end-to-end for React Native.
For instance, Metro uses Babel to transform syntax such as JSX into
executable JavaScript.

Step 2: Start your application

Let Metro Bundler run in its own terminal. Open a new terminal inside
your React Native project folder. Run the following:

-   npm
-   Yarn

    npm run android

 

    yarn android

 

If everything is set up correctly, you should see your new app running
in your Android emulator shortly.

[AwesomeProject on Android]

This is one way to run your app - you can also run it directly from
within Android Studio.

  If you can't get this to work, see the Troubleshooting page.

Modifying your app

Now that you have successfully run the app, let's modify it.

-   Open  App.tsx in your text editor of choice and edit some lines.
-   Press the R key twice or select  Reload from the Dev Menu ( Ctrl  +
    M ) to see your changes!

That's it!

Congratulations! You've successfully run and modified your first React
Native app.



Now what?

-   If you want to add this new React Native code to an existing
    application, check out the Integration guide .

If you're curious to learn more about React Native, check out the
Introduction to React Native .

Unsupported 

  A Mac is required to build projects with native code for iOS. You can
  follow the Expo Go Quickstart to learn how to build your app using
  Expo instead.

Target OS 

-   Android
-   iOS

Installing dependencies 

You will need Node, the React Native command line interface, a JDK, and
Android Studio.

While you can use any editor of your choice to develop your app, you
will need to install Android Studio in order to set up the necessary
tooling to build your React Native app for Android.

Node

Follow the installation instructions for your Linux distribution to
install Node 18 or newer.

Java Development Kit

React Native currently recommends version 17 of the Java SE Development
Kit (JDK). You may encounter problems using higher JDK versions. You may
download and install OpenJDK from AdoptOpenJDK or your system packager.

Android development environment

Setting up your development environment can be somewhat tedious if
you're new to Android development. If you're already familiar with
Android development, there are a few things you may need to configure.
In either case, please make sure to carefully follow the next few steps.

1. Install Android Studio

Download and install Android Studio . While on Android Studio
installation wizard, make sure the boxes next to all of the following
items are checked:

-    Android SDK
-    Android SDK Platform
-    Android Virtual Device

Then, click "Next" to install all of these components.

  If the checkboxes are grayed out, you will have a chance to install
  these components later on.

Once setup has finalized and you're presented with the Welcome screen,
proceed to the next step.

2. Install the Android SDK

Android Studio installs the latest Android SDK by default. Building a
React Native app with native code, however, requires the
 Android 14 (UpsideDownCake) SDK in particular. Additional Android SDKs
can be installed through the SDK Manager in Android Studio.

To do that, open Android Studio, click on "Configure" button and select
"SDK Manager".

  The SDK Manager can also be found within the Android Studio "Settings"
  dialog, under Languages & Frameworks → Android SDK .

Select the "SDK Platforms" tab from within the SDK Manager, then check
the box next to "Show Package Details" in the bottom right corner. Look
for and expand the  Android 14 (UpsideDownCake) entry, then make sure
the following items are checked:

-    Android SDK Platform 34
-    Intel x86 Atom_64 System Image or
     Google APIs Intel x86 Atom System Image

Next, select the "SDK Tools" tab and check the box next to "Show Package
Details" here as well. Look for and expand the "Android SDK Build-Tools"
entry, then make sure that  34.0.0 is selected.

Finally, click "Apply" to download and install the Android SDK and
related build tools.

3. Configure the ANDROID_HOME environment variable

The React Native tools require some environment variables to be set up
in order to build apps with native code.

Add the following lines to your  $HOME/.bash_profile or  $HOME/.bashrc
(if you are using  zsh then  ~/.zprofile or  ~/.zshrc ) config file:

    export ANDROID_HOME=$HOME/Android/Sdk
    export PATH=$PATH:$ANDROID_HOME/emulator
    export PATH=$PATH:$ANDROID_HOME/platform-tools

 

   .bash_profile is specific to  bash . If you're using another shell,
  you will need to edit the appropriate shell-specific config file.

Type  source $HOME/.bash_profile for  bash or  source $HOME/.zprofile to
load the config into your current shell. Verify that ANDROID_HOME has
been set by running  echo $ANDROID_HOME and the appropriate directories
have been added to your path by running  echo $PATH .

  Please make sure you use the correct Android SDK path. You can find
  the actual location of the SDK in the Android Studio "Settings"
  dialog, under Languages & Frameworks → Android SDK .

Watchman

Follow the Watchman installation guide to compile and install Watchman
from source.

  Watchman is a tool by Facebook for watching changes in the filesystem.
  It is highly recommended you install it for better performance and
  increased compatibility in certain edge cases (translation: you may be
  able to get by without installing this, but your mileage may vary;
  installing this now may save you from a headache later).

React Native Command Line Interface

React Native has a built-in command line interface. Rather than install
and manage a specific version of the CLI globally, we recommend you
access the current version at runtime using  npx , which ships with
Node.js. With  npx react-native <command> , the current stable version
of the CLI will be downloaded and executed at the time the command is
run.

Creating a new application

  If you previously installed a global  react-native-cli package, please
  remove it as it may cause unexpected issues:

      npm uninstall -g react-native-cli @react-native-community/cli

   

React Native has a built-in command line interface, which you can use to
generate a new project. You can access it without installing anything
globally using  npx , which ships with Node.js. Let's create a new React
Native project called "AwesomeProject":

    npx react-native@latest init AwesomeProject

 

This is not necessary if you are integrating React Native into an
existing application, or if you've installed Expo in your project, or if
you're adding Android support to an existing React Native project (see
Integration with Existing Apps ). You can also use a third-party CLI to
init your React Native app, such as Ignite CLI .

[Optional] Using a specific version or template

If you want to start a new project with a specific React Native version,
you can use the  --version argument:

    npx react-native@X.XX.X init AwesomeProject --version X.XX.X

 

You can also start a project with a custom React Native template with
the  --template argument.

Preparing the Android device

You will need an Android device to run your React Native Android app.
This can be either a physical Android device, or more commonly, you can
use an Android Virtual Device which allows you to emulate an Android
device on your computer.

Either way, you will need to prepare the device to run Android apps for
development.

Using a physical device

If you have a physical Android device, you can use it for development in
place of an AVD by plugging it in to your computer using a USB cable and
following the instructions here .

Using a virtual device

If you use Android Studio to open  ./AwesomeProject/android , you can
see the list of available Android Virtual Devices (AVDs) by opening the
"AVD Manager" from within Android Studio. Look for an icon that looks
like this:

[Android Studio AVD Manager]

If you have recently installed Android Studio, you will likely need to
create a new AVD . Select "Create Virtual Device...", then pick any
Phone from the list and click "Next", then select the UpsideDownCake API
Level 34 image.

  We recommend configuring VM acceleration on your system to improve
  performance. Once you've followed those instructions, go back to the
  AVD Manager.

Click "Next" then "Finish" to create your AVD. At this point you should
be able to click on the green triangle button next to your AVD to launch
it, then proceed to the next step.

Running your React Native application

Step 1: Start Metro

Metro is the JavaScript build tool for React Native. To start the Metro
development server, run the following from your project folder:

-   npm
-   Yarn

    npm start

 

    yarn start

 

 note

If you're familiar with web development, Metro is similar to bundlers
such as Vite and webpack, but is designed end-to-end for React Native.
For instance, Metro uses Babel to transform syntax such as JSX into
executable JavaScript.

Step 2: Start your application

Let Metro Bundler run in its own terminal. Open a new terminal inside
your React Native project folder. Run the following:

-   npm
-   Yarn

    npm run android

 

    yarn android

 

If everything is set up correctly, you should see your new app running
in your Android emulator shortly.

This is one way to run your app - you can also run it directly from
within Android Studio.

  If you can't get this to work, see the Troubleshooting page.

Modifying your app

Now that you have successfully run the app, let's modify it.

-   Open  App.tsx in your text editor of choice and edit some lines.
-   Press the R key twice or select  Reload from the Dev Menu ( Ctrl  +
    M ) to see your changes!

That's it!

Congratulations! You've successfully run and modified your first React
Native app.



Now what?

-   If you want to add this new React Native code to an existing
    application, check out the Integration guide .

If you're curious to learn more about React Native, check out the
Introduction to React Native .

Unsupported 

  A Mac is required to build projects with native code for iOS. You can
  follow the Expo Go Quickstart to learn how to build your app using
  Expo instead.

# Shadow Props #
 ____  _               _                 ____                      
/ ___|| |__   __ _  __| | _____      __ |  _ \ _ __ ___  _ __  ___ 
\___ \| '_ \ / _` |/ _` |/ _ \ \ /\ / / | |_) | '__/ _ \| '_ \/ __|
 ___) | | | | (_| | (_| | (_) \ V  V /  |  __/| | | (_) | |_) \__ \
|____/|_| |_|\__,_|\__,_|\___/ \_/\_/   |_|   |_|  \___/| .__/|___/
                                                        |_|        
-   Props
    -    shadowColor
    -    shadowOffset
        iOS
    -    shadowOpacity
        iOS
    -    shadowRadius
        iOS
Shadow Props

-   TypeScript
-   JavaScript

------------------------------------------------------------------------

Reference

Props 

 shadowColor 

Sets the drop shadow color.

This property will only work on Android API 28 and above. For similar
functionality on lower Android APIs, use the  elevation property .

  Type
  -------
  color

------------------------------------------------------------------------

 shadowOffset

iOS



Sets the drop shadow offset.

  Type
  -----------------------------------------
  object:  {width: number,height: number}

------------------------------------------------------------------------

 shadowOpacity

iOS



Sets the drop shadow opacity (multiplied by the color's alpha
component).

  Type
  --------
  number

------------------------------------------------------------------------

 shadowRadius

iOS



Sets the drop shadow blur radius.

  Type
  --------
  number

# Share #
 ____  _                    
/ ___|| |__   __ _ _ __ ___ 
\___ \| '_ \ / _` | '__/ _ \
 ___) | | | | (_| | | |  __/
|____/|_| |_|\__,_|_|  \___|
                            
-   Example
-   Methods
    -    share()
-   Properties
    -    sharedAction
    -    dismissedAction
        iOS
Share

Example 

-   TypeScript
-   JavaScript

Reference

Methods 

 share() 

    static share(content: ShareContent, options?: ShareOptions);

 

Open a dialog to share text content.

In iOS, returns a Promise which will be invoked with an object
containing  action and  activityType . If the user dismissed the dialog,
the Promise will still be resolved with action being
 Share.dismissedAction and all the other keys being undefined. Note that
some share options will not appear or work on the iOS simulator.

In Android, returns a Promise which will always be resolved with action
being  Share.sharedAction .

Properties:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| content               | object                |  message - a message  |
|                       |                       | to share              |
| Required              |                       |  url - a URL to share |
|                       |                       |                       |
|                       |                       | iOS                   |
|                       |                       |                       |
|                       |                       |  title - title of the |
|                       |                       | message               |
|                       |                       |                       |
|                       |                       | Android               |
|                       |                       |                       |
|                       |                       | -------------------   |
|                       |                       |                       |
|                       |                       | At least one of  url  |
|                       |                       | and  message is       |
|                       |                       | required.             |
+-----------------------+-----------------------+-----------------------+
| options               | object                |  dialogTitle          |
|                       |                       |                       |
|                       |                       | Android               |
|                       |                       |                       |
|                       |                       |                       |
|                       |                       | excludedActivityTypes |
|                       |                       |                       |
|                       |                       | iOS                   |
|                       |                       |                       |
|                       |                       |  subject - a subject  |
|                       |                       | to share via email    |
|                       |                       |                       |
|                       |                       | iOS                   |
|                       |                       |                       |
|                       |                       |  tintColor            |
|                       |                       |                       |
|                       |                       | iOS                   |
|                       |                       |                       |
|                       |                       |  anchor - the node to |
|                       |                       | which the action      |
|                       |                       | sheet should be       |
|                       |                       | anchored (used for    |
|                       |                       | iPad)                 |
|                       |                       |                       |
|                       |                       | iOS                   |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

Properties 

 sharedAction 

    static sharedAction: 'sharedAction';

 

The content was successfully shared.

------------------------------------------------------------------------

 dismissedAction

iOS



    static dismissedAction: 'dismissedAction';

 

The dialog has been dismissed.

# 🚧 Slider #
  /\/\    __   ____  _ _     _           
  >  <  _/ _) / ___|| (_) __| | ___ _ __ 
 _\/\ |/ \ \  \___ \| | |/ _` |/ _ \ '__|
/ __` |\ \\ \  ___) | | | (_| |  __/ |   
\____/  \ \_/ |____/|_|_|\__,_|\___|_|   
       (__/                              
-   Props
    -    style
    -    disabled
    -    maximumValue
    -    minimumTrackTintColor
    -    minimumValue
    -    onSlidingComplete
    -    onValueChange
    -    step
    -    maximumTrackTintColor
    -    testID
    -    value
    -    thumbTintColor
    -    maximumTrackImage
    -    minimumTrackImage
    -    thumbImage
    -    trackImage
🚧 Slider

  Deprecated. Use one of the community packages instead.

A component used to select a single value from a range of values.

------------------------------------------------------------------------

Reference

Props 

Inherits View Props .

 style 

Used to style and layout the  Slider . See  StyleSheet.js and
 ViewStylePropTypes.js for more info.

  Type         Required
  ------------ ----------
  View.style   No

------------------------------------------------------------------------

 disabled 

If true the user won't be able to move the slider. Default value is
false.

  Type   Required
  ------ ----------
  bool   No

------------------------------------------------------------------------

 maximumValue 

Initial maximum value of the slider. Default value is 1.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 minimumTrackTintColor 

The color used for the track to the left of the button. Overrides the
default blue gradient image on iOS.

  Type    Required
  ------- ----------
  color   No

------------------------------------------------------------------------

 minimumValue 

Initial minimum value of the slider. Default value is 0.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 onSlidingComplete 

Callback that is called when the user releases the slider, regardless if
the value has changed. The current value is passed as an argument to the
callback handler.

  Type       Required
  ---------- ----------
  function   No

------------------------------------------------------------------------

 onValueChange 

Callback continuously called while the user is dragging the slider.

  Type       Required
  ---------- ----------
  function   No

------------------------------------------------------------------------

 step 

Step value of the slider. The value should be between 0 and
(maximumValue - minimumValue). Default value is 0.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 maximumTrackTintColor 

The color used for the track to the right of the button. Overrides the
default gray gradient image on iOS.

  Type    Required
  ------- ----------
  color   No

------------------------------------------------------------------------

 testID 

Used to locate this view in UI automation tests.

  Type     Required
  -------- ----------
  string   No

------------------------------------------------------------------------

 value 

Initial value of the slider. The value should be between minimumValue
and maximumValue, which default to 0 and 1 respectively. Default value
is 0.

This is not a controlled component , you don't need to update the value
during dragging.

  Type     Required
  -------- ----------
  number   No

------------------------------------------------------------------------

 thumbTintColor 

The color used to tint the default thumb images on iOS, or the color of
the foreground switch grip on Android.

  Type    Required
  ------- ----------
  color   No

------------------------------------------------------------------------

 maximumTrackImage 

Assigns a maximum track image. Only static images are supported. The
leftmost pixel of the image will be stretched to fill the track.

  Type                     Required   Platform
  ------------------------ ---------- ----------
  Image.propTypes.source   No         iOS

------------------------------------------------------------------------

 minimumTrackImage 

Assigns a minimum track image. Only static images are supported. The
rightmost pixel of the image will be stretched to fill the track.

  Type                     Required   Platform
  ------------------------ ---------- ----------
  Image.propTypes.source   No         iOS

------------------------------------------------------------------------

 thumbImage 

Sets an image for the thumb. Only static images are supported.

  Type                     Required   Platform
  ------------------------ ---------- ----------
  Image.propTypes.source   No         iOS

------------------------------------------------------------------------

 trackImage 

Assigns a single image for the track. Only static images are supported.
The center pixel of the image will be stretched to fill the track.

  Type                     Required   Platform
  ------------------------ ---------- ----------
  Image.propTypes.source   No         iOS

# Speeding Up CI Builds #
 ____                      _ _               _   _          ____ ___ 
/ ___| _ __   ___  ___  __| (_)_ __   __ _  | | | |_ __    / ___|_ _|
\___ \| '_ \ / _ \/ _ \/ _` | | '_ \ / _` | | | | | '_ \  | |    | | 
 ___) | |_) |  __/  __/ (_| | | | | | (_| | | |_| | |_) | | |___ | | 
|____/| .__/ \___|\___|\__,_|_|_| |_|\__, |  \___/| .__/   \____|___|
      |_|                            |___/        |_|                
 ____        _ _     _     
| __ ) _   _(_) | __| |___ 
|  _ \| | | | | |/ _` / __|
| |_) | |_| | | | (_| \__ \
|____/ \__,_|_|_|\__,_|___/
                           
-   Disable Flipper for iOS
    -   Handle Transitive Dependencies
Speeding Up CI Builds

You or your company may have set up a Continuous Integration (CI)
environment to test your React Native application.

A fast CI service is important for 2 reasons:

-   The more time CI machines are running, the more they cost.
-   The longer the CI jobs take to run, the longer the development loop.

It is therefore important to try and minimize the time the CI
environment spends building React Native.

Disable Flipper for iOS 

Flipper is a debugging tool shipped by default with React Native, to
help developers debug and profile their React Native applications.
However, Flipper is not required in CI: it is very unlikely that you or
one of your collegue would have to debug the app built in the CI
environment.

For iOS apps, Flipper is built every time the React Native framework is
built and it may require some time to build, and this is time you can
save.

Starting from React Native 0.71, we introduced a new flag in the
template's Podfile: the  NO_FLIPPER flag .

By default, the  NO_FLIPPER flag is not set, therefore Flipper will be
included by default in your app.

You can specify  NO_FLIPPER=1 when installing your iOS pods, to instruct
React Native not to install Flipper. Typically, the command would look
like this:

    # from the root folder of the react native project
    NO_FLIPPER=1 bundle exec pod install --project-directory=ios

 

Add this command in your CI environment to skip the installation of
Flipper dependencies and thus saving time and money.

Handle Transitive Dependencies 

Your app may be using some libraries which depends on the Flipper pods.
If that's your case, disabling flipper with the  NO_FLIPPER flag may not
be enough: your app may fail to build in this case.

The proper way to handle this case is to add a custom configuration for
react native, instructing the app to properly install the transitive
dependency. To achieve that:

1.  If you don't have it already, create a new file called
     react-native.config.js .
2.  Exclude explicitly the transitive dependency from the  dependency
    when the flag is turned on.

For example, the  react-native-flipper library is an additional library
that depends on Flipper. If your app uses that, you need to exclude it
from the dependencies. Your  react-native.config.js would look like
this:

react-native.config.js

    module.exports = {
      // other fields
      dependency: {
        ...(process.env.NO_FLIPPER
          ? {'react-native-flipper': {platforms: {ios: null}}}
          : {}),
      },
    };

 

# Speeding up your Build phase #
 ____                      _ _                           
/ ___| _ __   ___  ___  __| (_)_ __   __ _   _   _ _ __  
\___ \| '_ \ / _ \/ _ \/ _` | | '_ \ / _` | | | | | '_ \ 
 ___) | |_) |  __/  __/ (_| | | | | | (_| | | |_| | |_) |
|____/| .__/ \___|\___|\__,_|_|_| |_|\__, |  \__,_| .__/ 
      |_|                            |___/        |_|    
                          ____        _ _     _         _                    
 _   _  ___  _   _ _ __  | __ ) _   _(_) | __| |  _ __ | |__   __ _ ___  ___ 
| | | |/ _ \| | | | '__| |  _ \| | | | | |/ _` | | '_ \| '_ \ / _` / __|/ _ \
| |_| | (_) | |_| | |    | |_) | |_| | | | (_| | | |_) | | | | (_| \__ \  __/
 \__, |\___/ \__,_|_|    |____/ \__,_|_|_|\__,_| | .__/|_| |_|\__,_|___/\___|
 |___/                                           |_|                         
-   Build only one ABI during development (Android-only)
-   Use a compiler cache
    -   Local caches
    -   Distributed caches
Speeding up your Build phase

Building your React Native app could be expensive and take several
minutes of developers time. This can be problematic as your project
grows and generally in bigger organizations with multiple React Native
developers.

To mitigate this performance hit, this page shares some suggestions on
how to improve your build time .

 info

If you're noticing slower build time with the New Architecture on
Android , we recommend to upgrade to React Native 0.71

Build only one ABI during development (Android-only) 

When building your android app locally, by default you build all the 4
Application Binary Interfaces (ABIs) :  armeabi-v7a ,  arm64-v8a ,  x86
&  x86_64 .

However, you probably don't need to build all of them if you're building
locally and testing your emulator or on a physical device.

This should reduce your native build time by a ~75% factor.

If you're using the React Native CLI, you can add the
 --active-arch-only flag to the  run-android command. This flag will
make sure the correct ABI is picked up from either the running emulator
or the plugged in phone. To confirm that this approach is working fine,
you'll see a message like  info Detected architectures arm64-v8a on
console.

    $ yarn react-native run-android --active-arch-only

    [ ... ]
    info Running jetifier to migrate libraries to AndroidX. You can disable it using "--no-jetifier" flag.
    Jetifier found 1037 file(s) to forward-jetify. Using 32 workers...
    info JS server already running.
    info Detected architectures arm64-v8a
    info Installing the app...

 

This mechanism relies on the  reactNativeArchitectures Gradle property.

Therefore, if you're building directly with Gradle from the command line
and without the CLI, you can specify the ABI you want to build as
follows:

    $ ./gradlew :app:assembleDebug -PreactNativeArchitectures=x86,x86_64

 

This can be useful if you wish to build your Android App on a CI and use
a matrix to parallelize the build of the different architectures.

If you wish, you can also override this value locally, using the
 gradle.properties file you have in the top-level folder of your
project:

    # Use this property to specify which architecture you want to build.
    # You can also override it from the CLI using
    # ./gradlew <task> -PreactNativeArchitectures=x86_64
    reactNativeArchitectures=armeabi-v7a,arm64-v8a,x86,x86_64

 

Once you build a release version of your app, don't forget to remove
those flags as you want to build an apk/app bundle that works for all
the ABIs and not only for the one you're using in your daily development
workflow.

Use a compiler cache 

If you're running frequent native builds (either C++ or Objective-C),
you might benefit from using a compiler cache .

Specifically you can use two type of caches: local compiler caches and
distributed compiler caches.

Local caches 

 info

The following instructions will work for both Android & iOS . If you're
building only Android apps, you should be good to go. If you're building
also iOS apps, please follow the instructions in the XCode Specific
Setup section below.

We suggest to use ccache to cache the compilation of your native builds.
Ccache works by wrapping the C++ compilers, storing the compilation
results, and skipping the compilation if an intermediate compilation
result was originally stored.

To install it, you can follow the official installation instructions .

On macOS, we can install ccache with  brew install ccache . Once
installed you can configure it as follows to cache NDK compile results:

    ln -s $(which ccache) /usr/local/bin/gcc
    ln -s $(which ccache) /usr/local/bin/g++
    ln -s $(which ccache) /usr/local/bin/cc
    ln -s $(which ccache) /usr/local/bin/c++
    ln -s $(which ccache) /usr/local/bin/clang
    ln -s $(which ccache) /usr/local/bin/clang++

 

This will create symbolic links to  ccache inside the  /usr/local/bin/
which are called  gcc ,  g++ , and so on.

This works as long as  /usr/local/bin/ comes first than  /usr/bin/
inside your  $PATH variable, which is the default.

You can verify that it works using the  which command:

    $ which gcc
    /usr/local/bin/gcc

 

If the results is  /usr/local/bin/gcc , then you're effectively calling
 ccache which will wrap the  gcc calls.

 caution

Please note that this setup of  ccache will affect all the compilations
that you're running on your machine, not only those related to React
Native. Use it at your own risk. If you're failing to install/compile
other software, this might be the reason. If that is the case, you can
remove the symlink you created with:

    unlink /usr/local/bin/gcc
    unlink /usr/local/bin/g++
    unlink /usr/local/bin/cc
    unlink /usr/local/bin/c++
    unlink /usr/local/bin/clang
    unlink /usr/local/bin/clang++

 

to revert your machine to the original status and use the default
compilers.

You can then do two clean builds (e.g. on Android you can first run
 yarn react-native run-android , delete the  android/app/build folder
and run the first command once more). You will notice that the second
build was way faster than the first one (it should take seconds rather
than minutes). While building, you can verify that  ccache works
correctly and check the cache hits/miss rate  ccache -s

    $ ccache -s
    Summary:
      Hits:             196 /  3068 (6.39 %)
        Direct:           0 /  3068 (0.00 %)
        Preprocessed:   196 /  3068 (6.39 %)
      Misses:          2872
        Direct:        3068
        Preprocessed:  2872
      Uncacheable:        1
    Primary storage:
      Hits:             196 /  6136 (3.19 %)
      Misses:          5940
      Cache size (GB): 0.60 / 20.00 (3.00 %)

 

Note that  ccache aggregates the stats over all builds. You can use
 ccache --zero-stats to reset them before a build to verify the
cache-hit ratio.

Should you need to wipe your cache, you can do so with  ccache --clear

XCode Specific Setup 

To make sure  ccache works correctly with iOS and XCode, you need to
follow a couple of extra steps:

1.  You must alter the way Xcode and  xcodebuild call for the compiler
    command. By default they use fully specified paths to the compiler
    binaries, so the symbolic links installed in  /usr/local/bin will
    not be used. You may configure Xcode to use relative names for the
    compilers using either of these two options:

-   environment variables prefixed on the command line if you use a
    direct command line:
     CLANG=clang CLANGPLUSPLUS=clang++ LD=clang LDPLUSPLUS=clang++ xcodebuild <rest of xcodebuild command line>
-   A  post_install section in your  ios/Podfile that alters the
    compiler in your Xcode workspace during the  pod install step:

      post_install do |installer|
        react_native_post_install(installer)

        # ...possibly other post_install items here

        installer.pods_project.targets.each do |target|
          target.build_configurations.each do |config|
            # Using the un-qualified names means you can swap in different implementations, for example ccache
            config.build_settings["CC"] = "clang"
            config.build_settings["LD"] = "clang"
            config.build_settings["CXX"] = "clang++"
            config.build_settings["LDPLUSPLUS"] = "clang++"
          end
        end

        __apply_Xcode_12_5_M1_post_install_workaround(installer)
      end

 

2.  You need a ccache configuration that allows for a certain level of
    sloppiness and cache behavior such that ccache registers cache hits
    during Xcode compiles. The ccache configuration variables that are
    different from standard are as follows if configured by environment
    variable:

    export CCACHE_SLOPPINESS=clang_index_store,file_stat_matches,include_file_ctime,include_file_mtime,ivfsoverlay,pch_defines,modules,system_headers,time_macros
    export CCACHE_FILECLONE=true
    export CCACHE_DEPEND=true
    export CCACHE_INODECACHE=true

 

The same may be configured in a  ccache.conf file or any other mechanism
ccache provides. More on this can be found in the official ccache manual
.

Using this approach on a CI 

Ccache uses the  /Users/$USER/Library/Caches/ccache folder on macOS to
store the cache. Therefore you could save & restore the corresponding
folder also on CI to speedup your builds.

However, there are a couple of things to be aware:

1.  On CI, we recommend to do a full clean build, to avoid poisoned
    cache problems. If you follow the approach mentioned in the previous
    paragraph, you should be able to parallelize the native build on 4
    different ABIs and you will most likely not need  ccache on CI.

2.   ccache relies on timestamps to compute a cache hit. This doesn't
    work well on CI as files are re-downloaded at every CI run. To
    overcome this, you'll need to use the  compiler_check content option
    which relies instead on hashing the content of the file .

Distributed caches 

Similar to local caches, you might want to consider using a distributed
cache for your native builds. This could be specifically useful in
bigger organizations that are doing frequent native builds.

We recommend to use sccache to achieve this. We defer to the sccache
distributed compilation quickstart for instructions on how to setup and
use this tool.

# State #
 ____  _        _       
/ ___|| |_ __ _| |_ ___ 
\___ \| __/ _` | __/ _ \
 ___) | || (_| | ||  __/
|____/ \__\__,_|\__\___|
                        

State

There are two types of data that control a component:  props and  state
.  props are set by the parent and they are fixed throughout the
lifetime of a component. For data that is going to change, we have to
use  state .

In general, you should initialize  state in the constructor, and then
call  setState when you want to change it.

For example, let's say we want to make text that blinks all the time.
The text itself gets set once when the blinking component gets created,
so the text itself is a  prop . The "whether the text is currently on or
off" changes over time, so that should be kept in  state .

-   TypeScript
-   JavaScript

In a real application, you probably won't be setting state with a timer.
You might set state when you have new data from the server, or from user
input. You can also use a state container like Redux or MobX to control
your data flow. In that case you would use Redux or MobX to modify your
state rather than calling  setState directly.

When setState is called, BlinkApp will re-render its Component. By
calling setState within the Timer, the component will re-render every
time the Timer ticks.

State works the same way as it does in React, so for more details on
handling state, you can look at the React.Component API . At this point,
you may have noticed that most of our examples use the default text
color. To customize the text color, you will have to learn about Style .

# StatusBar #
 ____  _        _             ____             
/ ___|| |_ __ _| |_ _   _ ___| __ )  __ _ _ __ 
\___ \| __/ _` | __| | | / __|  _ \ / _` | '__|
 ___) | || (_| | |_| |_| \__ \ |_) | (_| | |   
|____/ \__\__,_|\__|\__,_|___/____/ \__,_|_|   
                                               
-   Usage with Navigator
-   Imperative API
-   Constants
    -    currentHeight
        Android
-   Props
    -    animated
    -    backgroundColor
        Android
    -    barStyle
    -    hidden
    -    networkActivityIndicatorVisible
        iOS
    -    showHideTransition
        iOS
    -    translucent
        Android
-   Methods
    -    popStackEntry()
    -    pushStackEntry()
    -    replaceStackEntry()
    -    setBackgroundColor()
        Android
    -    setBarStyle()
    -    setHidden()
    -    setNetworkActivityIndicatorVisible()
        iOS
    -    setTranslucent()
        Android
-   Type Definitions
    -   StatusBarAnimation
    -   StatusBarStyle
StatusBar

Component to control the app's status bar. The status bar is the zone,
typically at the top of the screen, that displays the current time,
Wi-Fi and cellular network information, battery level and/or other
status icons.

Usage with Navigator 

It is possible to have multiple  StatusBar components mounted at the
same time. The props will be merged in the order the  StatusBar
components were mounted.

-   TypeScript
-   JavaScript

Imperative API 

For cases where using a component is not ideal, there is also an
imperative API exposed as static functions on the component. It is
however not recommended to use the static API and the component for the
same prop because any value set by the static API will get overridden by
the one set by the component in the next render.

------------------------------------------------------------------------

Reference

Constants 

 currentHeight

Android



The height of the status bar, which includes the notch height, if
present.

------------------------------------------------------------------------

Props 

 animated 

If the transition between status bar property changes should be
animated. Supported for  backgroundColor ,  barStyle and  hidden
properties.

  Type      Required   Default
  --------- ---------- ---------
  boolean   No          false

------------------------------------------------------------------------

 backgroundColor

Android



The background color of the status bar.

  Type    Required   Default
  ------- ---------- -----------------------------------------------------------------------
  color   No         default system StatusBar background color, or  'black' if not defined

------------------------------------------------------------------------

 barStyle 

Sets the color of the status bar text.

On Android, this will only have an impact on API versions 23 and above.

  Type             Required   Default
  ---------------- ---------- ------------
  StatusBarStyle   No          'default'

------------------------------------------------------------------------

 hidden 

If the status bar is hidden.

  Type      Required   Default
  --------- ---------- ---------
  boolean   No          false

------------------------------------------------------------------------

 networkActivityIndicatorVisible

iOS



If the network activity indicator should be visible.

  Type      Default
  --------- ---------
  boolean    false

------------------------------------------------------------------------

 showHideTransition

iOS



The transition effect when showing and hiding the status bar using the
 hidden prop.

  Type                 Default
  -------------------- ---------
  StatusBarAnimation    'fade'

------------------------------------------------------------------------

 translucent

Android



If the status bar is translucent. When translucent is set to  true , the
app will draw under the status bar. This is useful when using a semi
transparent status bar color.

  Type      Default
  --------- ---------
  boolean    false

Methods 

 popStackEntry() 

    static popStackEntry(entry: StatusBarProps);

 

Get and remove the last StatusBar entry from the stack.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| entry                 | any                   | Entry returned from   |
|                       |                       |  pushStackEntry .     |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 pushStackEntry() 

    static pushStackEntry(props: StatusBarProps): StatusBarProps;

 

Push a StatusBar entry onto the stack. The return value should be passed
to  popStackEntry when complete.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| props                 | any                   | Object containing the |
|                       |                       | StatusBar props to    |
| Required              |                       | use in the stack      |
|                       |                       | entry.                |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 replaceStackEntry() 

    static replaceStackEntry(
      entry: StatusBarProps,
      props: StatusBarProps
    ): StatusBarProps;

 

Replace an existing StatusBar stack entry with new props.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| entry                 | any                   | Entry returned from   |
|                       |                       |  pushStackEntry to    |
| Required              |                       | replace.              |
+-----------------------+-----------------------+-----------------------+
| props                 | any                   | Object containing the |
|                       |                       | StatusBar props to    |
| Required              |                       | use in the            |
|                       |                       | replacement stack     |
|                       |                       | entry.                |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 setBackgroundColor()

Android



    static setBackgroundColor(color: ColorValue, animated?: boolean);

 

Set the background color for the status bar.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| color                 | string                | Background color.     |
|                       |                       |                       |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+
| animated              | boolean               | Animate the style     |
|                       |                       | change.               |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 setBarStyle() 

    static setBarStyle(style: StatusBarStyle, animated?: boolean);

 

Set the status bar style.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| style                 | StatusBarStyle        | Status bar style to   |
|                       |                       | set.                  |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+
| animated              | boolean               | Animate the style     |
|                       |                       | change.               |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 setHidden() 

    static setHidden(hidden: boolean, animation?: StatusBarAnimation);

 

Show or hide the status bar.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| hidden                | boolean               | Hide the status bar.  |
|                       |                       |                       |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+
| animation             | StatusBarAnimation    | Animation when        |
|                       |                       | changing the status   |
| iOS                   |                       | bar hidden property.  |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 setNetworkActivityIndicatorVisible()

iOS



    static setNetworkActivityIndicatorVisible(visible: boolean);

 

Control the visibility of the network activity indicator.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| visible               | boolean               | Show the indicator.   |
|                       |                       |                       |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+

------------------------------------------------------------------------

 setTranslucent()

Android



    static setTranslucent(translucent: boolean);

 

Control the translucency of the status bar.

Parameters:

+-----------------------+-----------------------+-----------------------+
| Name                  | Type                  | Description           |
+=======================+=======================+=======================+
| translucent           | boolean               | Set as translucent.   |
|                       |                       |                       |
| Required              |                       |                       |
+-----------------------+-----------------------+-----------------------+

Type Definitions 

StatusBarAnimation 

Status bar animation type for transitions on the iOS.

  Type
  ------
  enum

Constants:

  Value      Type     Description
  ---------- -------- -----------------
   'fade'    string   Fade animation
   'slide'   string   Slide animation
   'none'    string   No animation

------------------------------------------------------------------------

StatusBarStyle 

Status bar style type.

  Type
  ------
  enum

Constants:

  Value              Type     Description
  ------------------ -------- ------------------------------------------------------------
   'default'         string   Default status bar style (dark for iOS, light for Android)
   'light-content'   string   White texts and icons
   'dark-content'    string   Dark texts and icons (requires API>=23 on Android)

# Style #
 ____  _         _      
/ ___|| |_ _   _| | ___ 
\___ \| __| | | | |/ _ \
 ___) | |_| |_| | |  __/
|____/ \__|\__, |_|\___|
           |___/        
-   Known issues
Style

With React Native, you style your application using JavaScript. All of
the core components accept a prop named  style . The style names and
values usually match how CSS works on the web, except names are written
using camel casing, e.g.  backgroundColor rather than  background-color
.

The  style prop can be a plain old JavaScript object. That's what we
usually use for example code. You can also pass an array of styles - the
last style in the array has precedence, so you can use this to inherit
styles.

As a component grows in complexity, it is often cleaner to use
 StyleSheet.create to define several styles in one place. Here's an
example:

One common pattern is to make your component accept a  style prop which
in turn is used to style subcomponents. You can use this to make styles
"cascade" the way they do in CSS.

There are a lot more ways to customize the text style. Check out the
Text component reference for a complete list.

Now you can make your text beautiful. The next step in becoming a style
expert is to learn how to control component size .

Known issues 

-   react-native#29308 : In some cases React Native does not match how
    CSS works on the web, for example the touch area never extends past
    the parent view bounds and on Android negative margin is not
    supported.

# StyleSheet #
 ____  _         _      ____  _               _   
/ ___|| |_ _   _| | ___/ ___|| |__   ___  ___| |_ 
\___ \| __| | | | |/ _ \___ \| '_ \ / _ \/ _ \ __|
 ___) | |_| |_| | |  __/___) | | | |  __/  __/ |_ 
|____/ \__|\__, |_|\___|____/|_| |_|\___|\___|\__|
           |___/                                  
-   Methods
    -    compose()
    -    create()
    -    flatten()
    -    setStyleAttributePreprocessor()
-   Properties
    -    absoluteFill
    -    absoluteFillObject
    -    hairlineWidth
StyleSheet

A StyleSheet is an abstraction similar to CSS StyleSheets

Code quality tips:

-   By moving styles away from the render function, you're making the
    code easier to understand.
-   Naming the styles is a good way to add meaning to the low level
    components in the render function.

------------------------------------------------------------------------

Reference

Methods 

 compose() 

    static compose(style1: Object, style2: Object): Object | Object;

 

Combines two styles such that  style2 will override any styles in
 style1 . If either style is falsy, the other one is returned without
allocating an array, saving allocations and maintaining reference
equality for PureComponent checks.

------------------------------------------------------------------------

 create() 

    static create(styles: Object): Object;

 

Creates a StyleSheet style reference from the given object.

------------------------------------------------------------------------

 flatten() 

    static flatten(style: Object): Object;

 

Flattens an array of style objects, into one aggregated style object.
Alternatively, this method can be used to lookup IDs, returned by
 StyleSheet.register .

  NOTE: Exercise caution as abusing this can tax you in terms of
  optimizations. IDs enable optimizations through the bridge and memory
  in general. Referring to style objects directly will deprive you of
  these optimizations.

This method internally uses  StyleSheetRegistry.getStyleByID(style) to
resolve style objects represented by IDs. Thus, an array of style
objects (instances of  StyleSheet.create() ), are individually resolved
to, their respective objects, merged as one and then returned. This also
explains the alternative use.

------------------------------------------------------------------------

 setStyleAttributePreprocessor() 

  WARNING: EXPERIMENTAL. Breaking changes will probably happen a lot and
  will not be reliably announced. The whole thing might be deleted, who
  knows? Use at your own risk.

    static setStyleAttributePreprocessor(
      property: string,
      process: (propValue: any) => any,
    );

 

Sets a function to use to pre-process a style property value. This is
used internally to process color and transform values. You should not
use this unless you really know what you are doing and have exhausted
other options.

Properties 

------------------------------------------------------------------------

 absoluteFill 

A very common pattern is to create overlays with position absolute and
zero positioning (
 position: 'absolute', left: 0, right: 0, top: 0, bottom: 0 ), so
 absoluteFill can be used for convenience and to reduce duplication of
these repeated styles. If you want, absoluteFill can be used to create a
customized entry in a StyleSheet, e.g.:

------------------------------------------------------------------------

 absoluteFillObject 

Sometimes you may want  absoluteFill but with a couple tweaks -
 absoluteFillObject can be used to create a customized entry in a
 StyleSheet , e.g.:

------------------------------------------------------------------------

 hairlineWidth 

This is defined as the width of a thin line on the platform. It can be
used as the thickness of a border or division between two elements.
Example:

This constant will always be a round number of pixels (so a line defined
by it can look crisp) and will try to match the standard width of a thin
line on the underlying platform. However, you should not rely on it
being a constant size, because on different platforms and screen
densities its value may be calculated differently.

A line with hairline width may not be visible if your simulator is
downscaled.

# Switch #
 ____          _ _       _     
/ ___|_      _(_) |_ ___| |__  
\___ \ \ /\ / / | __/ __| '_ \ 
 ___) \ V  V /| | || (__| | | |
|____/ \_/\_/ |_|\__\___|_| |_|
                               
-   Example
-   Props
    -   View Props
    -    disabled
    -    ios_backgroundColor
        iOS
    -    onChange
    -    onValueChange
    -    thumbColor
    -    trackColor
    -    value
Switch

Renders a boolean input.

This is a controlled component that requires an  onValueChange callback
that updates the  value prop in order for the component to reflect user
actions. If the  value prop is not updated, the component will continue
to render the supplied  value prop instead of the expected result of any
user actions.

Example 

------------------------------------------------------------------------

Reference

Props 

View Props 

Inherits View Props .

------------------------------------------------------------------------

 disabled 

If true the user won't be able to toggle the switch.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 ios_backgroundColor

iOS



On iOS, custom color for the background. This background color can be
seen either when the switch value is  false or when the switch is
disabled (and the switch is translucent).

  Type
  -------
  color

------------------------------------------------------------------------

 onChange 

Invoked when the user tries to change the value of the switch. Receives
the change event as an argument. If you want to only receive the new
value, use  onValueChange instead.

  Type
  ----------
  function

------------------------------------------------------------------------

 onValueChange 

Invoked when the user tries to change the value of the switch. Receives
the new value as an argument. If you want to instead receive an event,
use  onChange .

  Type
  ----------
  function

------------------------------------------------------------------------

 thumbColor 

Color of the foreground switch grip. If this is set on iOS, the switch
grip will lose its drop shadow.

  Type
  -------
  color

------------------------------------------------------------------------

 trackColor 

Custom colors for the switch track.

iOS : When the switch value is  false , the track shrinks into the
border. If you want to change the color of the background exposed by the
shrunken track, use  ios_backgroundColor .

  Type
  --------------------------------------------
   object: {false:  color  , true:  color  }

------------------------------------------------------------------------

 value 

The value of the switch. If true the switch will be turned on. Default
value is false.

  Type
  ------
  bool

# Systrace #
 ____            _                      
/ ___| _   _ ___| |_ _ __ __ _  ___ ___ 
\___ \| | | / __| __| '__/ _` |/ __/ _ \
 ___) | |_| \__ \ |_| | | (_| | (_|  __/
|____/ \__, |___/\__|_|  \__,_|\___\___|
       |___/                            
-   Example
-   Methods
    -    isEnabled()
    -    beginEvent()
    -    endEvent()
    -    beginAsyncEvent()
    -    endAsyncEvent()
    -    counterEvent()
Systrace

 Systrace is a standard Android marker-based profiling tool (and is
installed when you install the Android platform-tools package). Profiled
code blocks are surrounded by start/end markers which are then
visualized in a colorful chart format. Both the Android SDK and React
Native framework provide standard markers that you can visualize.

Example 

 Systrace allows you to mark JavaScript (JS) events with a tag and an
integer value. Capture the non-Timed JS events in EasyProfiler.

------------------------------------------------------------------------

Reference

Methods 

 isEnabled() 

    static isEnabled(): boolean;

 

------------------------------------------------------------------------

 beginEvent() 

    static beginEvent(eventName: string | (() => string), args?: EventArgs);

 

beginEvent/endEvent for starting and then ending a profile within the
same call stack frame.

------------------------------------------------------------------------

 endEvent() 

    static endEvent(args?: EventArgs);

 

------------------------------------------------------------------------

 beginAsyncEvent() 

    static beginAsyncEvent(
      eventName: string | (() => string),
      args?: EventArgs,
    ): number;

 

beginAsyncEvent/endAsyncEvent for starting and then ending a profile
where the end can either occur on another thread or out of the current
stack frame, eg await the returned cookie variable should be used as
input into the endAsyncEvent call to end the profile.

------------------------------------------------------------------------

 endAsyncEvent() 

    static endAsyncEvent(
      eventName: EventName,
      cookie: number,
      args?: EventArgs,
    );

 

------------------------------------------------------------------------

 counterEvent() 

    static counterEvent(eventName: string | (() => string), value: number);

 

Register the value to the profileName on the systrace timeline.

# Testing #
 _____         _   _             
|_   _|__  ___| |_(_)_ __   __ _ 
  | |/ _ \/ __| __| | '_ \ / _` |
  | |  __/\__ \ |_| | | | | (_| |
  |_|\___||___/\__|_|_| |_|\__, |
                           |___/ 
-   Why Test
-   Static Analysis
-   Writing Testable Code
-   Writing Tests
    -   Structuring Tests
-   Unit Tests
    -   Mocking
-   Integration Tests
-   Component Tests
    -   Testing User Interactions
    -   Testing Rendered Output
-   End-to-End Tests
-   Summary
    -   Links
Testing

As your codebase expands, small errors and edge cases you don’t expect
can cascade into larger failures. Bugs lead to bad user experience and
ultimately, business losses. One way to prevent fragile programming is
to test your code before releasing it into the wild.

In this guide, we will cover different, automated ways to ensure your
app works as expected, ranging from static analysis to end-to-end tests.

[Testing is a cycle of fixing, testing, and either passing to release or
failing back into testing.]

Why Test 

We're humans, and humans make mistakes. Testing is important because it
helps you uncover these mistakes and verifies that your code is working.
Perhaps even more importantly, testing ensures that your code continues
to work in the future as you add new features, refactor the existing
ones, or upgrade major dependencies of your project.

There is more value in testing than you might realize. One of the best
ways to fix a bug in your code is to write a failing test that exposes
it. Then when you fix the bug and re-run the test, if it passes it means
the bug is fixed, never reintroduced into the code base.

Tests can also serve as documentation for new people joining your team.
For people who have never seen a codebase before, reading tests can help
them understand how the existing code works.

Last but not least, more automated testing means less time spent with
manual QA , freeing up valuable time.

Static Analysis 

The first step to improve your code quality is to start using static
analysis tools. Static analysis checks your code for errors as you write
it, but without running any of that code.

-   Linters analyze code to catch common errors such as unused code and
    to help avoid pitfalls, to flag style guide no-nos like using tabs
    instead of spaces (or vice versa, depending on your configuration).
-   Type checking ensures that the construct you’re passing to a
    function matches what the function was designed to accept,
    preventing passing a string to a counting function that expects a
    number, for instance.

React Native comes with two such tools configured out of the box: ESLint
for linting and TypeScript for type checking.

Writing Testable Code 

To start with tests, you first need to write code that is testable.
Consider an aircraft manufacturing process - before any model first
takes off to show that all of its complex systems work well together,
individual parts are tested to guarantee they are safe and function
correctly. For example, wings are tested by bending them under extreme
load; engine parts are tested for their durability; the windshield is
tested against simulated bird impact.

Software is similar. Instead of writing your entire program in one huge
file with many lines of code, you write your code in multiple small
modules that you can test more thoroughly than if you tested the
assembled whole. In this way, writing testable code is intertwined with
writing clean, modular code.

To make your app more testable, start by separating the view part of
your app—your React components—from your business logic and app state
(regardless of whether you use Redux, MobX or other solutions). This
way, you can keep your business logic testing—which shouldn’t rely on
your React components—independent of the components themselves, whose
job is primarily rendering your app’s UI!

Theoretically, you could go so far as to move all logic and data
fetching out of your components. This way your components would be
solely dedicated to rendering. Your state would be entirely independent
of your components. Your app’s logic would work without any React
components at all!

  We encourage you to further explore the topic of testable code in
  other learning resources.

Writing Tests 

After writing testable code, it’s time to write some actual tests! The
default template of React Native ships with Jest testing framework. It
includes a preset that's tailored to this environment so you can get
productive without tweaking the configuration and mocks straight away—
more on mocks shortly. You can use Jest to write all types of tests
featured in this guide.

  If you do test-driven development, you actually write tests first!
  That way, testability of your code is given.

Structuring Tests 

Your tests should be short and ideally test only one thing. Let's start
with an example unit test written with Jest:

    it('given a date in the past, colorForDueDate() returns red', () => {
      expect(colorForDueDate('2000-10-20')).toBe('red');
    });

 

The test is described by the string passed to the  it function. Take
good care writing the description so that it’s clear what is being
tested. Do your best to cover the following:

1.  Given - some precondition
2.  When - some action executed by the function that you’re testing
3.  Then - the expected outcome

This is also known as AAA (Arrange, Act, Assert).

Jest offers  describe function to help structure your tests. Use
 describe to group together all tests that belong to one functionality.
Describes can be nested, if you need that. Other functions you'll
commonly use are  beforeEach or  beforeAll that you can use for setting
up the objects you're testing. Read more in the Jest api reference .

If your test has many steps or many expectations, you probably want to
split it into multiple smaller ones. Also, ensure that your tests are
completely independent of one another. Each test in your suite must be
executable on its own without first running some other test. Conversely,
if you run all your tests together, the first test must not influence
the output of the second one.

Lastly, as developers we like when our code works great and doesn't
crash. With tests, this is often the opposite. Think of a failed test as
of a good thing! When a test fails, it often means something is not
right. This gives you an opportunity to fix the problem before it
impacts the users.

Unit Tests 

Unit tests cover the smallest parts of code, like individual functions
or classes.

When the object being tested has any dependencies, you’ll often need to
mock them out, as described in the next paragraph.

The great thing about unit tests is that they are quick to write and
run. Therefore, as you work, you get fast feedback about whether your
tests are passing. Jest even has an option to continuously run tests
that are related to code you’re editing: Watch mode .

[ ]

Mocking 

Sometimes, when your tested objects have external dependencies, you’ll
want to “mock them out.” “Mocking” is when you replace some dependency
of your code with your own implementation.

  Generally, using real objects in your tests is better than using mocks
  but there are situations where this is not possible. For example: when
  your JS unit test relies on a native module written in Java or
  Objective-C.

Imagine you’re writing an app that shows the current weather in your
city and you’re using some external service or other dependency that
provides you with the weather information. If the service tells you that
it’s raining, you want to show an image with a rainy cloud. You don’t
want to call that service in your tests, because:

-   It could make the tests slow and unstable (because of the network
    requests involved)
-   The service may return different data every time you run the test
-   Third party services can go offline when you really need to run
    tests!

Therefore, you can provide a mock implementation of the service,
effectively replacing thousands of lines of code and some
internet-connected thermometers!

  Jest comes with support for mocking from function level all the way to
  module level mocking.

Integration Tests 

When writing larger software systems, individual pieces of it need to
interact with each other. In unit testing, if your unit depends on
another one, you’ll sometimes end up mocking the dependency, replacing
it with a fake one.

In integration testing, real individual units are combined (same as in
your app) and tested together to ensure that their cooperation works as
expected. This is not to say that mocking does not happen here: you’ll
still need mocks (for example, to mock communication with a weather
service), but you'll need them much less than in unit testing.

  Please note that the terminology around what integration testing means
  is not always consistent. Also, the line between what is a unit test
  and what is an integration test may not always be clear. For this
  guide, your test falls into "integration testing" if it:

  -   Combines several modules of your app as described above
  -   Uses an external system
  -   Makes a network call to other application (such as the weather
      service API)
  -   Does any kind of file or database I/O

[ ]

Component Tests 

React components are responsible for rendering your app, and users will
directly interact with their output. Even if your app's business logic
has high testing coverage and is correct, without component tests you
may still deliver a broken UI to your users. Component tests could fall
into both unit and integration testing, but because they are such a core
part of React Native, we'll cover them separately.

For testing React components, there are two things you may want to test:

-   Interaction: to ensure the component behaves correctly when
    interacted with by a user (eg. when user presses a button)
-   Rendering: to ensure the component render output used by React is
    correct (eg. the button's appearance and placement in the UI)

For example, if you have a button that has an  onPress listener, you
want to test that the button both appears correctly and that tapping the
button is correctly handled by the component.

There are several libraries that can help you testing these:

-   React’s Test Renderer , developed alongside its core, provides a
    React renderer that can be used to render React components to pure
    JavaScript objects, without depending on the DOM or a native mobile
    environment.
-   React Native Testing Library builds on top of React’s test renderer
    and adds  fireEvent and  query APIs described in the next paragraph.

  Component tests are only JavaScript tests running in Node.js
  environment. They do not take into account any iOS, Android, or other
  platform code which is backing the React Native components. It follows
  that they cannot give you a 100% confidence that everything works for
  the user. If there is a bug in the iOS or Android code, they will not
  find it.

[ ]

Testing User Interactions 

Aside from rendering some UI, your components handle events like
 onChangeText for  TextInput or  onPress for  Button . They may also
contain other functions and event callbacks. Consider the following
example:

    function GroceryShoppingList() {
      const [groceryItem, setGroceryItem] = useState('');
      const [items, setItems] = useState<string>();

      const addNewItemToShoppingList = useCallback(() => {
        setItems([groceryItem, ...items]);
        setGroceryItem('');
      }, [groceryItem, items]);

      return (
        <>
          <TextInput
            value={groceryItem}
            placeholder="Enter grocery item"
            onChangeText={text => setGroceryItem(text)}
          />
          <Button
            title="Add the item to list"
            onPress={addNewItemToShoppingList}
          />
          {items.map(item => (
            <Text key={item}>{item}</Text>
          ))}
        </>
      );
    }

 

When testing user interactions, test the component from the user
perspective—what's on the page? What changes when interacted with?

As a rule of thumb, prefer using things users can see or hear:

-   make assertions using rendered text or accessibility helpers

Conversely, you should avoid:

-   making assertions on component props or state
-   testID queries

Avoid testing implementation details like props or state—while such
tests work, they are not oriented toward how users will interact with
the component and tend to break by refactoring (for example when you'd
like to rename some things or rewrite class component using hooks).

  React class components are especially prone to testing their
  implementation details such as internal state, props or event
  handlers. To avoid testing implementation details, prefer using
  function components with Hooks, which make relying on component
  internals harder .

Component testing libraries such as React Native Testing Library
facilitate writing user-centric tests by careful choice of provided
APIs. The following example uses  fireEvent methods  changeText and
 press that simulate a user interacting with the component and a query
function  getAllByText that finds matching  Text nodes in the rendered
output.

    test('given empty GroceryShoppingList, user can add an item to it', () => {
      const {getByPlaceholderText, getByText, getAllByText} = render(
        <GroceryShoppingList />,
      );

      fireEvent.changeText(
        getByPlaceholderText('Enter grocery item'),
        'banana',
      );
      fireEvent.press(getByText('Add the item to list'));

      const bananaElements = getAllByText('banana');
      expect(bananaElements).toHaveLength(1); // expect 'banana' to be on the list
    });

 

This example is not testing how some state changes when you call a
function. It tests what happens when a user changes text in the
 TextInput and presses the  Button !

Testing Rendered Output 

Snapshot testing is an advanced kind of testing enabled by Jest. It is a
very powerful and low-level tool, so extra attention is advised when
using it.

A "component snapshot" is a JSX-like string created by a custom React
serializer built into Jest. This serializer lets Jest translate React
component trees to string that's human-readable. Put another way: a
component snapshot is a textual representation of your component’s
render output generated during a test run. It may look like this:

    <Text
      style={
        Object {
          "fontSize": 20,
          "textAlign": "center",
        }
      }>
      Welcome to React Native!
    </Text>

 

With snapshot testing, you typically first implement your component and
then run the snapshot test. The snapshot test then creates a snapshot
and saves it to a file in your repo as a reference snapshot. The file is
then committed and checked during code review . Any future changes to
the component render output will change its snapshot, which will cause
the test to fail. You then need to update the stored reference snapshot
for the test to pass. That change again needs to be committed and
reviewed.

Snapshots have several weak points:

-   For you as a developer or reviewer, it can be hard to tell whether a
    change in snapshot is intended or whether it's evidence of a bug.
    Especially large snapshots can quickly become hard to understand and
    their added value becomes low.
-   When snapshot is created, at that point it is considered to be
    correct-even in the case when the rendered output is actually wrong.
-   When a snapshot fails, it's tempting to update it using the
     --updateSnapshot jest option without taking proper care to
    investigate whether the change is expected. Certain developer
    discipline is thus needed.

Snapshots themselves do not ensure that your component render logic is
correct, they are merely good at guarding against unexpected changes and
for checking that the components in the React tree under test receive
the expected props (styles and etc.).

We recommend that you only use small snapshots (see  no-large-snapshots
rule ). If you want to test a change between two React component states,
use  snapshot-diff . When in doubt, prefer explicit expectations as
described in the previous paragraph.

[ ]

End-to-End Tests 

In end-to-end (E2E) tests, you verify your app is working as expected on
a device (or a simulator / emulator) from the user perspective.

This is done by building your app in the release configuration and
running the tests against it. In E2E tests, you no longer think about
React components, React Native APIs, Redux stores or any business logic.
That is not the purpose of E2E tests and those are not even accessible
to you during E2E testing.

Instead, E2E testing libraries allow you to find and control elements in
the screen of your app: for example, you can actually tap buttons or
insert text into  TextInputs the same way a real user would. Then you
can make assertions about whether or not a certain element exists in the
app’s screen, whether or not it’s visible, what text it contains, and so
on.

E2E tests give you the highest possible confidence that part of your app
is working. The tradeoffs include:

-   writing them is more time consuming compared to the other types of
    tests
-   they are slower to run
-   they are more prone to flakiness (a "flaky" test is a test which
    randomly passes and fails without any change to code)

Try to cover the vital parts of your app with E2E tests: authentication
flow, core functionalities, payments, etc. Use faster JS tests for the
non-vital parts of your app. The more tests you add, the higher your
confidence, but also, the more time you'll spend maintaining and running
them. Consider the tradeoffs and decide what's best for you.

There are several E2E testing tools available: in the React Native
community, Detox is a popular framework because it’s tailored for React
Native apps. Another popular library in the space of iOS and Android
apps is Appium or Maestro .

[ ]

Summary 

We hope you enjoyed reading and learned something from this guide. There
are many ways you can test your apps. It may be hard to decide what to
use at first. However, we believe it all will make sense once you start
adding tests to your awesome React Native app. So what are you waiting
for? Get your coverage up!

Links 

-   React testing overview
-   React Native Testing Library
-   Jest docs
-   Detox
-   Appium
-   Maestro

------------------------------------------------------------------------

This guide originally authored and contributed in full by Vojtech Novak
.

# Text #
 _____         _   
|_   _|____  _| |_ 
  | |/ _ \ \/ / __|
  | |  __/>  <| |_ 
  |_|\___/_/\_\\__|
                   
-   Nested text
-   Containers
-   Limited Style Inheritance
-   Props
    -    accessibilityHint
    -    accessibilityLanguage
        iOS
    -    accessibilityLabel
    -    accessibilityRole
    -    accessibilityState
    -    accessibilityActions
    -    onAccessibilityAction
    -    accessible
    -    adjustsFontSizeToFit
    -    allowFontScaling
    -    android_hyphenationFrequency
        Android
    -    aria-busy
    -    aria-checked
    -    aria-disabled
    -    aria-expanded
    -    aria-label
    -    aria-selected
    -    dataDetectorType
        Android
    -    disabled
        Android
    -    dynamicTypeRamp
        iOS
    -    ellipsizeMode
    -    id
    -    maxFontSizeMultiplier
    -    minimumFontScale
        iOS
    -    nativeID
    -    numberOfLines
    -    onLayout
    -    onLongPress
    -    onMoveShouldSetResponder
    -    onPress
    -    onPressIn
    -    onPressOut
    -    onResponderGrant
    -    onResponderMove
    -    onResponderRelease
    -    onResponderTerminate
    -    onResponderTerminationRequest
    -    onStartShouldSetResponderCapture
    -    onTextLayout
    -    pressRetentionOffset
    -    role
    -    selectable
    -    selectionColor
        Android
    -    style
    -    suppressHighlighting
        iOS
    -    testID
    -    textBreakStrategy
        Android
    -    lineBreakStrategyIOS
        iOS
-   Type Definitions
    -   TextLayout
    -   TextLayoutEvent
Text

A React component for displaying text.

 Text supports nesting, styling, and touch handling.

In the following example, the nested title and body text will inherit
the  fontFamily from  styles.baseText , but the title provides its own
additional styles. The title and body will stack on top of each other on
account of the literal newlines:

Nested text 

Both Android and iOS allow you to display formatted text by annotating
ranges of a string with specific formatting like bold or colored text (
 NSAttributedString on iOS,  SpannableString on Android). In practice,
this is very tedious. For React Native, we decided to use web paradigm
for this where you can nest text to achieve the same effect.

Behind the scenes, React Native converts this to a flat
 NSAttributedString or  SpannableString that contains the following
information:

    "I am bold and red"
    0-9: bold
    9-17: bold, red

 

Containers 

The  <Text> element is unique relative to layout: everything inside is
no longer using the Flexbox layout but using text layout. This means
that elements inside of a  <Text> are no longer rectangles, but wrap
when they see the end of the line.

    <Text>
      <Text>First part and </Text>
      <Text>second part</Text>
    </Text>
    // Text container: the text will be inline if the space allowed it
    // |First part and second part|

    // otherwise, the text will flow as if it was one
    // |First part |
    // |and second |
    // |part       |

    <View>
      <Text>First part and </Text>
      <Text>second part</Text>
    </View>
    // View container: each text is its own block
    // |First part and|
    // |second part   |

    // otherwise, the text will flow in its own block
    // |First part |
    // |and        |
    // |second part|

 

Limited Style Inheritance 

On the web, the usual way to set a font family and size for the entire
document is to take advantage of inherited CSS properties like so:

    html {
      font-family: 'lucida grande', tahoma, verdana, arial, sans-serif;
      font-size: 11px;
      color: #141823;
    }

 

All elements in the document will inherit this font unless they or one
of their parents specifies a new rule.

In React Native, we are more strict about it: you must wrap all the text
nodes inside of a  <Text> component . You cannot have a text node
directly under a  <View> .

    // BAD: will raise exception, can't have a text node as child of a <View>
    <View>
      Some text
    </View>

    // GOOD
    <View>
      <Text>
        Some text
      </Text>
    </View>

 

You also lose the ability to set up a default font for an entire
subtree. Meanwhile,  fontFamily only accepts a single font name, which
is different from  font-family in CSS. The recommended way to use
consistent fonts and sizes across your application is to create a
component  MyAppText that includes them and use this component across
your app. You can also use this component to make more specific
components like  MyAppHeaderText for other kinds of text.

    <View>
      <MyAppText>
        Text styled with the default font for the entire application
      </MyAppText>
      <MyAppHeaderText>Text styled as a header</MyAppHeaderText>
    </View>

 

Assuming that  MyAppText is a component that only renders out its
children into a  Text component with styling, then  MyAppHeaderText can
be defined as follows:

    const MyAppHeaderText = ({children}) => {
      return (
        <MyAppText>
          <Text style={{fontSize: 20}}>{children}</Text>
        </MyAppText>
      );
    };

 

Composing  MyAppText in this way ensures that we get the styles from a
top-level component, but leaves us the ability to add / override them in
specific use cases.

React Native still has the concept of style inheritance, but limited to
text subtrees. In this case, the second part will be both bold and red.

    <Text style={{fontWeight: 'bold'}}>
      I am bold
      <Text style={{color: 'red'}}>and red</Text>
    </Text>

 

We believe that this more constrained way to style text will yield
better apps:

-   (Developer) React components are designed with strong isolation in
    mind: You should be able to drop a component anywhere in your
    application, trusting that as long as the props are the same, it
    will look and behave the same way. Text properties that could
    inherit from outside of the props would break this isolation.

-   (Implementor) The implementation of React Native is also simplified.
    We do not need to have a  fontFamily field on every single element,
    and we do not need to potentially traverse the tree up to the root
    every time we display a text node. The style inheritance is only
    encoded inside of the native Text component and doesn't leak to
    other components or the system itself.

------------------------------------------------------------------------

Reference

Props 

 accessibilityHint 

An accessibility hint helps users understand what will happen when they
perform an action on the accessibility element when that result is not
clear from the accessibility label.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityLanguage

iOS



A value indicating which language should be used by the screen reader
when the user interacts with the element. It should follow the BCP 47
specification .

See the iOS  accessibilityLanguage doc for more information.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityLabel 

Overrides the text that's read by the screen reader when the user
interacts with the element. By default, the label is constructed by
traversing all the children and accumulating all the  Text nodes
separated by space.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityRole 

Tells the screen reader to treat the currently focused on element as
having a specific role.

On iOS, these roles map to corresponding Accessibility Traits. Image
button has the same functionality as if the trait was set to both
'image' and 'button'. See the Accessibility guide for more information.

On Android, these roles have similar functionality on TalkBack as adding
Accessibility Traits does on Voiceover in iOS

  Type
  -------------------
  AccessibilityRole

------------------------------------------------------------------------

 accessibilityState 

Tells the screen reader to treat the currently focused on element as
being in a specific state.

You can provide one state, no state, or multiple states. The states must
be passed in through an object. Ex:  {selected: true, disabled: true} .

  Type
  --------------------
  AccessibilityState

------------------------------------------------------------------------

 accessibilityActions 

Accessibility actions allow an assistive technology to programmatically
invoke the actions of a component. The  accessibilityActions property
should contain a list of action objects. Each action object should
contain the field name and label.

See the Accessibility guide for more information.

  Type    Required
  ------- ----------
  array   No

------------------------------------------------------------------------

 onAccessibilityAction 

Invoked when the user performs the accessibility actions. The only
argument to this function is an event containing the name of the action
to perform.

See the Accessibility guide for more information.

  Type       Required
  ---------- ----------
  function   No

------------------------------------------------------------------------

 accessible 

When set to  true , indicates that the view is an accessibility element.

See the Accessibility guide for more information.

  Type      Default
  --------- ---------
  boolean    true

------------------------------------------------------------------------

 adjustsFontSizeToFit 

Specifies whether fonts should be scaled down automatically to fit given
style constraints.

  Type      Default
  --------- ---------
  boolean    false

------------------------------------------------------------------------

 allowFontScaling 

Specifies whether fonts should scale to respect Text Size accessibility
settings.

  Type      Default
  --------- ---------
  boolean    true

------------------------------------------------------------------------

 android_hyphenationFrequency

Android



Sets the frequency of automatic hyphenation to use when determining word
breaks on Android API Level 23+.

  Type                                    Default
  --------------------------------------- ---------
  enum(  'none' ,  'normal' ,  'full' )    'none'

------------------------------------------------------------------------

 aria-busy 

Indicates an element is being modified and that assistive technologies
may want to wait until the changes are complete before informing the
user about the update.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-checked 

Indicates the state of a checkable element. This field can either take a
boolean or the "mixed" string to represent mixed checkboxes.

  Type               Default
  ------------------ ---------
  boolean, 'mixed'   false

------------------------------------------------------------------------

 aria-disabled 

Indicates that the element is perceivable but disabled, so it is not
editable or otherwise operable.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-expanded 

Indicates whether an expandable element is currently expanded or
collapsed.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-label 

Defines a string value that labels an interactive element.

  Type
  --------
  string

------------------------------------------------------------------------

 aria-selected 

Indicates whether a selectable element is currently selected or not.

  Type
  ---------
  boolean

 dataDetectorType

Android



Determines the types of data converted to clickable URLs in the text
element. By default, no data types are detected.

You can provide only one type.

  Type                                                             Default
  ---------------------------------------------------------------- ---------
  enum(  'phoneNumber' ,  'link' ,  'email' ,  'none' ,  'all' )    'none'

------------------------------------------------------------------------

 disabled

Android



Specifies the disabled state of the text view for testing purposes.

  Type   Default
  ------ ---------
  bool    false

------------------------------------------------------------------------

 dynamicTypeRamp

iOS



The Dynamic Type ramp to apply to this element on iOS.

  Type                                                                                                                                                        Default
  ----------------------------------------------------------------------------------------------------------------------------------------------------------- ---------
  enum(  'caption2' ,  'caption1' ,  'footnote' ,  'subheadline' ,  'callout' ,  'body' ,  'headline' ,  'title3' ,  'title2' ,  'title1' ,  'largeTitle' )    'body'

------------------------------------------------------------------------

 ellipsizeMode 

When  numberOfLines is set, this prop defines how the text will be
truncated.  numberOfLines must be set in conjunction with this prop.

This can be one of the following values:

-    head - The line is displayed so that the end fits in the container
    and the missing text at the beginning of the line is indicated by an
    ellipsis glyph. e.g., "...wxyz"
-    middle - The line is displayed so that the beginning and end fit in
    the container and the missing text in the middle is indicated by an
    ellipsis glyph. "ab...yz"
-    tail - The line is displayed so that the beginning fits in the
    container and the missing text at the end of the line is indicated
    by an ellipsis glyph. e.g., "abcd..."
-    clip - Lines are not drawn past the edge of the text container.

  On Android, when  numberOfLines is set to a value higher than  1 ,
  only  tail value will work correctly.

  Type                                              Default
  ------------------------------------------------- ---------
  enum(  'head' ,  'middle' ,  'tail' ,  'clip' )    tail

------------------------------------------------------------------------

 id 

Used to locate this view from native code. Has precedence over  nativeID
prop.

  Type
  --------
  string

------------------------------------------------------------------------

 maxFontSizeMultiplier 

Specifies the largest possible scale a font can reach when
 allowFontScaling is enabled. Possible values:

-    null/undefined : inherit from the parent node or the global default
    (0)
-    0 : no max, ignore parent/global default
-    >= 1 : sets the  maxFontSizeMultiplier of this node to this value

  Type     Default
  -------- ------------
  number    undefined

------------------------------------------------------------------------

 minimumFontScale

iOS



Specifies the smallest possible scale a font can reach when
 adjustsFontSizeToFit is enabled. (values 0.01-1.0).

  Type
  --------
  number

------------------------------------------------------------------------

 nativeID 

Used to locate this view from native code.

  Type
  --------
  string

------------------------------------------------------------------------

 numberOfLines 

Used to truncate the text with an ellipsis after computing the text
layout, including line wrapping, such that the total number of lines
does not exceed this number. Setting this property to  0 will result in
unsetting this value, which means that no lines restriction will be
applied.

This prop is commonly used with  ellipsizeMode .

  Type     Default
  -------- ---------
  number    0

------------------------------------------------------------------------

 onLayout 

Invoked on mount and on layout changes.

  Type
  ------------------------------------------
   ({nativeEvent:  LayoutEvent  }) => void

------------------------------------------------------------------------

 onLongPress 

This function is called on long press.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onMoveShouldSetResponder 

Does this view want to "claim" touch responsiveness? This is called for
every touch move on the  View when it is not the responder.

  Type
  --------------------------------------------
   ({nativeEvent:  PressEvent  }) => boolean

------------------------------------------------------------------------

 onPress 

Function called on user press, triggered after  onPressOut .

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onPressIn 

Called immediately when a touch is engaged, before  onPressOut and
 onPress .

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onPressOut 

Called when a touch is released.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onResponderGrant 

The View is now responding to touch events. This is the time to
highlight and show the user what is happening.

On Android, return true from this callback to prevent any other native
components from becoming responder until this responder terminates.

  Type
  ----------------------------------------------------
   ({nativeEvent:  PressEvent  }) => void ｜ boolean

------------------------------------------------------------------------

 onResponderMove 

The user is moving their finger.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onResponderRelease 

Fired at the end of the touch.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onResponderTerminate 

The responder has been taken from the  View . Might be taken by other
views after a call to  onResponderTerminationRequest , or might be taken
by the OS without asking (e.g., happens with control center/
notification center on iOS)

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onResponderTerminationRequest 

Some other  View wants to become a responder and is asking this  View to
release its responder. Returning  true allows its release.

  Type
  --------------------------------------------
   ({nativeEvent:  PressEvent  }) => boolean

------------------------------------------------------------------------

 onStartShouldSetResponderCapture 

If a parent  View wants to prevent a child  View from becoming a
responder on a touch start, it should have this handler which returns
 true .

  Type
  --------------------------------------------
   ({nativeEvent:  PressEvent  }) => boolean

------------------------------------------------------------------------

 onTextLayout 

Invoked on Text layout change.

  Type
  -------------------------------
  (  TextLayoutEvent ) => mixed

------------------------------------------------------------------------

 pressRetentionOffset 

When the scroll view is disabled, this defines how far your touch may
move off of the button, before deactivating the button. Once
deactivated, try moving it back and you'll see that the button is once
again reactivated! Move it back and forth several times while the scroll
view is disabled. Ensure you pass in a constant to reduce memory
allocations.

  Type
  ---------------
  Rect , number

------------------------------------------------------------------------

 role 

 role communicates the purpose of a component to the user of an
assistive technology. Has precedence over the  accessibilityRole prop.

  Type
  ------
  Role

------------------------------------------------------------------------

 selectable 

Lets the user select text, to use the native copy and paste
functionality.

  Type      Default
  --------- ---------
  boolean    false

------------------------------------------------------------------------

 selectionColor

Android



The highlight color of the text.

  Type
  -------
  color

------------------------------------------------------------------------

 style 

  Type
  -------------------------------
  Text Style , View Style Props

------------------------------------------------------------------------

 suppressHighlighting

iOS



When  true , no visual change is made when text is pressed down. By
default, a gray oval highlights the text on press down.

  Type      Default
  --------- ---------
  boolean    false

------------------------------------------------------------------------

 testID 

Used to locate this view in end-to-end tests.

  Type
  --------
  string

------------------------------------------------------------------------

 textBreakStrategy

Android



Set text break strategy on Android API Level 23+, possible values are
 simple ,  highQuality ,  balanced .

  Type                                               Default
  -------------------------------------------------- --------------
  enum(  'simple' ,  'highQuality' ,  'balanced' )    highQuality

------------------------------------------------------------------------

 lineBreakStrategyIOS

iOS



Set line break strategy on iOS 14+. Possible values are  none ,
 standard ,  hangul-word and  push-out .

  Type                                                           Default
  -------------------------------------------------------------- ---------
  enum(  'none' ,  'standard' ,  'hangul-word' ,  'push-out' )    'none'

Type Definitions 

TextLayout 

 TextLayout object is a part of  TextLayoutEvent callback and contains
the measurement data for  Text line.

Example 

    {
        capHeight: 10.496,
        ascender: 14.624,
        descender: 4,
        width: 28.224,
        height: 18.624,
        xHeight: 6.048,
        x: 0,
        y: 0
    }

 

Properties 

  Name        Type     Optional   Description
  ----------- -------- ---------- ---------------------------------------------------------------------
  ascender    number   No         The line ascender height after the text layout changes.
  capHeight   number   No         Height of capital letter above the baseline.
  descender   number   No         The line descender height after the text layout changes.
  height      number   No         Height of the line after the text layout changes.
  width       number   No         Width of the line after the text layout changes.
  x           number   No         Line X coordinate inside the Text component.
  xHeight     number   No         Distance between the baseline and median of the line (corpus size).
  y           number   No         Line Y coordinate inside the Text component.

TextLayoutEvent 

 TextLayoutEvent object is returned in the callback as a result of a
component layout change. It contains a key called  lines with a value
which is an array containing  TextLayout object corresponded to every
rendered text line.

Example 

    {
      lines: [
        TextLayout,
        TextLayout,
        // ...
      ];
      target: 1127;
    }

 

Properties 

  Name     Type                    Optional   Description
  -------- ----------------------- ---------- -------------------------------------------------------
  lines    array of TextLayout s   No         Provides the TextLayout data for every rendered line.
  target   number                  No         The node id of the element.

# TextInput #
 _____         _   ___                   _   
|_   _|____  _| |_|_ _|_ __  _ __  _   _| |_ 
  | |/ _ \ \/ / __|| || '_ \| '_ \| | | | __|
  | |  __/>  <| |_ | || | | | |_) | |_| | |_ 
  |_|\___/_/\_\\__|___|_| |_| .__/ \__,_|\__|
                            |_|              
-   Props
    -   View Props
    -    allowFontScaling
    -    autoCapitalize
    -    autoComplete
    -    autoCorrect
    -    autoFocus
    -    blurOnSubmit
    -    caretHidden
    -    clearButtonMode
        iOS
    -    clearTextOnFocus
        iOS
    -    contextMenuHidden
    -    dataDetectorTypes
        iOS
    -    defaultValue
    -    cursorColor
        Android
    -    disableFullscreenUI
        Android
    -    editable
    -    enablesReturnKeyAutomatically
        iOS
    -    enterKeyHint
    -    importantForAutofill
        Android
    -    inlineImageLeft
        Android
    -    inlineImagePadding
        Android
    -    inputAccessoryViewID
        iOS
    -    inputMode
    -    keyboardAppearance
        iOS
    -    keyboardType
    -    maxFontSizeMultiplier
    -    maxLength
    -    multiline
    -    numberOfLines
        Android
    -    onBlur
    -    onChange
    -    onChangeText
    -    onContentSizeChange
    -    onEndEditing
    -    onPressIn
    -    onPressOut
    -    onFocus
    -    onKeyPress
    -    onLayout
    -    onScroll
    -    onSelectionChange
    -    onSubmitEditing
    -    placeholder
    -    placeholderTextColor
    -    readOnly
    -    returnKeyLabel
        Android
    -    returnKeyType
    -    rejectResponderTermination
        iOS
    -    rows
        Android
    -    scrollEnabled
        iOS
    -    secureTextEntry
    -    selection
    -    selectionColor
    -    selectTextOnFocus
    -    showSoftInputOnFocus
    -    spellCheck
        iOS
    -    textAlign
    -    textContentType
        iOS
    -    passwordRules
        iOS
    -    style
    -    textBreakStrategy
        Android
    -    underlineColorAndroid
        Android
    -    value
    -    lineBreakStrategyIOS
        iOS
-   Methods
    -    .focus()
    -    .blur()
    -    clear()
    -    isFocused()
TextInput

A foundational component for inputting text into the app via a keyboard.
Props provide configurability for several features, such as
auto-correction, auto-capitalization, placeholder text, and different
keyboard types, such as a numeric keypad.

The most basic use case is to plop down a  TextInput and subscribe to
the  onChangeText events to read the user input. There are also other
events, such as  onSubmitEditing and  onFocus that can be subscribed to.
A minimal example:

Two methods exposed via the native element are .focus() and .blur() that
will focus or blur the TextInput programmatically.

Note that some props are only available with  multiline={true/false} .
Additionally, border styles that apply to only one side of the element
(e.g.,  borderBottomColor ,  borderLeftWidth , etc.) will not be applied
if  multiline=true . To achieve the same effect, you can wrap your
 TextInput in a  View :

 TextInput has by default a border at the bottom of its view. This
border has its padding set by the background image provided by the
system, and it cannot be changed. Solutions to avoid this are to either
not set height explicitly, in which case the system will take care of
displaying the border in the correct position, or to not display the
border by setting  underlineColorAndroid to transparent.

Note that on Android performing text selection in an input can change
the app's activity  windowSoftInputMode param to  adjustResize . This
may cause issues with components that have position: 'absolute' while
the keyboard is active. To avoid this behavior either specify
 windowSoftInputMode in AndroidManifest.xml (
https://developer.android.com/guide/topics/manifest/activity-element.html
) or control this param programmatically with native code.

------------------------------------------------------------------------

Reference

Props 

View Props 

Inherits View Props .

------------------------------------------------------------------------

 allowFontScaling 

Specifies whether fonts should scale to respect Text Size accessibility
settings. The default is  true .

  Type
  ------
  bool

------------------------------------------------------------------------

 autoCapitalize 

Tells  TextInput to automatically capitalize certain characters. This
property is not supported by some keyboard types such as  name-phone-pad
.

-    characters : all characters.
-    words : first letter of each word.
-    sentences : first letter of each sentence ( default ).
-    none : don't auto capitalize anything.

  Type
  --------------------------------------------------
  enum('none', 'sentences', 'words', 'characters')

------------------------------------------------------------------------

 autoComplete 

Specifies autocomplete hints for the system, so it can provide autofill.
On Android, the system will always attempt to offer autofill by using
heuristics to identify the type of content. To disable autocomplete, set
 autoComplete to  off .

The following values work across platforms:

-    additional-name
-    address-line1
-    address-line2
-    birthdate-day (iOS 17+)
-    birthdate-full (iOS 17+)
-    birthdate-month (iOS 17+)
-    birthdate-year (iOS 17+)
-    cc-csc (iOS 17+)
-    cc-exp (iOS 17+)
-    cc-exp-day (iOS 17+)
-    cc-exp-month (iOS 17+)
-    cc-exp-year (iOS 17+)
-    cc-number
-    country
-    current-password
-    email
-    family-name
-    given-name
-    honorific-prefix
-    honorific-suffix
-    name
-    new-password
-    off
-    one-time-code
-    postal-code
-    street-address
-    tel
-    username

iOS

The following values work on iOS only:

-    cc-family-name (iOS 17+)
-    cc-given-name (iOS 17+)
-    cc-middle-name (iOS 17+)
-    cc-name (iOS 17+)
-    cc-type (iOS 17+)
-    nickname
-    organization
-    organization-title
-    url

Android

The following values work on Android only:

-    gender
-    name-family
-    name-given
-    name-middle
-    name-middle-initial
-    name-prefix
-    name-suffix
-    password
-    password-new
-    postal-address
-    postal-address-country
-    postal-address-extended
-    postal-address-extended-postal-code
-    postal-address-locality
-    postal-address-region
-    sms-otp
-    tel-country-code
-    tel-device
-    tel-national
-    username-new

  Type
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  enum('additional-name', 'address-line1', 'address-line2', 'birthdate-day', 'birthdate-full', 'birthdate-month', 'birthdate-year', 'cc-csc', 'cc-exp', 'cc-exp-day', 'cc-exp-month', 'cc-exp-year', 'cc-number', 'country', 'current-password', 'email', 'family-name', 'given-name', 'honorific-prefix', 'honorific-suffix', 'name', 'new-password', 'off', 'one-time-code', 'postal-code', 'street-address', 'tel', 'username', 'cc-family-name', 'cc-given-name', 'cc-middle-name', 'cc-name', 'cc-type', 'nickname', 'organization', 'organization-title', 'url', 'gender', 'name-family', 'name-given', 'name-middle', 'name-middle-initial', 'name-prefix', 'name-suffix', 'password', 'password-new', 'postal-address', 'postal-address-country', 'postal-address-extended', 'postal-address-extended-postal-code', 'postal-address-locality', 'postal-address-region', 'sms-otp', 'tel-country-code', 'tel-device', 'tel-national', 'username-new')

------------------------------------------------------------------------

 autoCorrect 

If  false , disables auto-correct. The default value is  true .

  Type
  ------
  bool

------------------------------------------------------------------------

 autoFocus 

If  true , focuses the input on  componentDidMount or  useEffect . The
default value is  false .

  Type
  ------
  bool

------------------------------------------------------------------------

 blurOnSubmit 

If  true , the text field will blur when submitted. The default value is
true for single-line fields and false for multiline fields. Note that
for multiline fields, setting  blurOnSubmit to  true means that pressing
return will blur the field and trigger the  onSubmitEditing event
instead of inserting a newline into the field.

  Type
  ------
  bool

------------------------------------------------------------------------

 caretHidden 

If  true , caret is hidden. The default value is  false .

  Type
  ------
  bool

------------------------------------------------------------------------

 clearButtonMode

iOS



When the clear button should appear on the right side of the text view.
This property is supported only for single-line TextInput component. The
default value is  never .

  Type
  ------------------------------------------------------------
  enum('never', 'while-editing', 'unless-editing', 'always')

------------------------------------------------------------------------

 clearTextOnFocus

iOS



If  true , clears the text field automatically when editing begins.

  Type
  ------
  bool

------------------------------------------------------------------------

 contextMenuHidden 

If  true , context menu is hidden. The default value is  false .

  Type
  ------
  bool

------------------------------------------------------------------------

 dataDetectorTypes

iOS



Determines the types of data converted to clickable URLs in the text
input. Only valid if  multiline={true} and  editable={false} . By
default no data types are detected.

You can provide one type or an array of many types.

Possible values for  dataDetectorTypes are:

-    'phoneNumber'
-    'link'
-    'address'
-    'calendarEvent'
-    'none'
-    'all'

  Type
  ----------------------------------------------------------------------------------------------------------------------------------------------------------
  enum('phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all'), ,array of enum('phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all')

------------------------------------------------------------------------

 defaultValue 

Provides an initial value that will change when the user starts typing.
Useful for use-cases where you do not want to deal with listening to
events and updating the value prop to keep the controlled state in sync.

  Type
  --------
  string

------------------------------------------------------------------------

 cursorColor

Android



When provided it will set the color of the cursor (or "caret") in the
component. Unlike the behavior of  selectionColor the cursor color will
be set independently from the color of the text selection box.

  Type
  -------
  color

------------------------------------------------------------------------

 disableFullscreenUI

Android



When  false , if there is a small amount of space available around a
text input (e.g. landscape orientation on a phone), the OS may choose to
have the user edit the text inside of a full screen text input mode.
When  true , this feature is disabled and users will always edit the
text directly inside of the text input. Defaults to  false .

  Type
  ------
  bool

------------------------------------------------------------------------

 editable 

If  false , text is not editable. The default value is  true .

  Type
  ------
  bool

------------------------------------------------------------------------

 enablesReturnKeyAutomatically

iOS



If  true , the keyboard disables the return key when there is no text
and automatically enables it when there is text. The default value is
 false .

  Type
  ------
  bool

------------------------------------------------------------------------

 enterKeyHint 

Determines what text should be shown to the return key. Has precedence
over the  returnKeyType prop.

The following values work across platforms:

-    enter
-    done
-    next
-    search
-    send

Android Only

The following values work on Android only:

-    previous

  Type
  -------------------------------------------------------------
  enum('enter', 'done', 'next', 'previous', 'search', 'send')

------------------------------------------------------------------------

 importantForAutofill

Android



Tells the operating system whether the individual fields in your app
should be included in a view structure for autofill purposes on Android
API Level 26+. Possible values are  auto ,  no ,  noExcludeDescendants ,
 yes , and  yesExcludeDescendants . The default value is  auto .

-    auto : Let the Android System use its heuristics to determine if
    the view is important for autofill.
-    no : This view isn't important for autofill.
-    noExcludeDescendants : This view and its children aren't important
    for autofill.
-    yes : This view is important for autofill.
-    yesExcludeDescendants : This view is important for autofill, but
    its children aren't important for autofill.

  Type
  ----------------------------------------------------------------------------
  enum('auto', 'no', 'noExcludeDescendants', 'yes', 'yesExcludeDescendants')

------------------------------------------------------------------------

 inlineImageLeft

Android



If defined, the provided image resource will be rendered on the left.
The image resource must be inside  /android/app/src/main/res/drawable
and referenced like

    <TextInput
     inlineImageLeft='search_icon'
    />

 

  Type
  --------
  string

------------------------------------------------------------------------

 inlineImagePadding

Android



Padding between the inline image, if any, and the text input itself.

  Type
  --------
  number

------------------------------------------------------------------------

 inputAccessoryViewID

iOS



An optional identifier which links a custom InputAccessoryView to this
text input. The InputAccessoryView is rendered above the keyboard when
this text input is focused.

  Type
  --------
  string

------------------------------------------------------------------------

 inputMode 

Works like the  inputmode attribute in HTML, it determines which
keyboard to open, e.g.  numeric and has precedence over  keyboardType .

Support the following values:

-    none
-    text
-    decimal
-    numeric
-    tel
-    search
-    email
-    url

  Type
  -----------------------------------------------------------------------------
  enum('decimal', 'email', 'none', 'numeric', 'search', 'tel', 'text', 'url')

------------------------------------------------------------------------

 keyboardAppearance

iOS



Determines the color of the keyboard.

  Type
  ----------------------------------
  enum('default', 'light', 'dark')

------------------------------------------------------------------------

 keyboardType 

Determines which keyboard to open, e.g.  numeric .

See screenshots of all the types here .

The following values work across platforms:

-    default
-    number-pad
-    decimal-pad
-    numeric
-    email-address
-    phone-pad
-    url

iOS Only

The following values work on iOS only:

-    ascii-capable
-    numbers-and-punctuation
-    name-phone-pad
-    twitter
-    web-search

Android Only

The following values work on Android only:

-    visible-password

  Type
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  enum('default', 'email-address', 'numeric', 'phone-pad', 'ascii-capable', 'numbers-and-punctuation', 'url', 'number-pad', 'name-phone-pad', 'decimal-pad', 'twitter', 'web-search', 'visible-password')

------------------------------------------------------------------------

 maxFontSizeMultiplier 

Specifies largest possible scale a font can reach when  allowFontScaling
is enabled. Possible values:

-    null/undefined (default): inherit from the parent node or the
    global default (0)
-    0 : no max, ignore parent/global default
-    >= 1 : sets the  maxFontSizeMultiplier of this node to this value

  Type
  --------
  number

------------------------------------------------------------------------

 maxLength 

Limits the maximum number of characters that can be entered. Use this
instead of implementing the logic in JS to avoid flicker.

  Type
  --------
  number

------------------------------------------------------------------------

 multiline 

If  true , the text input can be multiple lines. The default value is
 false .

 note

It is important to note that this aligns the text to the top on iOS, and
centers it on Android. Use with  textAlignVertical set to  top for the
same behavior in both platforms.

  Type
  ------
  bool

------------------------------------------------------------------------

 numberOfLines

Android



Sets the number of lines for a  TextInput . Use it with multiline set to
 true to be able to fill the lines.

  Type
  --------
  number

------------------------------------------------------------------------

 onBlur 

Callback that is called when the text input is blurred.

  Note: If you are attempting to access the  text value from
   nativeEvent keep in mind that the resulting value you get can be
   undefined which can cause unintended errors. If you are trying to
  find the last value of TextInput, you can use the  onEndEditing event,
  which is fired upon completion of editing.

  Type
  ----------
  function

------------------------------------------------------------------------

 onChange 

Callback that is called when the text input's text changes.

  Type
  --------------------------------------------------------
  (  {nativeEvent: {eventCount, target, text}} ) => void

------------------------------------------------------------------------

 onChangeText 

Callback that is called when the text input's text changes. Changed text
is passed as a single string argument to the callback handler.

  Type
  ----------
  function

------------------------------------------------------------------------

 onContentSizeChange 

Callback that is called when the text input's content size changes.

Only called for multiline text inputs.

  Type
  -------------------------------------------------------------
  (  {nativeEvent: {contentSize: {width, height} }} ) => void

------------------------------------------------------------------------

 onEndEditing 

Callback that is called when text input ends.

  Type
  ----------
  function

------------------------------------------------------------------------

 onPressIn 

Callback that is called when a touch is engaged.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onPressOut 

Callback that is called when a touch is released.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onFocus 

Callback that is called when the text input is focused.

  Type
  ------------------------------------------
   ({nativeEvent:  LayoutEvent  }) => void

------------------------------------------------------------------------

 onKeyPress 

Callback that is called when a key is pressed. This will be called with
object where  keyValue is  'Enter' or  'Backspace' for respective keys
and the typed-in character otherwise including  ' ' for space. Fires
before  onChange callbacks. Note: on Android only the inputs from soft
keyboard are handled, not the hardware keyboard inputs.

  Type
  ----------------------------------------------
  (  {nativeEvent: {key: keyValue} } ) => void

------------------------------------------------------------------------

 onLayout 

Invoked on mount and on layout changes.

  Type
  ------------------------------------------
   ({nativeEvent:  LayoutEvent  }) => void

------------------------------------------------------------------------

 onScroll 

Invoked on content scroll. May also contain other properties from
 ScrollEvent but on Android  contentSize is not provided for performance
reasons.

  Type
  ------------------------------------------------------
  (  {nativeEvent: {contentOffset: {x, y} }} ) => void

------------------------------------------------------------------------

 onSelectionChange 

Callback that is called when the text input selection is changed.

  Type
  --------------------------------------------------------
  (  {nativeEvent: {selection: {start, end} }} ) => void

------------------------------------------------------------------------

 onSubmitEditing 

Callback that is called when the text input's submit button is pressed.

  Type
  --------------------------------------------------------
  (  {nativeEvent: {text, eventCount, target}} ) => void

Note that on iOS this method isn't called when using
 keyboardType="phone-pad" .

------------------------------------------------------------------------

 placeholder 

The string that will be rendered before text input has been entered.

  Type
  --------
  string

------------------------------------------------------------------------

 placeholderTextColor 

The text color of the placeholder string.

  Type
  -------
  color

------------------------------------------------------------------------

 readOnly 

If  true , text is not editable. The default value is  false .

  Type
  ------
  bool

------------------------------------------------------------------------

 returnKeyLabel

Android



Sets the return key to the label. Use it instead of  returnKeyType .

  Type
  --------
  string

------------------------------------------------------------------------

 returnKeyType 

Determines how the return key should look. On Android you can also use
 returnKeyLabel .

Cross platform

The following values work across platforms:

-    done
-    go
-    next
-    search
-    send

Android Only

The following values work on Android only:

-    none
-    previous

iOS Only

The following values work on iOS only:

-    default
-    emergency-call
-    google
-    join
-    route
-    yahoo

  Type
  -----------------------------------------------------------------------------------------------------------------------------------
  enum('done', 'go', 'next', 'search', 'send', 'none', 'previous', 'default', 'emergency-call', 'google', 'join', 'route', 'yahoo')

 rejectResponderTermination

iOS



If  true , allows TextInput to pass touch events to the parent
component. This allows components such as SwipeableListView to be
swipeable from the TextInput on iOS, as is the case on Android by
default. If  false , TextInput always asks to handle the input (except
when disabled). The default value is  true .

  Type
  ------
  bool

------------------------------------------------------------------------

 rows

Android



Sets the number of lines for a  TextInput . Use it with multiline set to
 true to be able to fill the lines.

  Type
  --------
  number

------------------------------------------------------------------------

 scrollEnabled

iOS



If  false , scrolling of the text view will be disabled. The default
value is  true . Only works with  multiline={true} .

  Type
  ------
  bool

------------------------------------------------------------------------

 secureTextEntry 

If  true , the text input obscures the text entered so that sensitive
text like passwords stay secure. The default value is  false . Does not
work with  multiline={true} .

  Type
  ------
  bool

------------------------------------------------------------------------

 selection 

The start and end of the text input's selection. Set start and end to
the same value to position the cursor.

  Type
  --------------------------------------
  object:  {start: number,end: number}

------------------------------------------------------------------------

 selectionColor 

The highlight and cursor color of the text input.

  Type
  -------
  color

------------------------------------------------------------------------

 selectTextOnFocus 

If  true , all text will automatically be selected on focus.

  Type
  ------
  bool

------------------------------------------------------------------------

 showSoftInputOnFocus 

When  false , it will prevent the soft keyboard from showing when the
field is focused. The default value is  true .

  Type
  ------
  bool

------------------------------------------------------------------------

 spellCheck

iOS



If  false , disables spell-check style (i.e. red underlines). The
default value is inherited from  autoCorrect .

  Type
  ------
  bool

------------------------------------------------------------------------

 textAlign 

Align the input text to the left, center, or right sides of the input
field.

Possible values for  textAlign are:

-    left
-    center
-    right

  Type
  ---------------------------------
  enum('left', 'center', 'right')

------------------------------------------------------------------------

 textContentType

iOS



Give the keyboard and the system information about the expected semantic
meaning for the content that users enter.

 note

 autoComplete , provides the same functionality and is available for all
platforms. You can use  Platform.select for differing platform
behaviors.

Avoid using both  textContentType and  autoComplete . For backwards
compatibility,  textContentType takes precedence when both properties
are set.

You can set  textContentType to  username or  password to enable
autofill of login details from the device keychain.

 newPassword can be used to indicate a new password input the user may
want to save in the keychain, and  oneTimeCode can be used to indicate
that a field can be autofilled by a code arriving in an SMS.

To disable autofill, set  textContentType to  none .

Possible values for  textContentType are:

-    none
-    addressCity
-    addressCityAndState
-    addressState
-    birthdate (iOS 17+)
-    birthdateDay (iOS 17+)
-    birthdateMonth (iOS 17+)
-    birthdateYear (iOS 17+)
-    countryName
-    creditCardExpiration (iOS 17+)
-    creditCardExpirationMonth (iOS 17+)
-    creditCardExpirationYear (iOS 17+)
-    creditCardFamilyName (iOS 17+)
-    creditCardGivenName (iOS 17+)
-    creditCardMiddleName (iOS 17+)
-    creditCardName (iOS 17+)
-    creditCardNumber
-    creditCardSecurityCode (iOS 17+)
-    creditCardType (iOS 17+)
-    emailAddress
-    familyName
-    fullStreetAddress
-    givenName
-    jobTitle
-    location
-    middleName
-    name
-    namePrefix
-    nameSuffix
-    newPassword
-    nickname
-    oneTimeCode
-    organizationName
-    password
-    postalCode
-    streetAddressLine1
-    streetAddressLine2
-    sublocality
-    telephoneNumber
-    URL
-    username

  Type
  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  enum('none', 'addressCity', 'addressCityAndState', 'addressState', 'birthdate', 'birthdateDay', 'birthdateMonth', 'birthdateYear', 'countryName', 'creditCardExpiration', 'creditCardExpirationMonth', 'creditCardExpirationYear', 'creditCardFamilyName', 'creditCardGivenName', 'creditCardMiddleName', 'creditCardName', 'creditCardNumber', 'creditCardSecurityCode', 'creditCardType', 'emailAddress', 'familyName', 'fullStreetAddress', 'givenName', 'jobTitle', 'location', 'middleName', 'name', 'namePrefix', 'nameSuffix', 'newPassword', 'nickname', 'oneTimeCode', 'organizationName', 'password', 'postalCode', 'streetAddressLine1', 'streetAddressLine2', 'sublocality', 'telephoneNumber', 'URL', 'username')

------------------------------------------------------------------------

 passwordRules

iOS



When using  textContentType as  newPassword on iOS we can let the OS
know the minimum requirements of the password so that it can generate
one that will satisfy them. In order to create a valid string for
 PasswordRules take a look to the Apple Docs .

  If passwords generation dialog doesn't appear please make sure that:

  -   AutoFill is enabled: Settings → Passwords & Accounts → toggle "On"
      the AutoFill Passwords ,
  -   iCloud Keychain is used: Settings → Apple ID → iCloud → Keychain →
      toggle "On" the iCloud Keychain .

  Type
  --------
  string

------------------------------------------------------------------------

 style 

Note that not all Text styles are supported, an incomplete list of what
is not supported includes:

-    borderLeftWidth
-    borderTopWidth
-    borderRightWidth
-    borderBottomWidth
-    borderTopLeftRadius
-    borderTopRightRadius
-    borderBottomRightRadius
-    borderBottomLeftRadius

see Issue#7070 for more detail.

Styles

  Type
  ------
  Text

------------------------------------------------------------------------

 textBreakStrategy

Android



Set text break strategy on Android API Level 23+, possible values are
 simple ,  highQuality ,  balanced The default value is  highQuality .

  Type
  -------------------------------------------
  enum('simple', 'highQuality', 'balanced')

------------------------------------------------------------------------

 underlineColorAndroid

Android



The color of the  TextInput underline.

  Type
  -------
  color

------------------------------------------------------------------------

 value 

The value to show for the text input.  TextInput is a controlled
component, which means the native value will be forced to match this
value prop if provided. For most uses, this works great, but in some
cases this may cause flickering - one common cause is preventing edits
by keeping value the same. In addition to setting the same value, either
set  editable={false} , or set/update  maxLength to prevent unwanted
edits without flicker.

  Type
  --------
  string

------------------------------------------------------------------------

 lineBreakStrategyIOS

iOS



Set line break strategy on iOS 14+. Possible values are  none ,
 standard ,  hangul-word and  push-out .

  Type                                                           Default
  -------------------------------------------------------------- ---------
  enum(  'none' ,  'standard' ,  'hangul-word' ,  'push-out' )    'none'

Methods 

 .focus() 

    focus();

 

Makes the native input request focus.

 .blur() 

    blur();

 

Makes the native input lose focus.

 clear() 

    clear();

 

Removes all text from the  TextInput .

------------------------------------------------------------------------

 isFocused() 

    isFocused(): boolean;

 

Returns  true if the input is currently focused;  false otherwise.

Known issues

-   react-native#19096 : Doesn't support Android's  onKeyPreIme .
-   react-native#19366 : Calling .focus() after closing Android's
    keyboard via back button doesn't bring keyboard up again.
-   react-native#26799 : Doesn't support Android's  secureTextEntry when
     keyboardType="email-address" or  keyboardType="phone-pad" .

# Text Style Props #
 _____         _     ____  _         _        ____                      
|_   _|____  _| |_  / ___|| |_ _   _| | ___  |  _ \ _ __ ___  _ __  ___ 
  | |/ _ \ \/ / __| \___ \| __| | | | |/ _ \ | |_) | '__/ _ \| '_ \/ __|
  | |  __/>  <| |_   ___) | |_| |_| | |  __/ |  __/| | | (_) | |_) \__ \
  |_|\___/_/\_\\__| |____/ \__|\__, |_|\___| |_|   |_|  \___/| .__/|___/
                               |___/                         |_|        
-   Example
-   Props
    -    color
    -    fontFamily
    -    fontSize
    -    fontStyle
    -    fontWeight
    -    includeFontPadding
        Android
    -    fontVariant
    -    letterSpacing
    -    lineHeight
    -    textAlign
    -    textAlignVertical
        Android
    -    textDecorationColor
        iOS
    -    textDecorationLine
    -    textDecorationStyle
        iOS
    -    textShadowColor
    -    textShadowOffset
    -    textShadowRadius
    -    textTransform
    -    verticalAlign
        Android
    -    writingDirection
        iOS
    -    userSelect
Text Style Props

Example 

-   TypeScript
-   JavaScript

Reference

Props 

 color 

  Type
  -------
  color

------------------------------------------------------------------------

 fontFamily 

  Type
  --------
  string

------------------------------------------------------------------------

 fontSize 

  Type
  --------
  number

------------------------------------------------------------------------

 fontStyle 

  Type
  -------------------------------
  enum(  'normal' ,  'italic' )

------------------------------------------------------------------------

 fontWeight 

Specifies font weight. The values  'normal' and  'bold' are supported
for most fonts. Not all fonts have a variant for each of the numeric
values, in that case the closest one is chosen.

  Type                                                                                                                     Default
  ------------------------------------------------------------------------------------------------------------------------ -----------
  enum(  'normal' ,  'bold' ,  '100' ,  '200' ,  '300' ,  '400' ,  '500' ,  '600' ,  '700' ,  '800' ,  '900' ) or number    'normal'

------------------------------------------------------------------------

 includeFontPadding

Android



Set to  false to remove extra font padding intended to make space for
certain ascenders / descenders. With some fonts, this padding can make
text look slightly misaligned when centered vertically. For best results
also set  textAlignVertical to  center .

  Type   Default
  ------ ---------
  bool    true

------------------------------------------------------------------------

 fontVariant 

Allows you to set all the font variants for a font. Can be set by using
an array of enums or a space-separated string e.g.
 'small-caps common-ligatures' .

  Type                                                                                                                    Default
  ----------------------------------------------------------------------------------------------------------------------- ---------
  array of enum(  'small-caps' ,  'oldstyle-nums' ,  'lining-nums' ,  'tabular-nums' ,  'proportional-nums' ) or string    

------------------------------------------------------------------------

 letterSpacing 

Increase or decrease the spacing between characters. By default there is
no extra letter spacing.

  Type
  --------
  number

------------------------------------------------------------------------

 lineHeight 

Numeric value that controls the vertical spacing between lines of text
within a text element. It specifies the distance between the baselines
of consecutive lines of text.

  Type
  --------
  number

------------------------------------------------------------------------

 textAlign 

Specifies text alignment. On Android, the value 'justify' is only
supported on Oreo (8.0) or above (API level >= 26). The value will
fallback to  left on lower Android versions.

  Type                                                            Default
  --------------------------------------------------------------- ---------
  enum(  'auto' ,  'left' ,  'right' ,  'center' ,  'justify' )    'auto'

------------------------------------------------------------------------

 textAlignVertical

Android



  Type                                               Default
  -------------------------------------------------- ---------
  enum(  'auto' ,  'top' ,  'bottom' ,  'center' )    'auto'

------------------------------------------------------------------------

 textDecorationColor

iOS



  Type
  -------
  color

------------------------------------------------------------------------

 textDecorationLine 

  Type                                                                           Default
  ------------------------------------------------------------------------------ ---------
  enum(  'none' ,  'underline' ,  'line-through' ,  'underline line-through' )    'none'

------------------------------------------------------------------------

 textDecorationStyle

iOS



  Type                                                   Default
  ------------------------------------------------------ ----------
  enum(  'solid' ,  'double' ,  'dotted' ,  'dashed' )    'solid'

------------------------------------------------------------------------

 textShadowColor 

  Type
  -------
  color

------------------------------------------------------------------------

 textShadowOffset 

  Type
  --------------------------------------------
  object:  {width?: number, height?: number}

------------------------------------------------------------------------

 textShadowRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 textTransform 

  Type                                                            Default
  --------------------------------------------------------------- ---------
  enum(  'none' ,  'uppercase' ,  'lowercase' ,  'capitalize' )    'none'

------------------------------------------------------------------------

 verticalAlign

Android



  Type                                               Default
  -------------------------------------------------- ---------
  enum(  'auto' ,  'top' ,  'bottom' ,  'middle' )    'auto'

------------------------------------------------------------------------

 writingDirection

iOS



  Type                                Default
  ----------------------------------- ---------
  enum(  'auto' ,  'ltr' ,  'rtl' )    'auto'

------------------------------------------------------------------------

 userSelect 

It allows the user to select text and to use the native copy and paste
functionality. Has precedence over the  selectable prop.

  Type                                                        Default
  ----------------------------------------------------------- ---------
  enum(  'auto' ,  'text' ,  'none' ,  'contain' ,  'all' )    none

# Timers #
 _____ _                         
|_   _(_)_ __ ___   ___ _ __ ___ 
  | | | | '_ ` _ \ / _ \ '__/ __|
  | | | | | | | | |  __/ |  \__ \
  |_| |_|_| |_| |_|\___|_|  |___/
                                 
-   Timers
-   InteractionManager
Timers

Timers are an important part of an application and React Native
implements the browser timers .

Timers 

-   setTimeout, clearTimeout
-   setInterval, clearInterval
-   setImmediate, clearImmediate
-   requestAnimationFrame, cancelAnimationFrame

 requestAnimationFrame(fn) is not the same as  setTimeout(fn, 0) - the
former will fire after all the frames have flushed, whereas the latter
will fire as quickly as possible (over 1000x per second on a iPhone 5S).

 setImmediate is executed at the end of the current JavaScript execution
block, right before sending the batched response back to native. Note
that if you call  setImmediate within a  setImmediate callback, it will
be executed right away, it won't yield back to native in between.

The  Promise implementation uses  setImmediate as its asynchronicity
implementation.

 note

When debugging on Android, if the times between the debugger and device
have drifted; things such as animation, event behavior, etc., might not
work properly or the results may not be accurate. Please correct this by
running  adb shell "date `date +%m%d%H%M%Y.%S%3N`" on your debugger
machine. Root access is required for the use in real device.

InteractionManager 

One reason why well-built native apps feel so smooth is by avoiding
expensive operations during interactions and animations. In React
Native, we currently have a limitation that there is only a single JS
execution thread, but you can use  InteractionManager to make sure
long-running work is scheduled to start after any
interactions/animations have completed.

Applications can schedule tasks to run after interactions with the
following:

    InteractionManager.runAfterInteractions(() => {
      // ...long-running synchronous task...
    });

 

Compare this to other scheduling alternatives:

-   requestAnimationFrame(): for code that animates a view over time.
-   setImmediate/setTimeout/setInterval(): run code later, note this may
    delay animations.
-   runAfterInteractions(): run code later, without delaying active
    animations.

The touch handling system considers one or more active touches to be an
'interaction' and will delay  runAfterInteractions() callbacks until all
touches have ended or been cancelled.

InteractionManager also allows applications to register animations by
creating an interaction 'handle' on animation start, and clearing it
upon completion:

    const handle = InteractionManager.createInteractionHandle();
    // run animation... (`runAfterInteractions` tasks are queued)
    // later, on animation completion:
    InteractionManager.clearInteractionHandle(handle);
    // queued tasks run if all handles were cleared

 

# ToastAndroid #
 _____               _      _              _           _     _ 
|_   _|__   __ _ ___| |_   / \   _ __   __| |_ __ ___ (_) __| |
  | |/ _ \ / _` / __| __| / _ \ | '_ \ / _` | '__/ _ \| |/ _` |
  | | (_) | (_| \__ \ |_ / ___ \| | | | (_| | | | (_) | | (_| |
  |_|\___/ \__,_|___/\__/_/   \_\_| |_|\__,_|_|  \___/|_|\__,_|
                                                               
-   Methods
    -    show()
    -    showWithGravity()
    -    showWithGravityAndOffset()
-   Properties
    -    SHORT
    -    LONG
    -    TOP
    -    BOTTOM
    -    CENTER
ToastAndroid

React Native's ToastAndroid API exposes the Android platform's
ToastAndroid module as a JS module. It provides the method
 show(message, duration) which takes the following parameters:

-   message A string with the text to toast
-   duration The duration of the toast—either  ToastAndroid.SHORT or
     ToastAndroid.LONG

You can alternatively use  showWithGravity(message, duration, gravity)
to specify where the toast appears in the screen's layout. May be
 ToastAndroid.TOP ,  ToastAndroid.BOTTOM or  ToastAndroid.CENTER .

The 'showWithGravityAndOffset(message, duration, gravity, xOffset,
yOffset)' method adds the ability to specify an offset with in pixels.

------------------------------------------------------------------------

Reference

Methods 

 show() 

    static show(message: string, duration: number);

 

------------------------------------------------------------------------

 showWithGravity() 

    static showWithGravity(message: string, duration: number, gravity: number);

 

------------------------------------------------------------------------

 showWithGravityAndOffset() 

    static showWithGravityAndOffset(
      message: string,
      duration: number,
      gravity: number,
      xOffset: number,
      yOffset: number,
    );

 

Properties 

 SHORT 

Indicates the duration on the screen.

    static SHORT: number;

 

------------------------------------------------------------------------

 LONG 

Indicates the duration on the screen.

    static LONG: number;

 

------------------------------------------------------------------------

 TOP 

Indicates the position on the screen.

    static TOP: number;

 

------------------------------------------------------------------------

 BOTTOM 

Indicates the position on the screen.

    static BOTTOM: number;

 

------------------------------------------------------------------------

 CENTER 

Indicates the position on the screen.

    static CENTER: number;

 

# Toggle navigation #
 _____                 _      
|_   _|__   __ _  __ _| | ___ 
  | |/ _ \ / _` |/ _` | |/ _ \
  | | (_) | (_| | (_| | |  __/
  |_|\___/ \__, |\__, |_|\___|
           |___/ |___/        
                   _             _   _             
 _ __   __ ___   _(_) __ _  __ _| |_(_) ___  _ __  
| '_ \ / _` \ \ / / |/ _` |/ _` | __| |/ _ \| '_ \ 
| | | | (_| |\ V /| | (_| | (_| | |_| | (_) | | | |
|_| |_|\__,_| \_/ |_|\__, |\__,_|\__|_|\___/|_| |_|
                     |___/                         



# TouchableHighlight #
 _____                _           _     _      _   _ _       _     _ _       
|_   _|__  _   _  ___| |__   __ _| |__ | | ___| | | (_) __ _| |__ | (_) __ _ 
  | |/ _ \| | | |/ __| '_ \ / _` | '_ \| |/ _ \ |_| | |/ _` | '_ \| | |/ _` |
  | | (_) | |_| | (__| | | | (_| | |_) | |  __/  _  | | (_| | | | | | | (_| |
  |_|\___/ \__,_|\___|_| |_|\__,_|_.__/|_|\___|_| |_|_|\__, |_| |_|_|_|\__, |
                                                       |___/           |___/ 
 _     _   
| |__ | |_ 
| '_ \| __|
| | | | |_ 
|_| |_|\__|
           
-   Example
-   Props
    -   TouchableWithoutFeedback Props
    -    activeOpacity
    -    onHideUnderlay
    -    onShowUnderlay
    -    style
    -    underlayColor
    -    hasTVPreferredFocus
        iOS
    -    nextFocusDown
        Android
    -    nextFocusForward
        Android
    -    nextFocusLeft
        Android
    -    nextFocusRight
        Android
    -    nextFocusUp
        Android
    -    testOnly_pressed
TouchableHighlight

  If you're looking for a more extensive and future-proof way to handle
  touch-based input, check out the Pressable API.

A wrapper for making views respond properly to touches. On press down,
the opacity of the wrapped view is decreased, which allows the underlay
color to show through, darkening or tinting the view.

The underlay comes from wrapping the child in a new View, which can
affect layout, and sometimes cause unwanted visual artifacts if not used
correctly, for example if the backgroundColor of the wrapped view isn't
explicitly set to an opaque color.

TouchableHighlight must have one child (not zero or more than one). If
you wish to have several child components, wrap them in a View.

    function MyComponent(props: MyComponentProps) {
      return (
        <View {...props} style={{flex: 1, backgroundColor: '#fff'}}>
          <Text>My Component</Text>
        </View>
      );
    }

    <TouchableHighlight
      activeOpacity={0.6}
      underlayColor="#DDDDDD"
      onPress={() => alert('Pressed!')}>
      <MyComponent />
    </TouchableHighlight>;

 

Example 

------------------------------------------------------------------------

Reference

Props 

TouchableWithoutFeedback Props 

Inherits TouchableWithoutFeedback Props .

------------------------------------------------------------------------

 activeOpacity 

Determines what the opacity of the wrapped view should be when touch is
active. The value should be between 0 and 1. Defaults to 0.85. Requires
 underlayColor to be set.

  Type
  --------
  number

------------------------------------------------------------------------

 onHideUnderlay 

Called immediately after the underlay is hidden.

  Type
  ----------
  function

------------------------------------------------------------------------

 onShowUnderlay 

Called immediately after the underlay is shown.

  Type
  ----------
  function

------------------------------------------------------------------------

 style 

  Type
  ------------
  View.style

------------------------------------------------------------------------

 underlayColor 

The color of the underlay that will show through when the touch is
active.

  Type
  -------
  color

------------------------------------------------------------------------

 hasTVPreferredFocus

iOS



(Apple TV only) TV preferred focus (see documentation for the View
component).

  Type
  ------
  bool

------------------------------------------------------------------------

 nextFocusDown

Android



TV next focus down (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusForward

Android



TV next focus forward (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusLeft

Android



TV next focus left (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusRight

Android



TV next focus right (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusUp

Android



TV next focus up (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 testOnly_pressed 

Handy for snapshot tests.

  Type
  ------
  bool

# TouchableNativeFeedback #
 _____                _           _     _      _   _       _   _           
|_   _|__  _   _  ___| |__   __ _| |__ | | ___| \ | | __ _| |_(_)_   _____ 
  | |/ _ \| | | |/ __| '_ \ / _` | '_ \| |/ _ \  \| |/ _` | __| \ \ / / _ \
  | | (_) | |_| | (__| | | | (_| | |_) | |  __/ |\  | (_| | |_| |\ V /  __/
  |_|\___/ \__,_|\___|_| |_|\__,_|_.__/|_|\___|_| \_|\__,_|\__|_| \_/ \___|
                                                                           
 _____             _ _                _    
|  ___|__  ___  __| | |__   __ _  ___| | __
| |_ / _ \/ _ \/ _` | '_ \ / _` |/ __| |/ /
|  _|  __/  __/ (_| | |_) | (_| | (__|   < 
|_|  \___|\___|\__,_|_.__/ \__,_|\___|_|\_\
                                           
-   Example
-   Props
    -   TouchableWithoutFeedback Props
    -    background
    -    useForeground
    -    hasTVPreferredFocus
        Android
    -    nextFocusDown
        Android
    -    nextFocusForward
        Android
    -    nextFocusLeft
        Android
    -    nextFocusRight
        Android
    -    nextFocusUp
        Android
-   Methods
    -    SelectableBackground()
    -    SelectableBackgroundBorderless()
    -    Ripple()
    -    canUseNativeForeground()
TouchableNativeFeedback

  If you're looking for a more extensive and future-proof way to handle
  touch-based input, check out the Pressable API.

A wrapper for making views respond properly to touches (Android only).
On Android this component uses native state drawable to display touch
feedback.

At the moment it only supports having a single View instance as a child
node, as it's implemented by replacing that View with another instance
of RCTView node with some additional properties set.

Background drawable of native feedback touchable can be customized with
 background property.

Example 

------------------------------------------------------------------------

Reference

Props 

TouchableWithoutFeedback Props 

Inherits TouchableWithoutFeedback Props .

------------------------------------------------------------------------

 background 

Determines the type of background drawable that's going to be used to
display feedback. It takes an object with  type property and extra data
depending on the  type . It's recommended to use one of the static
methods to generate that dictionary.

  Type
  --------------------
  backgroundPropType

------------------------------------------------------------------------

 useForeground 

Set to true to add the ripple effect to the foreground of the view,
instead of the background. This is useful if one of your child views has
a background of its own, or you're e.g. displaying images, and you don't
want the ripple to be covered by them.

Check TouchableNativeFeedback.canUseNativeForeground() first, as this is
only available on Android 6.0 and above. If you try to use this on older
versions you will get a warning and fallback to background.

  Type
  ------
  bool

------------------------------------------------------------------------

 hasTVPreferredFocus

Android



TV preferred focus (see documentation for the View component).

  Type
  ------
  bool

------------------------------------------------------------------------

 nextFocusDown

Android



TV next focus down (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusForward

Android



TV next focus forward (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusLeft

Android



TV next focus left (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusRight

Android



TV next focus right (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusUp

Android



TV next focus up (see documentation for the View component).

  Type
  --------
  number

Methods 

 SelectableBackground() 

    static SelectableBackground(
      rippleRadius: number | null,
    ): ThemeAttributeBackgroundPropType;

 

Creates an object that represents android theme's default background for
selectable elements (  ?android:attr/selectableItemBackground ).
 rippleRadius parameter controls the radius of the ripple effect.

------------------------------------------------------------------------

 SelectableBackgroundBorderless() 

    static SelectableBackgroundBorderless(
      rippleRadius: number | null,
    ): ThemeAttributeBackgroundPropType;

 

Creates an object that represent android theme's default background for
borderless selectable elements (
 ?android:attr/selectableItemBackgroundBorderless ). Available on
android API level 21+.  rippleRadius parameter controls the radius of
the ripple effect.

------------------------------------------------------------------------

 Ripple() 

    static Ripple(
      color: ColorValue,
      borderless: boolean,
      rippleRadius?: number | null,
    ): RippleBackgroundPropType;

 

Creates an object that represents ripple drawable with specified color
(as a string). If property  borderless evaluates to true the ripple will
render outside of the view bounds (see native actionbar buttons as an
example of that behavior). This background type is available on Android
API level 21+.

Parameters:

  Name           Type      Required   Description
  -------------- --------- ---------- ---------------------------------------------
  color          string    Yes        The ripple color
  borderless     boolean   Yes        If the ripple can render outside its bounds
  rippleRadius   ?number   No         controls the radius of the ripple effect

------------------------------------------------------------------------

 canUseNativeForeground() 

    static canUseNativeForeground(): boolean;

 

# TouchableOpacity #
 _____                _           _     _       ___                   _ _   
|_   _|__  _   _  ___| |__   __ _| |__ | | ___ / _ \ _ __   __ _  ___(_) |_ 
  | |/ _ \| | | |/ __| '_ \ / _` | '_ \| |/ _ \ | | | '_ \ / _` |/ __| | __|
  | | (_) | |_| | (__| | | | (_| | |_) | |  __/ |_| | |_) | (_| | (__| | |_ 
  |_|\___/ \__,_|\___|_| |_|\__,_|_.__/|_|\___|\___/| .__/ \__,_|\___|_|\__|
                                                    |_|                     
       
 _   _ 
| | | |
| |_| |
 \__, |
 |___/ 
-   Example
-   Props
    -   TouchableWithoutFeedback Props
    -    style
    -    activeOpacity
    -    tvParallaxProperties
        IOS
    -    hasTVPreferredFocus
        iOS
    -    nextFocusDown
        Android
    -    nextFocusForward
        Android
    -    nextFocusLeft
        Android
    -    nextFocusRight
        Android
    -    nextFocusUp
        Android
TouchableOpacity

  If you're looking for a more extensive and future-proof way to handle
  touch-based input, check out the Pressable API.

A wrapper for making views respond properly to touches. On press down,
the opacity of the wrapped view is decreased, dimming it.

Opacity is controlled by wrapping the children in an  Animated.View ,
which is added to the view hierarchy. Be aware that this can affect
layout.

Example 

------------------------------------------------------------------------

Reference

Props 

TouchableWithoutFeedback Props 

Inherits TouchableWithoutFeedback Props .

------------------------------------------------------------------------

 style 

  Type
  ------------
  View.style

------------------------------------------------------------------------

 activeOpacity 

Determines what the opacity of the wrapped view should be when touch is
active. Defaults to  0.2 .

  Type
  --------
  number

------------------------------------------------------------------------

 tvParallaxProperties

IOS



(Apple TV only) Object with properties to control Apple TV parallax
effects.

-    enabled : If  true , parallax effects are enabled. Defaults to
     true .
-    shiftDistanceX : Defaults to  2.0 .
-    shiftDistanceY : Defaults to  2.0 .
-    tiltAngle : Defaults to  0.05 .
-    magnification : Defaults to  1.0 .
-    pressMagnification : Defaults to  1.0 .
-    pressDuration : Defaults to  0.3 .
-    pressDelay : Defaults to  0.0 .

  Type
  --------
  object

------------------------------------------------------------------------

 hasTVPreferredFocus

iOS



(Apple TV only) TV preferred focus (see documentation for the View
component).

  Type
  ------
  bool

------------------------------------------------------------------------

 nextFocusDown

Android



TV next focus down (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusForward

Android



TV next focus forward (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusLeft

Android



TV next focus left (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusRight

Android



TV next focus right (see documentation for the View component).

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusUp

Android



TV next focus up (see documentation for the View component).

  Type
  --------
  number

# TouchableWithoutFeedback #
 _____                _           _     _    __        ___ _   _           
|_   _|__  _   _  ___| |__   __ _| |__ | | __\ \      / (_) |_| |__   ___  
  | |/ _ \| | | |/ __| '_ \ / _` | '_ \| |/ _ \ \ /\ / /| | __| '_ \ / _ \ 
  | | (_) | |_| | (__| | | | (_| | |_) | |  __/\ V  V / | | |_| | | | (_) |
  |_|\___/ \__,_|\___|_| |_|\__,_|_.__/|_|\___| \_/\_/  |_|\__|_| |_|\___/ 
                                                                           
       _   _____             _ _                _    
 _   _| |_|  ___|__  ___  __| | |__   __ _  ___| | __
| | | | __| |_ / _ \/ _ \/ _` | '_ \ / _` |/ __| |/ /
| |_| | |_|  _|  __/  __/ (_| | |_) | (_| | (__|   < 
 \__,_|\__|_|  \___|\___|\__,_|_.__/ \__,_|\___|_|\_\
                                                     
-   Usage Pattern
-   Example
-   Props
    -    accessibilityIgnoresInvertColors
    -    accessible
    -    accessibilityLabel
    -    accessibilityLanguage
        iOS
    -    accessibilityHint
    -    accessibilityRole
    -    accessibilityState
    -    accessibilityActions
    -    aria-busy
    -    aria-checked
    -    aria-disabled
    -    aria-expanded
    -    aria-hidden
    -    aria-label
    -    aria-live
        Android
    -    aria-modal
        iOS
    -    aria-selected
    -    onAccessibilityAction
    -    accessibilityValue
    -    aria-valuemax
    -    aria-valuemin
    -    aria-valuenow
    -    aria-valuetext
    -    delayLongPress
    -    delayPressIn
    -    delayPressOut
    -    disabled
    -    hitSlop
    -    id
    -    onBlur
    -    onFocus
    -    onLayout
    -    onLongPress
    -    onPress
    -    onPressIn
    -    onPressOut
    -    pressRetentionOffset
    -    nativeID
    -    testID
    -    touchSoundDisabled
        Android
TouchableWithoutFeedback

  If you're looking for a more extensive and future-proof way to handle
  touch-based input, check out the Pressable API.

Do not use unless you have a very good reason. All elements that respond
to press should have a visual feedback when touched.

 TouchableWithoutFeedback supports only one child. If you wish to have
several child components, wrap them in a View. Importantly,
 TouchableWithoutFeedback works by cloning its child and applying
responder props to it. It is therefore required that any intermediary
components pass through those props to the underlying React Native
component.

Usage Pattern 

    function MyComponent(props: MyComponentProps) {
      return (
        <View {...props} style={{flex: 1, backgroundColor: '#fff'}}>
          <Text>My Component</Text>
        </View>
      );
    }

    <TouchableWithoutFeedback onPress={() => alert('Pressed!')}>
      <MyComponent />
    </TouchableWithoutFeedback>;

 

Example 

------------------------------------------------------------------------

Reference

Props 

 accessibilityIgnoresInvertColors 

  Type
  ---------
  Boolean

------------------------------------------------------------------------

 accessible 

When  true , indicates that the view is an accessibility element. By
default, all the touchable elements are accessible.

  Type
  ------
  bool

------------------------------------------------------------------------

 accessibilityLabel 

Overrides the text that's read by the screen reader when the user
interacts with the element. By default, the label is constructed by
traversing all the children and accumulating all the  Text nodes
separated by space.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityLanguage

iOS



A value indicating which language should be used by the screen reader
when the user interacts with the element. It should follow the BCP 47
specification .

See the iOS  accessibilityLanguage doc for more information.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityHint 

An accessibility hint helps users understand what will happen when they
perform an action on the accessibility element when that result is not
clear from the accessibility label.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityRole 

 accessibilityRole communicates the purpose of a component to the user
of an assistive technology.

 accessibilityRole can be one of the following:

-    'none' - Used when the element has no role.
-    'button' - Used when the element should be treated as a button.
-    'link' - Used when the element should be treated as a link.
-    'search' - Used when the text field element should also be treated
    as a search field.
-    'image' - Used when the element should be treated as an image. Can
    be combined with button or link, for example.
-    'keyboardkey' - Used when the element acts as a keyboard key.
-    'text' - Used when the element should be treated as static text
    that cannot change.
-    'adjustable' - Used when an element can be "adjusted" (e.g. a
    slider).
-    'imagebutton' - Used when the element should be treated as a button
    and is also an image.
-    'header' - Used when an element acts as a header for a content
    section (e.g. the title of a navigation bar).
-    'summary' - Used when an element can be used to provide a quick
    summary of current conditions in the app when the app first
    launches.
-    'alert' - Used when an element contains important text to be
    presented to the user.
-    'checkbox' - Used when an element represents a checkbox which can
    be checked, unchecked, or have mixed checked state.
-    'combobox' - Used when an element represents a combo box, which
    allows the user to select among several choices.
-    'menu' - Used when the component is a menu of choices.
-    'menubar' - Used when a component is a container of multiple menus.
-    'menuitem' - Used to represent an item within a menu.
-    'progressbar' - Used to represent a component which indicates
    progress of a task.
-    'radio' - Used to represent a radio button.
-    'radiogroup' - Used to represent a group of radio buttons.
-    'scrollbar' - Used to represent a scroll bar.
-    'spinbutton' - Used to represent a button which opens a list of
    choices.
-    'switch' - Used to represent a switch which can be turned on and
    off.
-    'tab' - Used to represent a tab.
-    'tablist' - Used to represent a list of tabs.
-    'timer' - Used to represent a timer.
-    'toolbar' - Used to represent a tool bar (a container of action
    buttons or components).

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityState 

Describes the current state of a component to the user of an assistive
technology.

See the Accessibility guide for more information.

  Type
  -------------------------------------------------------------------------------------------------
  object:  {disabled: bool, selected: bool, checked: bool or 'mixed', busy: bool, expanded: bool}

------------------------------------------------------------------------

 accessibilityActions 

Accessibility actions allow an assistive technology to programmatically
invoke the actions of a component. The  accessibilityActions property
should contain a list of action objects. Each action object should
contain the field name and label.

See the Accessibility guide for more information.

  Type
  -------
  array

------------------------------------------------------------------------

 aria-busy 

Indicates an element is being modified and that assistive technologies
may want to wait until the changes are complete before informing the
user about the update.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-checked 

Indicates the state of a checkable element. This field can either take a
boolean or the "mixed" string to represent mixed checkboxes.

  Type               Default
  ------------------ ---------
  boolean, 'mixed'   false

------------------------------------------------------------------------

 aria-disabled 

Indicates that the element is perceivable but disabled, so it is not
editable or otherwise operable.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-expanded 

Indicates whether an expandable element is currently expanded or
collapsed.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-hidden 

Indicates whether the accessibility elements contained within this
accessibility element are hidden.

For example, in a window that contains sibling views  A and  B , setting
 aria-hidden to  true on view  B causes VoiceOver to ignore the elements
in the view  B .

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-label 

Defines a string value that labels an interactive element.

  Type
  --------
  string

------------------------------------------------------------------------

 aria-live

Android



Indicates that an element will be updated, and describes the types of
updates the user agents, assistive technologies, and user can expect
from the live region.

-   off Accessibility services should not announce changes to this view.
-   polite Accessibility services should announce changes to this view.
-   assertive Accessibility services should interrupt ongoing speech to
    immediately announce changes to this view.

  Type                                        Default
  ------------------------------------------- ---------
  enum(  'assertive' ,  'off' ,  'polite' )    'off'

------------------------------------------------------------------------

 aria-modal

iOS



Boolean value indicating whether VoiceOver should ignore the elements
within views that are siblings of the receiver. Has precedence over the
 accessibilityViewIsModal prop.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-selected 

Indicates whether a selectable element is currently selected or not.

  Type
  ---------
  boolean

 onAccessibilityAction 

Invoked when the user performs the accessibility actions. The only
argument to this function is an event containing the name of the action
to perform.

See the Accessibility guide for more information.

  Type
  ----------
  function

------------------------------------------------------------------------

 accessibilityValue 

Represents the current value of a component. It can be a textual
description of a component's value, or for range-based components, such
as sliders and progress bars, it contains range information (minimum,
current, and maximum).

See the Accessibility guide for more information.

  Type
  ----------------------------------------------------------------
  object:  {min: number, max: number, now: number, text: string}

------------------------------------------------------------------------

 aria-valuemax 

Represents the maximum value for range-based components, such as sliders
and progress bars. Has precedence over the  max value in the
 accessibilityValue prop.

  Type
  --------
  number

------------------------------------------------------------------------

 aria-valuemin 

Represents the minimum value for range-based components, such as sliders
and progress bars. Has precedence over the  min value in the
 accessibilityValue prop.

  Type
  --------
  number

------------------------------------------------------------------------

 aria-valuenow 

Represents the current value for range-based components, such as sliders
and progress bars. Has precedence over the  now value in the
 accessibilityValue prop.

  Type
  --------
  number

------------------------------------------------------------------------

 aria-valuetext 

Represents the textual description of the component. Has precedence over
the  text value in the  accessibilityValue prop.

  Type
  --------
  string

------------------------------------------------------------------------

 delayLongPress 

Duration (in milliseconds) from  onPressIn before  onLongPress is
called.

  Type
  --------
  number

------------------------------------------------------------------------

 delayPressIn 

Duration (in milliseconds), from the start of the touch, before
 onPressIn is called.

  Type
  --------
  number

------------------------------------------------------------------------

 delayPressOut 

Duration (in milliseconds), from the release of the touch, before
 onPressOut is called.

  Type
  --------
  number

------------------------------------------------------------------------

 disabled 

If true, disable all interactions for this component.

  Type
  ------
  bool

------------------------------------------------------------------------

 hitSlop 

This defines how far your touch can start away from the button. This is
added to  pressRetentionOffset when moving off of the button.

  The touch area never extends past the parent view bounds and the
  Z-index of sibling views always takes precedence if a touch hits two
  overlapping views.

  Type
  ----------------
  Rect or number

 id 

Used to locate this view from native code. Has precedence over  nativeID
prop.

  Type
  --------
  string

------------------------------------------------------------------------

 onBlur 

Invoked when the item loses focus.

  Type
  ----------
  function

------------------------------------------------------------------------

 onFocus 

Invoked when the item receives focus.

  Type
  ----------
  function

------------------------------------------------------------------------

 onLayout 

Invoked on mount and on layout changes.

  Type
  ------------------------------------------
   ({nativeEvent:  LayoutEvent  }) => void

------------------------------------------------------------------------

 onLongPress 

Called if the time after  onPressIn lasts longer than 370 milliseconds.
This time period can be customized with  delayLongPress .

  Type
  ----------
  function

------------------------------------------------------------------------

 onPress 

Called when the touch is released, but not if cancelled (e.g. by a
scroll that steals the responder lock). The first function argument is
an event in form of PressEvent .

  Type
  ----------
  function

------------------------------------------------------------------------

 onPressIn 

Called as soon as the touchable element is pressed and invoked even
before onPress. This can be useful when making network requests. The
first function argument is an event in form of PressEvent .

  Type
  ----------
  function

------------------------------------------------------------------------

 onPressOut 

Called as soon as the touch is released even before onPress. The first
function argument is an event in form of PressEvent .

  Type
  ----------
  function

------------------------------------------------------------------------

 pressRetentionOffset 

When the scroll view is disabled, this defines how far your touch may
move off of the button, before deactivating the button. Once
deactivated, try moving it back and you'll see that the button is once
again reactivated! Move it back and forth several times while the scroll
view is disabled. Ensure you pass in a constant to reduce memory
allocations.

  Type
  ----------------
  Rect or number

------------------------------------------------------------------------

 nativeID 

  Type
  --------
  string

------------------------------------------------------------------------

 testID 

Used to locate this view in end-to-end tests.

  Type
  --------
  string

------------------------------------------------------------------------

 touchSoundDisabled

Android



If true, doesn't play a system sound on touch.

  Type
  ---------
  Boolean

# Transforms #
 _____                     __                          
|_   _| __ __ _ _ __  ___ / _| ___  _ __ _ __ ___  ___ 
  | || '__/ _` | '_ \/ __| |_ / _ \| '__| '_ ` _ \/ __|
  | || | | (_| | | | \__ \  _| (_) | |  | | | | | \__ \
  |_||_|  \__,_|_| |_|___/_|  \___/|_|  |_| |_| |_|___/
                                                       
-   Example
-   Transform
    -    decomposedMatrix ,  rotation ,  scaleX ,  scaleY ,
         transformMatrix ,  translateX ,  translateY
-   Transform Origin
    -   Values
Transforms

Transforms are style properties that will help you modify the appearance
and position of your components using 2D or 3D transformations. However,
once you apply transforms, the layouts remain the same around the
transformed component hence it might overlap with the nearby components.
You can apply margin to the transformed component, the nearby components
or padding to the container to prevent such overlaps.

Example 

------------------------------------------------------------------------

Reference

Transform 

 transform accepts an array of transformation objects or space-separated
string values. Each object specifies the property that will be
transformed as the key, and the value to use in the transformation.
Objects should not be combined. Use a single key/value pair per object.

The rotate transformations require a string so that the transform may be
expressed in degrees (deg) or radians (rad). For example:

    {
      transform: [{rotateX: '45deg'}, {rotateZ: '0.785398rad'}],
    }

 

The same could also be achieved using a space-separated string:

    {
      transform: 'rotateX(45deg) rotateZ(0.785398rad)',
    }

 

The skew transformations require a string so that the transform may be
expressed in degrees (deg). For example:

    {
      transform: [{skewX: '45deg'}],
    }

 

  Type                                                                                                                                                                                                                                                                                                           Required
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- ----------
  array of objects:  {matrix: number} ,  {perspective: number} ,  {rotate: string} ,  {rotateX: string} ,  {rotateY: string} ,  {rotateZ: string} ,  {scale: number} ,  {scaleX: number} ,  {scaleY: number} ,  {translateX: number} ,  {translateY: number} ,  {skewX: string} ,  {skewY: string} or string   No

------------------------------------------------------------------------

 decomposedMatrix ,  rotation ,  scaleX ,  scaleY ,  transformMatrix ,  translateX ,  translateY 

  Deprecated. Use the  transform prop instead.

Transform Origin 

The  transformOrigin property sets the origin for a view's
transformations. The transform origin is the point around which a
transformation is applied. By default, the origin of a transform is
 center .

Example

Values 

Transform origin supports  px ,  percentage and keywords  top ,  left ,
 right ,  bottom ,  center values.

The  transformOrigin property may be specified using one, two, or three
values, where each value represents an offset.

One-value syntax: 

-   The value must be a  px , a  percentage , or one of the keywords
     left ,  center ,  right ,  top , and  bottom .

    {
      transformOrigin: '20px',
      transformOrigin: 'bottom',
    }

 

Two-value syntax: 

-   First value (x-offset) must be a  px , a  percentage , or one of the
    keywords  left ,  center , and  right .
-   The second value (y-offset) must be a  px , a  percentage , or one
    of the keywords  top ,  center , and  bottom .

    {
      transformOrigin: '10px 2px',
      transformOrigin: 'left top',
      transformOrigin: 'top right',
    }

 

Three-value syntax: 

-   The first two values are the same as for the two-value syntax.
-   The third value (z-offset) must be a  px . It always represents the
    Z offset.

    {
      transformOrigin: '2px 30% 10px',
      transformOrigin: 'right bottom 20px',
    }

 

Array syntax 

 transformOrigin also supports an array syntax. It makes it convenient
to use it with Animated APIs. It also avoids string parsing, so should
be more efficient.

    {
      // Using numeric values
      transformOrigin: [10, 30, 40],
      // Mixing numeric and percentage values
      transformOrigin: [10, '20%', 0],
    }

 

You may refer to MDN's guide on Transform origin for additional
information.

# Troubleshooting #
 _____                _     _           _                 _   _             
|_   _| __ ___  _   _| |__ | | ___  ___| |__   ___   ___ | |_(_)_ __   __ _ 
  | || '__/ _ \| | | | '_ \| |/ _ \/ __| '_ \ / _ \ / _ \| __| | '_ \ / _` |
  | || | | (_) | |_| | |_) | |  __/\__ \ | | | (_) | (_) | |_| | | | | (_| |
  |_||_|  \___/ \__,_|_.__/|_|\___||___/_| |_|\___/ \___/ \__|_|_| |_|\__, |
                                                                      |___/ 
-   Port already in use
-   NPM locking error
-   Missing libraries for React
-   No transports available
-   Shell Command Unresponsive Exception
-   react-native init hangs
-   Unable to start react-native package manager (on Linux)
    -   Case 1: Error "code":"ENOSPC","errno":"ENOSPC"
    -   Error: spawnSync ./gradlew EACCES
Troubleshooting

These are some common issues you may run into while setting up React
Native. If you encounter something that is not listed here, try
searching for the issue in GitHub .

Port already in use 

The Metro bundler runs on port 8081. If another process is already using
that port, you can either terminate that process, or change the port
that the bundler uses.

Terminating a process on port 8081 

Run the following command to find the id for the process that is
listening on port 8081:

    sudo lsof -i :8081

 

Then run the following to terminate the process:

    kill -9 <PID>

 

On Windows you can find the process using port 8081 using Resource
Monitor and stop it using Task Manager.

Using a port other than 8081 

You can configure the bundler to use a port other than 8081 by using the
 port parameter, from the root of your project run:

-   npm
-   Yarn

    npm start -- --port=8088

 

    yarn start --port 8088

 

You will also need to update your applications to load the JavaScript
bundle from the new port. If running on device from Xcode, you can do
this by updating occurrences of  8081 to your chosen port in the
 ios/__App_Name__.xcodeproj/project.pbxproj file.

NPM locking error 

If you encounter an error such as  npm WARN locking Error: EACCES while
using the React Native CLI, try running the following:

    sudo chown -R $USER ~/.npm
    sudo chown -R $USER /usr/local/lib/node_modules

 

Missing libraries for React 

If you added React Native manually to your project, make sure you have
included all the relevant dependencies that you are using, like
 RCTText.xcodeproj ,  RCTImage.xcodeproj . Next, the binaries built by
these dependencies have to be linked to your app binary. Use the
 Linked Frameworks and Binaries section in the Xcode project settings.
More detailed steps are here: Linking Libraries .

If you are using CocoaPods, verify that you have added React along with
the subspecs to the  Podfile . For example, if you were using the
 <Text /> ,  <Image /> and  fetch() APIs, you would need to add these in
your  Podfile :

    pod 'React', :path => '../node_modules/react-native', :subspecs => [
      'RCTText',
      'RCTImage',
      'RCTNetwork',
      'RCTWebSocket',
    ]

 

Next, make sure you have run  pod install and that a  Pods/ directory
has been created in your project with React installed. CocoaPods will
instruct you to use the generated  .xcworkspace file henceforth to be
able to use these installed dependencies.

React Native does not compile when being used as a CocoaPod 

There is a CocoaPods plugin called cocoapods-fix-react-native which
handles any potential post-fixing of the source code due to differences
when using a dependency manager.

Argument list too long: recursive header expansion failed 

In the project's build settings,  User Search Header Paths and
 Header Search Paths are two configs that specify where Xcode should
look for  #import header files specified in the code. For Pods,
CocoaPods uses a default array of specific folders to look in. Verify
that this particular config is not overwritten, and that none of the
folders configured are too large. If one of the folders is a large
folder, Xcode will attempt to recursively search the entire directory
and throw above error at some point.

To revert the  User Search Header Paths and  Header Search Paths build
settings to their defaults set by CocoaPods - select the entry in the
Build Settings panel, and hit delete. It will remove the custom override
and return to the CocoaPod defaults.

No transports available 

React Native implements a polyfill for WebSockets. These polyfills are
initialized as part of the react-native module that you include in your
application through  import React from 'react' . If you load another
module that requires WebSockets, such as Firebase , be sure to
load/require it after react-native:

    import React from 'react';
    import Firebase from 'firebase';

 

Shell Command Unresponsive Exception 

If you encounter a ShellCommandUnresponsiveException exception such as:

    Execution failed for task ':app:installDebug'.
      com.android.builder.testing.api.DeviceException: com.android.ddmlib.ShellCommandUnresponsiveException

 

Try downgrading your Gradle version to 1.2.3 in  android/build.gradle .

react-native init hangs 

If you run into issues where running  npx react-native init hangs in
your system, try running it again in verbose mode and referring to #2797
for common causes:

    npx react-native init --verbose

 

When you're debugging a process or need to know a little more about the
error being thrown, you may want to use the verbose option to output
more logs and information to nail down your issue.

Run the following command in your project's root directory.

-   npm
-   Yarn

    npm run android -- --verbose

 

    yarn android --verbose

 

Unable to start react-native package manager (on Linux) 

Case 1: Error "code":"ENOSPC","errno":"ENOSPC" 

Issue caused by the number of directories inotify (used by watchman on
Linux) can monitor. To solve it, run this command in your terminal
window

    echo fs.inotify.max_user_watches=582222 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p

 

Error: spawnSync ./gradlew EACCES 

If you run into issue where executing  npm run android or  yarn android
on macOS throws the above error, try to run
 sudo chmod +x android/gradlew command to make  gradlew files into
executable.

# Upgrading to new versions #
 _   _                           _ _               _        
| | | |_ __   __ _ _ __ __ _  __| (_)_ __   __ _  | |_ ___  
| | | | '_ \ / _` | '__/ _` |/ _` | | '_ \ / _` | | __/ _ \ 
| |_| | |_) | (_| | | | (_| | (_| | | | | | (_| | | || (_) |
 \___/| .__/ \__, |_|  \__,_|\__,_|_|_| |_|\__, |  \__\___/ 
      |_|    |___/                         |___/            
                                          _                 
 _ __   _____      __ __   _____ _ __ ___(_) ___  _ __  ___ 
| '_ \ / _ \ \ /\ / / \ \ / / _ \ '__/ __| |/ _ \| '_ \/ __|
| | | |  __/\ V  V /   \ V /  __/ |  \__ \ | (_) | | | \__ \
|_| |_|\___| \_/\_/     \_/ \___|_|  |___/_|\___/|_| |_|___/
                                                            
-   Expo projects
-   React Native projects
    -   1. Select the versions
    -   2. Upgrade dependencies
    -   3. Upgrade your project files
    -   Troubleshooting
Upgrading to new versions

Upgrading to new versions of React Native will give you access to more
APIs, views, developer tools and other goodies. Upgrading requires a
small amount of effort, but we try to make it straightforward for you.

Expo projects 

Upgrading your Expo project to a new version of React Native requires
updating the  react-native ,  react , and  expo package versions in your
 package.json file. Expo provides an  upgrade command to handle
upgrading these and any other known dependencies for you. See the
Upgrading Expo SDK Walkthrough for up-to-date information about
upgrading your project.

React Native projects 

Because typical React Native projects are essentially made up of an
Android project, an iOS project, and a JavaScript project, upgrading can
be rather tricky. The Upgrade Helper is a web tool to help you out when
upgrading your apps by providing the full set of changes happening
between any two versions. It also shows comments on specific files to
help understanding why that change is needed.

1. Select the versions 

You first need to select from and to which version you wish to upgrade,
by default the latest major versions are selected. After selecting you
can click the button "Show me how to upgrade".

💡 Major updates will show an "useful content" section on the top with
links to help you out when upgrading.

 tip

Or you can run the  npx react-native upgrade , which will automatically
check your current version and the latest version available and will
show you the link to the Upgrade Helper page with the versions already
selected.

2. Upgrade dependencies 

The first file that is shown is the  package.json , it's good to update
the dependencies that are showing in there. For example, if
 react-native and  react appears as changes then you can install it in
your project by running following commands:

-   npm
-   Yarn

    # {{VERSION}} and {{REACT_VERSION}} are the release versions showing in the diff
    npm install react-native@{{VERSION}}
    npm install react@{{REACT_VERSION}}

 

    # {{VERSION}} and {{REACT_VERSION}} are the release versions showing in the diff
    yarn add react-native@{{VERSION}}
    yarn add react@{{REACT_VERSION}}

 

3. Upgrade your project files 

The new release may contain updates to other files that are generated
when you run  npx react-native init , those files are listed after the
 package.json in the Upgrade Helper page. If there aren't other changes
then you only need to rebuild the project to continue developing.

In case there are changes then you can either update them manually by
copying and pasting from the changes in the page or you can do it with
the React Native CLI upgrade command by running:

    npx react-native upgrade

 

This will check your files against the latest template and perform the
following:

-   If there is a new file in the template, it is created.
-   If a file in the template is identical to your file, it is skipped.
-   If a file is different in your project than the template, you will
    be prompted; you have options to keep your file or overwrite it with
    the template version.

  Some upgrades won't be done automatically with the React Native CLI
  and require manual work, e.g.  0.28 to  0.29 , or  0.56 to  0.57 .
  Make sure to check the release notes when upgrading so that you can
  identify any manual changes your particular project may require.

Troubleshooting 

I have done all the changes but my app is still using an old version 

These sort of errors are usually related to caching, it's recommended to
install react-native-clean-project to clear all your project's cache and
then you can run it again.

# useColorScheme #
                 ____      _            ____       _                         
 _   _ ___  ___ / ___|___ | | ___  _ __/ ___|  ___| |__   ___ _ __ ___   ___ 
| | | / __|/ _ \ |   / _ \| |/ _ \| '__\___ \ / __| '_ \ / _ \ '_ ` _ \ / _ \
| |_| \__ \  __/ |__| (_) | | (_) | |   ___) | (__| | | |  __/ | | | | |  __/
 \__,_|___/\___|\____\___/|_|\___/|_|  |____/ \___|_| |_|\___|_| |_| |_|\___|
                                                                             
-   Supported color schemes
-   Example
useColorScheme

    import {useColorScheme} from 'react-native';

 

The  useColorScheme React hook provides and subscribes to color scheme
updates from the  Appearance module. The return value indicates the
current user preferred color scheme. The value may be updated later,
either through direct user action (e.g. theme selection in device
settings) or on a schedule (e.g. light and dark themes that follow the
day/night cycle).

Supported color schemes 

-    "light" : The user prefers a light color theme.
-    "dark" : The user prefers a dark color theme.
-    null : The user has not indicated a preferred color theme.

  Note: Currently due to technical constraints, when the Chrome debugger
  is enabled, this hook will always return  "light" .

------------------------------------------------------------------------

Example 

You can find a complete example that demonstrates the use of this hook
alongside a React context to add support for light and dark themes to
your application in  AppearanceExample.js .

# useWindowDimensions #
              __        ___           _               ____  _                
 _   _ ___  __\ \      / (_)_ __   __| | _____      _|  _ \(_)_ __ ___   ___ 
| | | / __|/ _ \ \ /\ / /| | '_ \ / _` |/ _ \ \ /\ / / | | | | '_ ` _ \ / _ \
| |_| \__ \  __/\ V  V / | | | | | (_| | (_) \ V  V /| |_| | | | | | | |  __/
 \__,_|___/\___| \_/\_/  |_|_| |_|\__,_|\___/ \_/\_/ |____/|_|_| |_| |_|\___|
                                                                             
           _                 
 _ __  ___(_) ___  _ __  ___ 
| '_ \/ __| |/ _ \| '_ \/ __|
| | | \__ \ | (_) | | | \__ \
|_| |_|___/_|\___/|_| |_|___/
                             
-   Example
-   Properties
    -    fontScale
    -    height
    -    scale
    -    width
useWindowDimensions

    import {useWindowDimensions} from 'react-native';

 

 useWindowDimensions automatically updates all of its values when screen
size or font scale changes. You can get your application window's width
and height like so:

    const {height, width} = useWindowDimensions();

 

Example 

Properties 

 fontScale 

    useWindowDimensions().fontScale;

 

The scale of the font currently used. Some operating systems allow users
to scale their font sizes larger or smaller for reading comfort. This
property will let you know what is in effect.

------------------------------------------------------------------------

 height 

    useWindowDimensions().height;

 

The height in pixels of the window or screen your app occupies.

------------------------------------------------------------------------

 scale 

    useWindowDimensions().scale;

 

The pixel ratio of the device your app is running on. The values can be:

-    1 which indicates that one point equals one pixel (usually PPI/DPI
    of 96, 76 on some platforms).
-    2 or  3 which indicates a Retina or high DPI display.

------------------------------------------------------------------------

 width 

    useWindowDimensions().width;

 

The width in pixels of the window or screen your app occupies.

# Using a ScrollView #
 _   _     _                     
| | | |___(_)_ __   __ _    __ _ 
| | | / __| | '_ \ / _` |  / _` |
| |_| \__ \ | | | | (_| | | (_| |
 \___/|___/_|_| |_|\__, |  \__,_|
                   |___/         
 ____                 _ ___     ___               
/ ___|  ___ _ __ ___ | | \ \   / (_) _____      __
\___ \ / __| '__/ _ \| | |\ \ / /| |/ _ \ \ /\ / /
 ___) | (__| | | (_) | | | \ V / | |  __/\ V  V / 
|____/ \___|_|  \___/|_|_|  \_/  |_|\___| \_/\_/  
                                                  

Using a ScrollView

The ScrollView is a generic scrolling container that can contain
multiple components and views. The scrollable items can be
heterogeneous, and you can scroll both vertically and horizontally (by
setting the  horizontal property).

This example creates a vertical  ScrollView with both images and text
mixed together.

ScrollViews can be configured to allow paging through views using
swiping gestures by using the  pagingEnabled props. Swiping horizontally
between views can also be implemented on Android using the ViewPager
component.

On iOS a ScrollView with a single item can be used to allow the user to
zoom content. Set up the  maximumZoomScale and  minimumZoomScale props
and your user will be able to use pinch and expand gestures to zoom in
and out.

The ScrollView works best to present a small number of things of a
limited size. All the elements and views of a  ScrollView are rendered,
even if they are not currently shown on the screen. If you have a long
list of items which cannot fit on the screen, you should use a  FlatList
instead. So let's learn about list views next.

# Using Hermes #
 _   _     _               _   _                               
| | | |___(_)_ __   __ _  | | | | ___ _ __ _ __ ___   ___  ___ 
| | | / __| | '_ \ / _` | | |_| |/ _ \ '__| '_ ` _ \ / _ \/ __|
| |_| \__ \ | | | | (_| | |  _  |  __/ |  | | | | | |  __/\__ \
 \___/|___/_|_| |_|\__, | |_| |_|\___|_|  |_| |_| |_|\___||___/
                   |___/                                       
-   Bundled Hermes
-   Confirming Hermes is in use
-   Debugging JS on Hermes using Google Chrome's DevTools
-   Enabling Hermes on Older Versions of React Native
    -   Android
    -   iOS
-   Switching back to JavaScriptCore
    -   Android
    -   iOS
Using Hermes



Hermes is an open-source JavaScript engine optimized for React Native.
For many apps, using Hermes will result in improved start-up time,
decreased memory usage, and smaller app size when compared to
JavaScriptCore. Hermes is used by default by React Native and no
additional configuration is required to enable it.

Bundled Hermes 

React Native comes with a bundled version of Hermes. We will be building
a version of Hermes for you whenever we release a new version of React
Native. This will make sure you're consuming a version of Hermes which
is fully compatible with the version of React Native you're using.

Historically, we had problems with matching versions of Hermes with
versions of React Native. This fully eliminates this problem, and offers
users a JS engine that is compatible with the specific React Native
version.

This change is fully transparent to users of React Native. You can still
disable Hermes using the command described in this page. You can read
more about the technical implementation on this page .

Confirming Hermes is in use 

If you've recently created a new app from scratch, you should see if
Hermes is enabled in the welcome view:

[Where to find JS engine status in AwesomeProject]

A  HermesInternal global variable will be available in JavaScript that
can be used to verify that Hermes is in use:

    const isHermes = () => !!global.HermesInternal;

 

 caution

If you are using a non-standard way of loading the JS bundle, it is
possible that the  HermesInternal variable is available but you aren't
using the highly optimised pre-compiled bytecode. Confirm that you are
using the  .hbc file and also benchmark the before/after as detailed
below.

To see the benefits of Hermes, try making a release build/deployment of
your app to compare. For example; from the root of your project:

-   Android
-   iOS

-   npm
-   Yarn

    npm run android -- --mode="release"

 

    yarn android --mode release

 

-   npm
-   Yarn

    npm run ios -- --mode="Release"

 

    yarn ios --mode Release

 

This will compile JavaScript to bytecode during build time which will
improve your app's startup speed on device.

Debugging JS on Hermes using Google Chrome's DevTools 

Hermes supports the Chrome debugger by implementing the Chrome inspector
protocol. This means Chrome's tools can be used to directly debug
JavaScript running on Hermes, on an emulator or on a real, physical,
device.

 info

Note that this is very different with the deprecated "Remote JS
Debugging" from the In-App Dev Menu documented in the Debugging section,
which actually runs the JS code on Chrome's V8 on your development
machine (laptop or desktop) instead of connecting to the JS engine
running the app on your device.

Chrome connects to Hermes running on device via Metro, so you'll need to
know where Metro is listening. Typically this will be on  localhost:8081
, but this is configurable . When running  yarn start the address is
written to stdout on startup.

Once you know where the Metro server is listening, you can connect with
Chrome using the following steps:

1.  Navigate to  chrome://inspect in a Chrome browser instance.

2.  Use the  Configure... button to add the Metro server address
    (typically  localhost:8081 as described above).

[Configure button in Chrome DevTools devices page]

[Dialog for adding Chrome DevTools network targets]

3.  You should now see a "Hermes React Native" target with an "inspect"
    link which can be used to bring up debugger. If you don't see the
    "inspect" link, make sure the Metro server is running. [Target
    inspect link]

4.  You can now use the Chrome debug tools. For example, to breakpoint
    the next time some JavaScript is run, click on the pause button and
    trigger an action in your app which would cause JavaScript to
    execute. [Pause button in debug tools]

Enabling Hermes on Older Versions of React Native 

Hermes is the default engine as of React Native 0.70. This section
explains how to enable Hermes on older versions of React Native. First,
ensure you're using at least version 0.60.4 of React Native to enable
Hermes on Android or 0.64 of React Native to enable Hermes on iOS.

If you have an existing app based on an earlier version of React Native,
you will have to upgrade it first. See Upgrading to new React Native
Versions for how to do this. After upgrading the app, make sure
everything works before trying to switch to Hermes.

 Note for React Native compatibility

Each Hermes release is aimed at a specific RN version. The rule of thumb
is to always follow Hermes releases strictly. Version mismatch can
result in instant crash of your apps in the worst case scenario.

 Note for Windows users

Hermes requires Microsoft Visual C++ 2015 Redistributable .

Android 

Edit your  android/gradle.properties file and make sure  hermesEnabled
is true:

    # Use this property to enable or disable the Hermes JS engine.
    # If set to false, you will be using JSC instead.
    hermesEnabled=true

 

 note

This property was added in React Native 0.71. If you can't find it in
your  gradle.properties file, please refer to the documentation for the
corresponding React Native version you're using.

Also, if you're using ProGuard, you will need to add these rules in
 proguard-rules.pro :

    -keep class com.facebook.hermes.unicode.** { *; }
    -keep class com.facebook.jni.** { *; }

 

Next, if you've already built your app at least once, clean the build:

    $ cd android && ./gradlew clean

 

That's it! You should now be able to develop and deploy your app as
usual:

-   npm
-   Yarn

    npm run android

 

    yarn android

 

iOS 

Since React Native 0.64, Hermes also runs on iOS. To enable Hermes for
iOS, edit your  ios/Podfile file and make the change illustrated below:

       use_react_native!(
         :path => config[:reactNativePath],
         # to enable hermes on iOS, change `false` to `true` and then install pods
         # By default, Hermes is disabled on Old Architecture, and enabled on New Architecture.
         # You can enable/disable it manually by replacing `flags[:hermes_enabled]` with `true` or `false`.
    -    :hermes_enabled => flags[:hermes_enabled],
    +    :hermes_enabled => true
       )

 

By default, you will be using Hermes if you're on the New Architecture.
By specifying a value such as  true or  false you can enable/disable
Hermes as you wish.

Once you've configured it, you can install the Hermes pods with:

    $ cd ios && pod install

 

That's it! You should now be able to develop and deploy your app as
usual:

-   npm
-   Yarn

    npm run ios

 

    yarn ios

 

Switching back to JavaScriptCore 

React Native also supports using JavaScriptCore as the JavaScript engine
. Follow these instructions to opt-out of Hermes.

Android 

Edit your  android/gradle.properties file and flip  hermesEnabled back
to false:

    # Use this property to enable or disable the Hermes JS engine.
    # If set to false, you will be using JSC instead.
    hermesEnabled=false

 

iOS 

Edit your  ios/Podfile file and make the change illustrated below:

       use_react_native!(
         :path => config[:reactNativePath],
    +    :hermes_enabled => false,
         # Enables Flipper.
         #
         # Note that if you have use_frameworks! enabled, Flipper will not work and
         # you should disable the next line.
         :flipper_configuration => flipper_config,
         # An absolute path to your application root.
         :app_path => "#{Pod::Config.instance.installation_root}/.."
       )

 

# Using Libraries #
 _   _     _               _     _ _                    _           
| | | |___(_)_ __   __ _  | |   (_) |__  _ __ __ _ _ __(_) ___  ___ 
| | | / __| | '_ \ / _` | | |   | | '_ \| '__/ _` | '__| |/ _ \/ __|
| |_| \__ \ | | | | (_| | | |___| | |_) | | | (_| | |  | |  __/\__ \
 \___/|___/_|_| |_|\__, | |_____|_|_.__/|_|  \__,_|_|  |_|\___||___/
                   |___/                                            
-   Selecting a Package Manager
-   Installing a Library
-   Linking Native Code on iOS
-   Linking Native Code on Android
-   Finding Libraries
-   Determining Library Compatibility
    -   Does it work with React Native?
    -   Does it work for the platforms that my app supports?
    -   Does it work with my app version of React Native?
Using Libraries

React Native provides a set of built-in Core Components and APIs ready
to use in your app. You're not limited to the components and APIs
bundled with React Native. React Native has a community of thousands of
developers. If the Core Components and APIs don't have what you are
looking for, you may be able to find and install a library from the
community to add the functionality to your app.

Selecting a Package Manager 

React Native libraries are typically installed from the npm registry
using a Node.js package manager such as npm CLI or Yarn Classic .

If you have Node.js installed on your computer then you already have the
npm CLI installed. Some developers prefer to use Yarn Classic for
slightly faster install times and additional advanced features like
Workspaces. Both tools work great with React Native. We will assume npm
for the rest of this guide for simplicity of explanation.

  💡 The terms "library" and "package" are used interchangeably in the
  JavaScript community.

Installing a Library 

To install a library in your project, navigate to your project directory
in your terminal and run the installation command. Let's try this with
 react-native-webview :

-   npm
-   Yarn

    npm install react-native-webview

 

    yarn add react-native-webview

 

The library that we installed includes native code, and we need to link
to our app before we use it.

Linking Native Code on iOS 

React Native uses CocoaPods to manage iOS project dependencies and most
React Native libraries follow this same convention. If a library you are
using does not, then please refer to their README for additional
instruction. In most cases, the following instructions will apply.

Run  pod install in our  ios directory in order to link it to our native
iOS project. A shortcut for doing this without switching to the  ios
directory is to run  npx pod-install .

    npx pod-install

 

Once this is complete, re-build the app binary to start using your new
library:

-   npm
-   Yarn

    npm run ios

 

    yarn ios

 

Linking Native Code on Android 

React Native uses Gradle to manage Android project dependencies. After
you install a library with native dependencies, you will need to
re-build the app binary to use your new library:

-   npm
-   Yarn

    npm run android

 

    yarn android

 

Finding Libraries 

React Native Directory is a searchable database of libraries built
specifically for React Native. This is the first place to look for a
library for your React Native app.

Many of the libraries you will find on the directory are from React
Native Community or Expo .

Libraries built by the React Native Community are driven by volunteers
and individuals at companies that depend on React Native. They often
support iOS, tvOS, Android, Windows, but this varies across projects.
Many of the libraries in this organization were once React Native Core
Components and APIs.

Libraries built by Expo are all written in TypeScript and support iOS,
Android, and  react-native-web wherever possible.

After React Native Directory, the npm registry is the next best place if
you can't find a library specifically for React Native on the directory.
The npm registry is the definitive source for JavaScript libraries, but
the libraries that it lists may not all be compatible with React Native.
React Native is one of many JavaScript programming environments,
including Node.js, web browsers, Electron, and more, and npm includes
libraries that work for all of these environments.

Determining Library Compatibility 

Does it work with React Native? 

Usually libraries built specifically for other platforms will not work
with React Native. Examples include  react-select which is built for the
web and specifically targets  react-dom , and  rimraf which is built for
Node.js and interacts with your computer file system. Other libraries
like  lodash use only JavaScript language features and work in any
environment. You will gain a sense for this over time, but until then
the easiest way to find out is to try it yourself. You can remove
packages using  npm uninstall if it turns out that it does not work in
React Native.

Does it work for the platforms that my app supports? 

React Native Directory allows you to filter by platform compatibility,
such as iOS, Android, Web, and Windows. If the library you would like to
use is not currently listed there, refer to the README for the library
to learn more.

Does it work with my app version of React Native? 

The latest version of a library is typically compatible with the latest
version of React Native. If you are using an older version, you should
refer to the README to know which version of the library you should
install. You can install a particular version of the library by running
 npm install <library-name>@<version-number> , for example:
 npm install @react-native-community/netinfo@^2.0.0 .

# Using List Views #
 _   _     _               _     _     _    __     ___                   
| | | |___(_)_ __   __ _  | |   (_)___| |_  \ \   / (_) _____      _____ 
| | | / __| | '_ \ / _` | | |   | / __| __|  \ \ / /| |/ _ \ \ /\ / / __|
| |_| \__ \ | | | | (_| | | |___| \__ \ |_    \ V / | |  __/\ V  V /\__ \
 \___/|___/_|_| |_|\__, | |_____|_|___/\__|    \_/  |_|\___| \_/\_/ |___/
                   |___/                                                 

Using List Views

React Native provides a suite of components for presenting lists of
data. Generally, you'll want to use either FlatList or SectionList .

The  FlatList component displays a scrolling list of changing, but
similarly structured, data.  FlatList works well for long lists of data,
where the number of items might change over time. Unlike the more
generic  ScrollView , the  FlatList only renders elements that are
currently showing on the screen, not all the elements at once.

The  FlatList component requires two props:  data and  renderItem .
 data is the source of information for the list.  renderItem takes one
item from the source and returns a formatted component to render.

This example creates a basic  FlatList of hardcoded data. Each item in
the  data props is rendered as a  Text component. The  FlatListBasics
component then renders the  FlatList and all  Text components.

If you want to render a set of data broken into logical sections, maybe
with section headers, similar to  UITableView s on iOS, then a
SectionList is the way to go.

One of the most common uses for a list view is displaying data that you
fetch from a server. To do that, you will need to learn about networking
in React Native .

# Using TypeScript #
 _   _     _               _____                 ____            _       _   
| | | |___(_)_ __   __ _  |_   _|   _ _ __   ___/ ___|  ___ _ __(_)_ __ | |_ 
| | | / __| | '_ \ / _` |   | || | | | '_ \ / _ \___ \ / __| '__| | '_ \| __|
| |_| \__ \ | | | | (_| |   | || |_| | |_) |  __/___) | (__| |  | | |_) | |_ 
 \___/|___/_|_| |_|\__, |   |_| \__, | .__/ \___|____/ \___|_|  |_| .__/ \__|
                   |___/        |___/|_|                          |_|        
-   Getting Started with TypeScript
-   Adding TypeScript to an Existing Project
-   Using JavaScript Instead of TypeScript
-   How TypeScript and React Native works
-   What does React Native + TypeScript look like
-   Where to Find Useful Advice
-   Using Custom Path Aliases with TypeScript
Using TypeScript

TypeScript is a language which extends JavaScript by adding type
definitions. New React Native projects target TypeScript by default, but
also support JavaScript and Flow.

Getting Started with TypeScript 

New projects created by the React Native CLI or popular templates like
Ignite will use TypeScript by default.

TypeScript may also be used with Expo , which maintains TypeScript
templates, or will prompt you to automatically install and configure
TypeScript when a  .ts or  .tsx file is added to your project.

    npx create-expo-app --template

 

Adding TypeScript to an Existing Project 

1.  Add TypeScript, types, and ESLint plugins to your project.

-   npm
-   Yarn

    npm install -D @tsconfig/react-native @types/jest @types/react @types/react-test-renderer typescript

 

    yarn add --dev @tsconfig/react-native @types/jest @types/react @types/react-test-renderer typescript

 

 note

This command adds the latest version of every dependency. The versions
may need to be changed to match the existing packages used by your
project. You can use a tool like React Native Upgrade Helper to see the
versions shipped by React Native.

2.  Add a TypeScript config file. Create a  tsconfig.json in the root of
    your project:

    {
      "extends": "@tsconfig/react-native/tsconfig.json"
    }

 

3.  Rename a JavaScript file to be  *.tsx

  You should leave the  ./index.js entrypoint file as it is otherwise
  you may run into an issue when it comes to bundling a production
  build.

4.  Run  yarn tsc to type-check your new TypeScript files.

Using JavaScript Instead of TypeScript 

React Native defaults new applications to TypeScript, but JavaScript may
still be used. Files with a  .jsx extension are treated as JavaScript
instead of TypeScript, and will not be typechecked. JavaScript modules
may still be imported by TypeScript modules, along with the reverse.

How TypeScript and React Native works 

Out of the box, TypeScript sources are transformed by Babel during
bundling. We recommend that you use the TypeScript compiler only for
type checking. This is the default behavior of  tsc for newly created
applications. If you have existing TypeScript code being ported to React
Native, there are one or two caveats to using Babel instead of
TypeScript.

What does React Native + TypeScript look like 

You can provide an interface for a React Component's Props and State via
 React.Component<Props, State> which will provide type-checking and
editor auto-completing when working with that component in JSX.

components/Hello.tsx

    import React from 'react';
    import {Button, StyleSheet, Text, View} from 'react-native';

    export type Props = {
      name: string;
      baseEnthusiasmLevel?: number;
    };

    const Hello: React.FC<Props> = ({
      name,
      baseEnthusiasmLevel = 0,
    }) => {
      const [enthusiasmLevel, setEnthusiasmLevel] = React.useState(
        baseEnthusiasmLevel,
      );

      const onIncrement = () =>
        setEnthusiasmLevel(enthusiasmLevel + 1);
      const onDecrement = () =>
        setEnthusiasmLevel(
          enthusiasmLevel > 0 ? enthusiasmLevel - 1 : 0,
        );

      const getExclamationMarks = (numChars: number) =>
        numChars > 0 ? Array(numChars + 1).join('!') : '';

      return (
        <View style={styles.container}>
          <Text style={styles.greeting}>
            Hello {name}
            {getExclamationMarks(enthusiasmLevel)}
          </Text>
          <View>
            <Button
              title="Increase enthusiasm"
              accessibilityLabel="increment"
              onPress={onIncrement}
              color="blue"
            />
            <Button
              title="Decrease enthusiasm"
              accessibilityLabel="decrement"
              onPress={onDecrement}
              color="red"
            />
          </View>
        </View>
      );
    };

    const styles = StyleSheet.create({
      container: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
      },
      greeting: {
        fontSize: 20,
        fontWeight: 'bold',
        margin: 16,
      },
    });

    export default Hello;

 

You can explore the syntax more in the TypeScript playground .

Where to Find Useful Advice 

-   TypeScript Handbook
-   React's documentation on TypeScript
-   React + TypeScript Cheatsheets has a good overview on how to use
    React with TypeScript

Using Custom Path Aliases with TypeScript 

To use custom path aliases with TypeScript, you need to set the path
aliases to work from both Babel and TypeScript. Here's how:

1.  Edit your  tsconfig.json to have your custom path mappings . Set
    anything in the root of  src to be available with no preceding path
    reference, and allow any test file to be accessed by using
     tests/File.tsx :

    {
    -  "extends": "@tsconfig/react-native/tsconfig.json"
    +  "extends": "@tsconfig/react-native/tsconfig.json",
    +  "compilerOptions": {
    +    "baseUrl": ".",
    +    "paths": {
    +      "*": ["src/*"],
    +      "tests": ["tests/*"],
    +      "@components/*": ["src/components/*"],
    +    },
    +  }
    }

 

2.  Add  babel-plugin-module-resolver as a development package to your
    project:

-   npm
-   Yarn

    npm install --save-dev babel-plugin-module-resolver

 

    yarn add --dev babel-plugin-module-resolver

 

3.  Finally, configure your  babel.config.js (note that the syntax for
    your  babel.config.js is different from your  tsconfig.json ):

    {
       presets: ['module:metro-react-native-babel-preset'],
    +  plugins: [
    +    [
    +       'module-resolver',
    +       {
    +         root: ['./src'],
    +         extensions: ['.ios.js', '.android.js', '.js', '.ts', '.tsx', '.json'],
    +         alias: {
    +           tests: ['./tests/'],
    +           "@components": "./src/components",
    +         }
    +       }
    +    ]
    +  ]
    }

 

# Vibration #
__     ___ _               _   _             
\ \   / (_) |__  _ __ __ _| |_(_) ___  _ __  
 \ \ / /| | '_ \| '__/ _` | __| |/ _ \| '_ \ 
  \ V / | | |_) | | | (_| | |_| | (_) | | | |
   \_/  |_|_.__/|_|  \__,_|\__|_|\___/|_| |_|
                                             
-   Example
-   Methods
    -    cancel()
    -    vibrate()
Vibration

Vibrates the device.

Example 

  Android apps should request the  android.permission.VIBRATE permission
  by adding
   <uses-permission android:name="android.permission.VIBRATE"/> to
   AndroidManifest.xml .

  The Vibration API is implemented as a
   AudioServicesPlaySystemSound(kSystemSoundID_Vibrate) call on iOS.

------------------------------------------------------------------------

Reference

Methods 

 cancel() 

    static cancel();

 

Call this to stop vibrating after having invoked  vibrate() with
repetition enabled.

------------------------------------------------------------------------

 vibrate() 

    static vibrate(
      pattern?: number | number,
      repeat?: boolean
    );

 

Triggers a vibration with a fixed duration.

On Android, the vibration duration defaults to 400 milliseconds, and an
arbitrary vibration duration can be specified by passing a number as the
value for the  pattern argument. On iOS, the vibration duration is fixed
at roughly 400 milliseconds.

The  vibrate() method can take a  pattern argument with an array of
numbers that represent time in milliseconds. You may set  repeat to true
to run through the vibration pattern in a loop until  cancel() is
called.

On Android, the odd indices of the  pattern array represent the
vibration duration, while the even ones represent the separation time.
On iOS, the numbers in the  pattern array represent the separation time,
as the vibration duration is fixed.

Parameters:

+-----------------+-----------------+-----------------+-----------------+
| Name            | Type            | Default         | Description     |
+=================+=================+=================+=================+
| pattern         | number          |  400            | Vibration       |
|                 |                 |                 | duration in     |
|                 | Android         |                 | milliseconds.   |
|                 |                 |                 |                 |
|                 | -------------   |                 | -------------   |
|                 |                 |                 |                 |
|                 | array of        |                 | Vibration       |
|                 | numbers         |                 | pattern as an   |
|                 |                 |                 | array of        |
|                 |                 |                 | numbers in      |
|                 |                 |                 | milliseconds.   |
+-----------------+-----------------+-----------------+-----------------+
| repeat          | boolean         |  false          | Repeat          |
|                 |                 |                 | vibration       |
|                 |                 |                 | pattern until   |
|                 |                 |                 |  cancel() .     |
+-----------------+-----------------+-----------------+-----------------+

# View #
__     ___               
\ \   / (_) _____      __
 \ \ / /| |/ _ \ \ /\ / /
  \ V / | |  __/\ V  V / 
   \_/  |_|\___| \_/\_/  
                         
-   Synthetic Touch Events
-   Props
    -    accessibilityActions
    -    accessibilityElementsHidden
        iOS
    -    accessibilityHint
    -    accessibilityLanguage
        iOS
    -    accessibilityIgnoresInvertColors
        iOS
    -    accessibilityLabel
    -    accessibilityLiveRegion
        Android
    -    accessibilityRole
    -    accessibilityState
    -    accessibilityValue
    -    accessibilityViewIsModal
        iOS
    -    accessible
    -    aria-busy
    -    aria-checked
    -    aria-disabled
    -    aria-expanded
    -    aria-hidden
    -    aria-label
    -    aria-labelledby
        Android
    -    aria-live
        Android
    -    aria-modal
        iOS
    -    aria-selected
    -    aria-valuemax
    -    aria-valuemin
    -    aria-valuenow
    -    aria-valuetext
    -    collapsable
        Android
    -    focusable
        Android
    -    hitSlop
    -    id
    -    importantForAccessibility
        Android
    -    nativeID
    -    needsOffscreenAlphaCompositing
    -    nextFocusDown
        Android
    -    nextFocusForward
        Android
    -    nextFocusLeft
        Android
    -    nextFocusRight
        Android
    -    nextFocusUp
        Android
    -    onAccessibilityAction
    -    onAccessibilityEscape
        iOS
    -    onAccessibilityTap
    -    onLayout
    -    onMagicTap
        iOS
    -    onMoveShouldSetResponder
    -    onMoveShouldSetResponderCapture
    -    onResponderGrant
    -    onResponderMove
    -    onResponderReject
    -    onResponderRelease
    -    onResponderTerminate
    -    onResponderTerminationRequest
    -    onStartShouldSetResponder
    -    onStartShouldSetResponderCapture
    -    pointerEvents
    -    removeClippedSubviews
    -    renderToHardwareTextureAndroid
        Android
    -    role
    -    shouldRasterizeIOS
        iOS
    -    style
    -    tabIndex
        Android
    -    testID
View

The most fundamental component for building a UI,  View is a container
that supports layout with flexbox , style , some touch handling , and
accessibility controls.  View maps directly to the native view
equivalent on whatever platform React Native is running on, whether that
is a  UIView ,  <div> ,  android.view , etc.

 View is designed to be nested inside other views and can have 0 to many
children of any type.

This example creates a  View that wraps two boxes with color and a text
component in a row with padding.

   View s are designed to be used with  StyleSheet for clarity and
  performance, although inline styles are also supported.

Synthetic Touch Events 

For  View responder props (e.g.,  onResponderMove ), the synthetic touch
event passed to them are in form of PressEvent .

------------------------------------------------------------------------

Reference

Props 

------------------------------------------------------------------------

 accessibilityActions 

Accessibility actions allow an assistive technology to programmatically
invoke the actions of a component. The  accessibilityActions property
should contain a list of action objects. Each action object should
contain the field name and label.

See the Accessibility guide for more information.

  Type
  -------
  array

------------------------------------------------------------------------

 accessibilityElementsHidden

iOS



A value indicating whether the accessibility elements contained within
this accessibility element are hidden. Default is  false .

See the Accessibility guide for more information.

  Type
  ------
  bool

------------------------------------------------------------------------

 accessibilityHint 

An accessibility hint helps users understand what will happen when they
perform an action on the accessibility element when that result is not
clear from the accessibility label.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityLanguage

iOS



A value indicating which language should be used by the screen reader
when the user interacts with the element. It should follow the BCP 47
specification .

See the iOS  accessibilityLanguage doc for more information.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityIgnoresInvertColors

iOS



A value indicating this view should or should not be inverted when color
inversion is turned on. A value of  true will tell the view to not be
inverted even if color inversion is turned on.

See the Accessibility guide for more information.

  Type
  ------
  bool

------------------------------------------------------------------------

 accessibilityLabel 

Overrides the text that's read by the screen reader when the user
interacts with the element. By default, the label is constructed by
traversing all the children and accumulating all the  Text nodes
separated by space.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityLiveRegion

Android



Indicates to accessibility services whether the user should be notified
when this view changes. Works for Android API >= 19 only. Possible
values:

-    'none' - Accessibility services should not announce changes to this
    view.
-    'polite' - Accessibility services should announce changes to this
    view.
-    'assertive' - Accessibility services should interrupt ongoing
    speech to immediately announce changes to this view.

See the Android  View docs for reference.

  Type
  -------------------------------------
  enum('none', 'polite', 'assertive')

------------------------------------------------------------------------

 accessibilityRole 

 accessibilityRole communicates the purpose of a component to the user
of an assistive technology.

 accessibilityRole can be one of the following:

-    'none' - Used when the element has no role.
-    'button' - Used when the element should be treated as a button.
-    'link' - Used when the element should be treated as a link.
-    'search' - Used when the text field element should also be treated
    as a search field.
-    'image' - Used when the element should be treated as an image. Can
    be combined with button or link, for example.
-    'keyboardkey' - Used when the element acts as a keyboard key.
-    'text' - Used when the element should be treated as static text
    that cannot change.
-    'adjustable' - Used when an element can be "adjusted" (e.g. a
    slider).
-    'imagebutton' - Used when the element should be treated as a button
    and is also an image.
-    'header' - Used when an element acts as a header for a content
    section (e.g. the title of a navigation bar).
-    'summary' - Used when an element can be used to provide a quick
    summary of current conditions in the app when the app first
    launches.
-    'alert' - Used when an element contains important text to be
    presented to the user.
-    'checkbox' - Used when an element represents a checkbox which can
    be checked, unchecked, or have mixed checked state.
-    'combobox' - Used when an element represents a combo box, which
    allows the user to select among several choices.
-    'menu' - Used when the component is a menu of choices.
-    'menubar' - Used when a component is a container of multiple menus.
-    'menuitem' - Used to represent an item within a menu.
-    'progressbar' - Used to represent a component which indicates
    progress of a task.
-    'radio' - Used to represent a radio button.
-    'radiogroup' - Used to represent a group of radio buttons.
-    'scrollbar' - Used to represent a scroll bar.
-    'spinbutton' - Used to represent a button which opens a list of
    choices.
-    'switch' - Used to represent a switch which can be turned on and
    off.
-    'tab' - Used to represent a tab.
-    'tablist' - Used to represent a list of tabs.
-    'timer' - Used to represent a timer.
-    'toolbar' - Used to represent a tool bar (a container of action
    buttons or components).
-    'grid' - Used with ScrollView, VirtualizedList, FlatList, or
    SectionList to represent a grid. Adds the in/out of grid
    announcements to the android GridView.

  Type
  --------
  string

------------------------------------------------------------------------

 accessibilityState 

Describes the current state of a component to the user of an assistive
technology.

See the Accessibility guide for more information.

  Type
  -------------------------------------------------------------------------------------------------
  object:  {disabled: bool, selected: bool, checked: bool or 'mixed', busy: bool, expanded: bool}

------------------------------------------------------------------------

 accessibilityValue 

Represents the current value of a component. It can be a textual
description of a component's value, or for range-based components, such
as sliders and progress bars, it contains range information (minimum,
current, and maximum).

See the Accessibility guide for more information.

  Type
  ----------------------------------------------------------------
  object:  {min: number, max: number, now: number, text: string}

------------------------------------------------------------------------

 accessibilityViewIsModal

iOS



A value indicating whether VoiceOver should ignore the elements within
views that are siblings of the receiver. Default is  false .

See the Accessibility guide for more information.

  Type
  ------
  bool

------------------------------------------------------------------------

 accessible 

When  true , indicates that the view is an accessibility element. By
default, all the touchable elements are accessible.

------------------------------------------------------------------------

 aria-busy 

Indicates an element is being modified and that assistive technologies
may want to wait until the changes are complete before informing the
user about the update.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-checked 

Indicates the state of a checkable element. This field can either take a
boolean or the "mixed" string to represent mixed checkboxes.

  Type               Default
  ------------------ ---------
  boolean, 'mixed'   false

------------------------------------------------------------------------

 aria-disabled 

Indicates that the element is perceivable but disabled, so it is not
editable or otherwise operable.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-expanded 

Indicates whether an expandable element is currently expanded or
collapsed.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-hidden 

Indicates whether the accessibility elements contained within this
accessibility element are hidden.

For example, in a window that contains sibling views  A and  B , setting
 aria-hidden to  true on view  B causes VoiceOver to ignore the elements
in the view  B .

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-label 

Defines a string value that labels an interactive element.

  Type
  --------
  string

------------------------------------------------------------------------

 aria-labelledby

Android



Identifies the element that labels the element it is applied to. The
value of  aria-labelledby should match the  nativeID of the related
element:

    <View>
      <Text nativeID="formLabel">Label for Input Field</Text>
      <TextInput aria-label="input" aria-labelledby="formLabel" />
    </View>

 

  Type
  --------
  string

------------------------------------------------------------------------

 aria-live

Android



Indicates that an element will be updated, and describes the types of
updates the user agents, assistive technologies, and user can expect
from the live region.

-   off Accessibility services should not announce changes to this view.
-   polite Accessibility services should announce changes to this view.
-   assertive Accessibility services should interrupt ongoing speech to
    immediately announce changes to this view.

  Type                                        Default
  ------------------------------------------- ---------
  enum(  'assertive' ,  'off' ,  'polite' )    'off'

------------------------------------------------------------------------

 aria-modal

iOS



Boolean value indicating whether VoiceOver should ignore the elements
within views that are siblings of the receiver. Has precedence over the
 accessibilityViewIsModal prop.

  Type      Default
  --------- ---------
  boolean   false

------------------------------------------------------------------------

 aria-selected 

Indicates whether a selectable element is currently selected or not.

  Type
  ---------
  boolean

 aria-valuemax 

Represents the maximum value for range-based components, such as sliders
and progress bars. Has precedence over the  max value in the
 accessibilityValue prop.

  Type
  --------
  number

------------------------------------------------------------------------

 aria-valuemin 

Represents the minimum value for range-based components, such as sliders
and progress bars. Has precedence over the  min value in the
 accessibilityValue prop.

  Type
  --------
  number

------------------------------------------------------------------------

 aria-valuenow 

Represents the current value for range-based components, such as sliders
and progress bars. Has precedence over the  now value in the
 accessibilityValue prop.

  Type
  --------
  number

------------------------------------------------------------------------

 aria-valuetext 

Represents the textual description of the component. Has precedence over
the  text value in the  accessibilityValue prop.

  Type
  --------
  string

------------------------------------------------------------------------

 collapsable

Android



Views that are only used to layout their children or otherwise don't
draw anything may be automatically removed from the native hierarchy as
an optimization. Set this property to  false to disable this
optimization and ensure that this  View exists in the native view
hierarchy.

  Type
  ------
  bool

------------------------------------------------------------------------

 focusable

Android



Whether this  View should be focusable with a non-touch input device,
eg. receive focus with a hardware keyboard.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 hitSlop 

This defines how far a touch event can start away from the view. Typical
interface guidelines recommend touch targets that are at least 30 - 40
points/density-independent pixels.

For example, if a touchable view has a height of 20 the touchable height
can be extended to 40 with
 hitSlop={{top: 10, bottom: 10, left: 0, right: 0}}

  The touch area never extends past the parent view bounds and the
  Z-index of sibling views always takes precedence if a touch hits two
  overlapping views.

  Type
  ---------------------------------------------------------------------
  object:  {top: number, left: number, bottom: number, right: number}

------------------------------------------------------------------------

 id 

Used to locate this view from native classes. Has precedence over
 nativeID prop.

  This disables the 'layout-only view removal' optimization for this
  view!

  Type
  --------
  string

------------------------------------------------------------------------

 importantForAccessibility

Android



Controls how view is important for accessibility which is if it fires
accessibility events and if it is reported to accessibility services
that query the screen. Works for Android only.

Possible values:

-    'auto' - The system determines whether the view is important for
    accessibility - default (recommended).
-    'yes' - The view is important for accessibility.
-    'no' - The view is not important for accessibility.
-    'no-hide-descendants' - The view is not important for
    accessibility, nor are any of its descendant views.

See the Android  importantForAccessibility docs for reference.

  Type
  --------------------------------------------------
  enum('auto', 'yes', 'no', 'no-hide-descendants')

------------------------------------------------------------------------

 nativeID 

Used to locate this view from native classes.

  This disables the 'layout-only view removal' optimization for this
  view!

  Type
  --------
  string

------------------------------------------------------------------------

 needsOffscreenAlphaCompositing 

Whether this  View needs to rendered offscreen and composited with an
alpha in order to preserve 100% correct colors and blending behavior.
The default (  false ) falls back to drawing the component and its
children with an alpha applied to the paint used to draw each element
instead of rendering the full component offscreen and compositing it
back with an alpha value. This default may be noticeable and undesired
in the case where the  View you are setting an opacity on has multiple
overlapping elements (e.g. multiple overlapping  View s, or text and a
background).

Rendering offscreen to preserve correct alpha behavior is extremely
expensive and hard to debug for non-native developers, which is why it
is not turned on by default. If you do need to enable this property for
an animation, consider combining it with renderToHardwareTextureAndroid
if the view contents are static (i.e. it doesn't need to be redrawn each
frame). If that property is enabled, this View will be rendered
off-screen once, saved in a hardware texture, and then composited onto
the screen with an alpha each frame without having to switch rendering
targets on the GPU.

  Type
  ------
  bool

------------------------------------------------------------------------

 nextFocusDown

Android



Designates the next view to receive focus when the user navigates down.
See the Android documentation .

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusForward

Android



Designates the next view to receive focus when the user navigates
forward. See the Android documentation .

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusLeft

Android



Designates the next view to receive focus when the user navigates left.
See the Android documentation .

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusRight

Android



Designates the next view to receive focus when the user navigates right.
See the Android documentation .

  Type
  --------
  number

------------------------------------------------------------------------

 nextFocusUp

Android



Designates the next view to receive focus when the user navigates up.
See the Android documentation .

  Type
  --------
  number

------------------------------------------------------------------------

 onAccessibilityAction 

Invoked when the user performs the accessibility actions. The only
argument to this function is an event containing the name of the action
to perform.

See the Accessibility guide for more information.

  Type
  ----------
  function

------------------------------------------------------------------------

 onAccessibilityEscape

iOS



When  accessible is  true , the system will invoke this function when
the user performs the escape gesture.

  Type
  ----------
  function

------------------------------------------------------------------------

 onAccessibilityTap 

When  accessible is true, the system will try to invoke this function
when the user performs accessibility tap gesture.

  Type
  ----------
  function

------------------------------------------------------------------------

 onLayout 

Invoked on mount and on layout changes.

This event is fired immediately once the layout has been calculated, but
the new layout may not yet be reflected on the screen at the time the
event is received, especially if a layout animation is in progress.

  Type
  ------------------------------------------
   ({nativeEvent:  LayoutEvent  }) => void

------------------------------------------------------------------------

 onMagicTap

iOS



When  accessible is  true , the system will invoke this function when
the user performs the magic tap gesture.

  Type
  ----------
  function

------------------------------------------------------------------------

 onMoveShouldSetResponder 

Does this view want to "claim" touch responsiveness? This is called for
every touch move on the  View when it is not the responder.

  Type
  --------------------------------------------
   ({nativeEvent:  PressEvent  }) => boolean

------------------------------------------------------------------------

 onMoveShouldSetResponderCapture 

If a parent  View wants to prevent a child  View from becoming responder
on a move, it should have this handler which returns  true .

  Type
  --------------------------------------------
   ({nativeEvent:  PressEvent  }) => boolean

------------------------------------------------------------------------

 onResponderGrant 

The View is now responding for touch events. This is the time to
highlight and show the user what is happening.

On Android, return true from this callback to prevent any other native
components from becoming responder until this responder terminates.

  Type
  ----------------------------------------------------
   ({nativeEvent:  PressEvent  }) => void ｜ boolean

------------------------------------------------------------------------

 onResponderMove 

The user is moving their finger.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onResponderReject 

Another responder is already active and will not release it to that
 View asking to be the responder.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onResponderRelease 

Fired at the end of the touch.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onResponderTerminate 

The responder has been taken from the  View . Might be taken by other
views after a call to  onResponderTerminationRequest , or might be taken
by the OS without asking (e.g., happens with control center/
notification center on iOS)

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onResponderTerminationRequest 

Some other  View wants to become responder and is asking this  View to
release its responder. Returning  true allows its release.

  Type
  -----------------------------------------
   ({nativeEvent:  PressEvent  }) => void

------------------------------------------------------------------------

 onStartShouldSetResponder 

Does this view want to become responder on the start of a touch?

  Type
  --------------------------------------------
   ({nativeEvent:  PressEvent  }) => boolean

------------------------------------------------------------------------

 onStartShouldSetResponderCapture 

If a parent  View wants to prevent a child  View from becoming responder
on a touch start, it should have this handler which returns  true .

  Type
  --------------------------------------------
   ({nativeEvent:  PressEvent  }) => boolean

------------------------------------------------------------------------

 pointerEvents 

Controls whether the  View can be the target of touch events.

-    'auto' : The View can be the target of touch events.
-    'none' : The View is never the target of touch events.
-    'box-none' : The View is never the target of touch events but its
    subviews can be. It behaves like if the view had the following
    classes in CSS:

    .box-none {
         pointer-events: none;
    }
    .box-none * {
         pointer-events: auto;
    }

 

-    'box-only' : The view can be the target of touch events but its
    subviews cannot be. It behaves like if the view had the following
    classes in CSS:

    .box-only {
         pointer-events: auto;
    }
    .box-only * {
         pointer-events: none;
    }

 

  Type
  ----------------------------------------------
  enum('box-none', 'none', 'box-only', 'auto')

------------------------------------------------------------------------

 removeClippedSubviews 

This is a reserved performance property exposed by  RCTView and is
useful for scrolling content when there are many subviews, most of which
are offscreen. For this property to be effective, it must be applied to
a view that contains many subviews that extend outside its bound. The
subviews must also have  overflow: hidden , as should the containing
view (or one of its superviews).

  Type
  ------
  bool

------------------------------------------------------------------------

 renderToHardwareTextureAndroid

Android



Whether this  View should render itself (and all of its children) into a
single hardware texture on the GPU.

On Android, this is useful for animations and interactions that only
modify opacity, rotation, translation, and/or scale: in those cases, the
view doesn't have to be redrawn and display lists don't need to be
re-executed. The texture can be re-used and re-composited with different
parameters. The downside is that this can use up limited video memory,
so this prop should be set back to false at the end of the
interaction/animation.

  Type
  ------
  bool

------------------------------------------------------------------------

 role 

 role communicates the purpose of a component to the user of an
assistive technology. Has precedence over the  accessibilityRole prop.

  Type
  ------
  Role

------------------------------------------------------------------------

 shouldRasterizeIOS

iOS



Whether this  View should be rendered as a bitmap before compositing.

On iOS, this is useful for animations and interactions that do not
modify this component's dimensions nor its children; for example, when
translating the position of a static view, rasterization allows the
renderer to reuse a cached bitmap of a static view and quickly composite
it during each frame.

Rasterization incurs an off-screen drawing pass and the bitmap consumes
memory. Test and measure when using this property.

  Type
  ------
  bool

------------------------------------------------------------------------

 style 

  Type
  ------------
  View Style

------------------------------------------------------------------------

 tabIndex

Android



Whether this  View should be focusable with a non-touch input device,
eg. receive focus with a hardware keyboard. Supports the following
values:

-    0 - View is focusable
-    -1 - View is not focusable

  Type
  -------------
  enum(0, -1)

------------------------------------------------------------------------

 testID 

Used to locate this view in end-to-end tests.

  This disables the 'layout-only view removal' optimization for this
  view!

  Type
  --------
  string

# View Style Props #
__     ___                 ____  _         _        ____                      
\ \   / (_) _____      __ / ___|| |_ _   _| | ___  |  _ \ _ __ ___  _ __  ___ 
 \ \ / /| |/ _ \ \ /\ / / \___ \| __| | | | |/ _ \ | |_) | '__/ _ \| '_ \/ __|
  \ V / | |  __/\ V  V /   ___) | |_| |_| | |  __/ |  __/| | | (_) | |_) \__ \
   \_/  |_|\___| \_/\_/   |____/ \__|\__, |_|\___| |_|   |_|  \___/| .__/|___/
                                     |___/                         |_|        
-   Example
-   Props
    -    backfaceVisibility
    -    backgroundColor
    -    borderBottomColor
    -    borderBottomEndRadius
    -    borderBottomLeftRadius
    -    borderBottomRightRadius
    -    borderBottomStartRadius
    -    borderStartEndRadius
    -    borderStartStartRadius
    -    borderEndEndRadius
    -    borderEndStartRadius
    -    borderBottomWidth
    -    borderColor
    -    borderCurve
        iOS
    -    borderEndColor
    -    borderLeftColor
    -    borderLeftWidth
    -    borderRadius
    -    borderRightColor
    -    borderRightWidth
    -    borderStartColor
    -    borderStyle
    -    borderTopColor
    -    borderTopEndRadius
    -    borderTopLeftRadius
    -    borderTopRightRadius
    -    borderTopStartRadius
    -    borderTopWidth
    -    borderWidth
    -    elevation
        Android
    -    opacity
    -    pointerEvents
View Style Props

Example 

Reference

Props 

 backfaceVisibility 

  Type
  --------------------------------
  enum(  'visible' ,  'hidden' )

------------------------------------------------------------------------

 backgroundColor 

  Type
  -------
  color

------------------------------------------------------------------------

 borderBottomColor 

  Type
  -------
  color

------------------------------------------------------------------------

 borderBottomEndRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderBottomLeftRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderBottomRightRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderBottomStartRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderStartEndRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderStartStartRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderEndEndRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderEndStartRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderBottomWidth 

  Type
  --------
  number

------------------------------------------------------------------------

 borderColor 

  Type
  -------
  color

------------------------------------------------------------------------

 borderCurve

iOS



On iOS 13+, it is possible to change the corner curve of borders.

  Type
  -------------------------------------
  enum(  'circular' ,  'continuous' )

------------------------------------------------------------------------

 borderEndColor 

  Type
  -------
  color

------------------------------------------------------------------------

 borderLeftColor 

  Type
  -------
  color

------------------------------------------------------------------------

 borderLeftWidth 

  Type
  --------
  number

------------------------------------------------------------------------

 borderRadius 

If the rounded border is not visible, try applying  overflow: 'hidden'
as well.

  Type
  --------
  number

------------------------------------------------------------------------

 borderRightColor 

  Type
  -------
  color

------------------------------------------------------------------------

 borderRightWidth 

  Type
  --------
  number

------------------------------------------------------------------------

 borderStartColor 

  Type
  -------
  color

------------------------------------------------------------------------

 borderStyle 

  Type
  ------------------------------------------
  enum(  'solid' ,  'dotted' ,  'dashed' )

------------------------------------------------------------------------

 borderTopColor 

  Type
  -------
  color

------------------------------------------------------------------------

 borderTopEndRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderTopLeftRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderTopRightRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderTopStartRadius 

  Type
  --------
  number

------------------------------------------------------------------------

 borderTopWidth 

  Type
  --------
  number

------------------------------------------------------------------------

 borderWidth 

  Type
  --------
  number

------------------------------------------------------------------------

 elevation

Android



Sets the elevation of a view, using Android's underlying elevation API .
This adds a drop shadow to the item and affects z-order for overlapping
views. Only supported on Android 5.0+, has no effect on earlier
versions.

  Type
  --------
  number

------------------------------------------------------------------------

 opacity 

  Type
  --------
  number

 pointerEvents 

Controls whether the  View can be the target of touch events.

-    'auto' : The View can be the target of touch events.
-    'none' : The View is never the target of touch events.
-    'box-none' : The View is never the target of touch events but its
    subviews can be.
-    'box-only' : The view can be the target of touch events but its
    subviews cannot be.

  Type
  -----------------------------------------------
  enum('auto', 'box-none', 'box-only', 'none' )

# ViewToken Object Type #
__     ___               _____     _              
\ \   / (_) _____      _|_   _|__ | | _____ _ __  
 \ \ / /| |/ _ \ \ /\ / / | |/ _ \| |/ / _ \ '_ \ 
  \ V / | |  __/\ V  V /  | | (_) |   <  __/ | | |
   \_/  |_|\___| \_/\_/   |_|\___/|_|\_\___|_| |_|
                                                  
  ___  _     _           _     _____                 
 / _ \| |__ (_) ___  ___| |_  |_   _|   _ _ __   ___ 
| | | | '_ \| |/ _ \/ __| __|   | || | | | '_ \ / _ \
| |_| | |_) | |  __/ (__| |_    | || |_| | |_) |  __/
 \___/|_.__// |\___|\___|\__|   |_| \__, | .__/ \___|
          |__/                      |___/|_|         
-   Example
-   Keys and values
    -    index
    -    isViewable
    -    item
    -    key
    -    section
-   Used by
ViewToken Object Type

 ViewToken object is returned as one of properties in the
 onViewableItemsChanged callback, for example in FlatList component. It
is exported by  ViewabilityHelper.js .

Example 

    {
      item: {key: "key-12"},
      key: "key-12",
      index: 11,
      isViewable: true
    }

 

Keys and values 

 index 

Unique numeric identifier assigned to the data element.

  Type     Optional
  -------- ----------
  number   Yes

 isViewable 

Specifies if at least some part of list element is visible in the
viewport.

  Type      Optional
  --------- ----------
  boolean   No

 item 

Item data

  Type   Optional
  ------ ----------
  any    No

 key 

Key identifier assigned of the data element extracted to the top level.

  Type     Optional
  -------- ----------
  string   No

 section 

Item section data when used with  SectionList .

  Type   Optional
  ------ ----------
  any    Yes

Used by 

-    FlatList
-    SectionList
-    VirtualizedList

# VirtualizedList #
__     ___      _               _ _             _ _     _     _   
\ \   / (_)_ __| |_ _   _  __ _| (_)_______  __| | |   (_)___| |_ 
 \ \ / /| | '__| __| | | |/ _` | | |_  / _ \/ _` | |   | / __| __|
  \ V / | | |  | |_| |_| | (_| | | |/ /  __/ (_| | |___| \__ \ |_ 
   \_/  |_|_|   \__|\__,_|\__,_|_|_/___\___|\__,_|_____|_|___/\__|
                                                                  
-   Example
-   Props
    -   ScrollView Props
    -    data
    -   
        Required

         getItem
    -   
        Required

         getItemCount
    -   
        Required

         renderItem
    -    CellRendererComponent
    -    ItemSeparatorComponent
    -    ListEmptyComponent
    -    ListItemComponent
    -    ListFooterComponent
    -    ListFooterComponentStyle
    -    ListHeaderComponent
    -    ListHeaderComponentStyle
    -    debug
    -    disableVirtualization
    -    extraData
    -    getItemLayout
    -    horizontal
    -    initialNumToRender
    -    initialScrollIndex
    -    inverted
    -    keyExtractor
    -    maxToRenderPerBatch
    -    onEndReached
    -    onEndReachedThreshold
    -    onRefresh
    -    onScrollToIndexFailed
    -    onStartReached
    -    onStartReachedThreshold
    -    onViewableItemsChanged
    -    persistentScrollbar
    -    progressViewOffset
    -    refreshControl
    -    refreshing
    -    removeClippedSubviews
    -    renderScrollComponent
    -    viewabilityConfig
    -    viewabilityConfigCallbackPairs
    -    updateCellsBatchingPeriod
    -    windowSize
-   Methods
    -    flashScrollIndicators()
    -    getScrollableNode()
    -    getScrollRef()
    -    getScrollResponder()
    -    scrollToEnd()
    -    scrollToIndex()
    -    scrollToItem()
    -    scrollToOffset()
VirtualizedList

Base implementation for the more convenient  <FlatList> and
 <SectionList> components, which are also better documented. In general,
this should only really be used if you need more flexibility than
 FlatList provides, e.g. for use with immutable data instead of plain
arrays.

Virtualization massively improves memory consumption and performance of
large lists by maintaining a finite render window of active items and
replacing all items outside of the render window with appropriately
sized blank space. The window adapts to scrolling behavior, and items
are rendered incrementally with low-pri (after any running interactions)
if they are far from the visible area, or with hi-pri otherwise to
minimize the potential of seeing blank space.

Example 

-   TypeScript
-   JavaScript

------------------------------------------------------------------------

Some caveats:

-   Internal state is not preserved when content scrolls out of the
    render window. Make sure all your data is captured in the item data
    or external stores like Flux, Redux, or Relay.
-   This is a  PureComponent which means that it will not re-render if
     props are shallow-equal. Make sure that everything your  renderItem
    function depends on is passed as a prop (e.g.  extraData ) that is
    not  === after updates, otherwise your UI may not update on changes.
    This includes the  data prop and parent component state.
-   In order to constrain memory and enable smooth scrolling, content is
    rendered asynchronously offscreen. This means it's possible to
    scroll faster than the fill rate and momentarily see blank content.
    This is a tradeoff that can be adjusted to suit the needs of each
    application, and we are working on improving it behind the scenes.
-   By default, the list looks for a  key prop on each item and uses
    that for the React key. Alternatively, you can provide a custom
     keyExtractor prop.

------------------------------------------------------------------------

Reference

Props 

ScrollView Props 

Inherits ScrollView Props .

------------------------------------------------------------------------

 data 

Opaque data type passed to  getItem and  getItemCount to retrieve items.

  Type
  ------
  any

------------------------------------------------------------------------

Required

 getItem 

    (data: any, index: number) => any;

 

A generic accessor for extracting an item from any sort of data blob.

  Type
  ----------
  function

------------------------------------------------------------------------

Required

 getItemCount 

    (data: any) => number;

 

Determines how many items are in the data blob.

  Type
  ----------
  function

------------------------------------------------------------------------

Required

 renderItem 

    (info: any) => ?React.Element<any>

 

Takes an item from  data and renders it into the list

  Type
  ----------
  function

------------------------------------------------------------------------

 CellRendererComponent 

CellRendererComponent allows customizing how cells rendered by
 renderItem /  ListItemComponent are wrapped when placed into the
underlying ScrollView. This component must accept event handlers which
notify VirtualizedList of changes within the cell.

  Type
  -----------------------------------------
   React.ComponentType<CellRendererProps>

------------------------------------------------------------------------

 ItemSeparatorComponent 

Rendered in between each item, but not at the top or bottom. By default,
 highlighted and  leadingItem props are provided.  renderItem provides
 separators.highlight /  unhighlight which will update the  highlighted
prop, but you can also add custom props with  separators.updateProps .
Can be a React Component (e.g.  SomeComponent ), or a React element
(e.g.  <SomeComponent /> ).

  Type
  ------------------------------
  component, function, element

------------------------------------------------------------------------

 ListEmptyComponent 

Rendered when the list is empty. Can be a React Component (e.g.
 SomeComponent ), or a React element (e.g.  <SomeComponent /> ).

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 ListItemComponent 

Each data item is rendered using this element. Can be a React Component
Class, or a render function.

  Type
  ---------------------
  component, function

------------------------------------------------------------------------

 ListFooterComponent 

Rendered at the bottom of all the items. Can be a React Component (e.g.
 SomeComponent ), or a React element (e.g.  <SomeComponent /> ).

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 ListFooterComponentStyle 

Styling for internal View for  ListFooterComponent .

  Type            Required
  --------------- ----------
  ViewStyleProp   No

------------------------------------------------------------------------

 ListHeaderComponent 

Rendered at the top of all the items. Can be a React Component (e.g.
 SomeComponent ), or a React element (e.g.  <SomeComponent /> ).

  Type
  --------------------
  component, element

------------------------------------------------------------------------

 ListHeaderComponentStyle 

Styling for internal View for  ListHeaderComponent .

  Type
  ------------
  View Style

------------------------------------------------------------------------

 debug 

 debug will turn on extra logging and visual overlays to aid with
debugging both usage and implementation, but with a significant perf
hit.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 disableVirtualization 

  Deprecated. Virtualization provides significant performance and memory
  optimizations, but fully unmounts react instances that are outside of
  the render window. You should only need to disable this for debugging
  purposes.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 extraData 

A marker property for telling the list to re-render (since it implements
 PureComponent ). If any of your  renderItem , Header, Footer, etc.
functions depend on anything outside of the  data prop, stick it here
and treat it immutably.

  Type
  ------
  any

------------------------------------------------------------------------

 getItemLayout 

    (
      data: any,
      index: number,
    ) => {length: number, offset: number, index: number}

 

  Type
  ----------
  function

------------------------------------------------------------------------

 horizontal 

If  true , renders items next to each other horizontally instead of
stacked vertically.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 initialNumToRender 

How many items to render in the initial batch. This should be enough to
fill the screen but not much more. Note these items will never be
unmounted as part of the windowed rendering in order to improve
perceived performance of scroll-to-top actions.

  Type     Default
  -------- ---------
  number    10

------------------------------------------------------------------------

 initialScrollIndex 

Instead of starting at the top with the first item, start at
 initialScrollIndex . This disables the "scroll to top" optimization
that keeps the first  initialNumToRender items always rendered and
immediately renders the items starting at this initial index. Requires
 getItemLayout to be implemented.

  Type
  --------
  number

------------------------------------------------------------------------

 inverted 

Reverses the direction of scroll. Uses scale transforms of  -1 .

  Type
  ---------
  boolean

------------------------------------------------------------------------

 keyExtractor 

    (item: any, index: number) => string;

 

Used to extract a unique key for a given item at the specified index.
Key is used for caching and as the react key to track item re-ordering.
The default extractor checks  item.key , then  item.id , and then falls
back to using the index, like React does.

  Type
  ----------
  function

------------------------------------------------------------------------

 maxToRenderPerBatch 

The maximum number of items to render in each incremental render batch.
The more rendered at once, the better the fill rate, but responsiveness
may suffer because rendering content may interfere with responding to
button taps or other interactions.

  Type
  --------
  number

------------------------------------------------------------------------

 onEndReached 

Called once when the scroll position gets within  onEndReachedThreshold
from the logical end of the list.

  Type
  --------------------------------------------
   (info: {distanceFromEnd: number}) => void

------------------------------------------------------------------------

 onEndReachedThreshold 

How far from the end (in units of visible length of the list) the
trailing edge of the list must be from the end of the content to trigger
the  onEndReached callback. Thus, a value of 0.5 will trigger
 onEndReached when the end of the content is within half the visible
length of the list.

  Type     Default
  -------- ---------
  number    2

------------------------------------------------------------------------

 onRefresh 

    () => void;

 

If provided, a standard  RefreshControl will be added for "Pull to
Refresh" functionality. Make sure to also set the  refreshing prop
correctly.

  Type
  ----------
  function

------------------------------------------------------------------------

 onScrollToIndexFailed 

    (info: {
      index: number,
      highestMeasuredFrameIndex: number,
      averageItemLength: number,
    }) => void;

 

Used to handle failures when scrolling to an index that has not been
measured yet. Recommended action is to either compute your own offset
and  scrollTo it, or scroll as far as possible and then try again after
more items have been rendered.

  Type
  ----------
  function

------------------------------------------------------------------------

 onStartReached 

Called once when the scroll position gets within
 onStartReachedThreshold from the logical start of the list.

  Type
  ----------------------------------------------
   (info: {distanceFromStart: number}) => void

------------------------------------------------------------------------

 onStartReachedThreshold 

How far from the start (in units of visible length of the list) the
leading edge of the list must be from the start of the content to
trigger the  onStartReached callback. Thus, a value of 0.5 will trigger
 onStartReached when the start of the content is within half the visible
length of the list.

  Type     Default
  -------- ---------
  number    2

------------------------------------------------------------------------

 onViewableItemsChanged 

Called when the viewability of rows changes, as defined by the
 viewabilityConfig prop.

  Type
  -------------------------------------------------------------------------------
   (callback: {changed:  ViewToken  , viewableItems:  ViewToken  }) => void

------------------------------------------------------------------------

 persistentScrollbar 

  Type
  ------
  bool

------------------------------------------------------------------------

 progressViewOffset 

Set this when offset is needed for the loading indicator to show
correctly.

  Type
  --------
  number

------------------------------------------------------------------------

 refreshControl 

A custom refresh control element. When set, it overrides the default
 <RefreshControl> component built internally. The onRefresh and
refreshing props are also ignored. Only works for vertical
VirtualizedList.

  Type
  ---------
  element

------------------------------------------------------------------------

 refreshing 

Set this true while waiting for new data from a refresh.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 removeClippedSubviews 

This may improve scroll performance for large lists.

  Note: May have bugs (missing content) in some circumstances - use at
  your own risk.

  Type
  ---------
  boolean

------------------------------------------------------------------------

 renderScrollComponent 

    (props: object) => element;

 

Render a custom scroll component, e.g. with a differently styled
 RefreshControl .

  Type
  ----------
  function

------------------------------------------------------------------------

 viewabilityConfig 

See  ViewabilityHelper.js for flow type and further documentation.

  Type
  -------------------
  ViewabilityConfig

------------------------------------------------------------------------

 viewabilityConfigCallbackPairs 

List of  ViewabilityConfig /  onViewableItemsChanged pairs. A specific
 onViewableItemsChanged will be called when its corresponding
 ViewabilityConfig 's conditions are met. See  ViewabilityHelper.js for
flow type and further documentation.

  Type
  ----------------------------------------
  array of ViewabilityConfigCallbackPair

------------------------------------------------------------------------

 updateCellsBatchingPeriod 

Amount of time between low-pri item render batches, e.g. for rendering
items quite a ways off screen. Similar fill rate/responsiveness tradeoff
as  maxToRenderPerBatch .

  Type
  --------
  number

------------------------------------------------------------------------

 windowSize 

Determines the maximum number of items rendered outside of the visible
area, in units of visible lengths. So if your list fills the screen,
then  windowSize={21} (the default) will render the visible screen area
plus up to 10 screens above and 10 below the viewport. Reducing this
number will reduce memory consumption and may improve performance, but
will increase the chance that fast scrolling may reveal momentary blank
areas of unrendered content.

  Type
  --------
  number

Methods 

 flashScrollIndicators() 

    flashScrollIndicators();

 

------------------------------------------------------------------------

 getScrollableNode() 

    getScrollableNode(): any;

 

------------------------------------------------------------------------

 getScrollRef() 

    getScrollRef():
      | React.ElementRef<typeof ScrollView>
      | React.ElementRef<typeof View>
      | null;

 

------------------------------------------------------------------------

 getScrollResponder() 

    getScrollResponder () => ScrollResponderMixin | null;

 

Provides a handle to the underlying scroll responder. Note that
 this._scrollRef might not be a  ScrollView , so we need to check that
it responds to  getScrollResponder before calling it.

------------------------------------------------------------------------

 scrollToEnd() 

    scrollToEnd(params?: {animated?: boolean});

 

Scrolls to the end of the content. May be janky without  getItemLayout
prop.

Parameters:

  Name     Type
  -------- --------
  params   object

Valid  params keys are:

-    'animated' (boolean) - Whether the list should do an animation
    while scrolling. Defaults to  true .

------------------------------------------------------------------------

 scrollToIndex() 

    scrollToIndex(params: {
      index: number;
      animated?: boolean;
      viewOffset?: number;
      viewPosition?: number;
    });

 

Valid  params consist of:

-   'index' (number). Required.
-   'animated' (boolean). Optional.
-   'viewOffset' (number). Optional.
-   'viewPosition' (number). Optional.

------------------------------------------------------------------------

 scrollToItem() 

    scrollToItem(params: {
      item: ItemT;
      animated?: boolean;
      viewOffset?: number;
      viewPosition?: number;
    );

 

Valid  params consist of:

-   'item' (Item). Required.
-   'animated' (boolean). Optional.
-   'viewOffset' (number). Optional.
-   'viewPosition' (number). Optional.

------------------------------------------------------------------------

 scrollToOffset() 

    scrollToOffset(params: {
      offset: number;
      animated?: boolean;
    });

 

Scroll to a specific content pixel offset in the list.

Param  offset expects the offset to scroll to. In case of  horizontal is
true, the offset is the x-value, in any other case the offset is the
y-value.

Param  animated (  true by default) defines whether the list should do
an animation while scrolling.

